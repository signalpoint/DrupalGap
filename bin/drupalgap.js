// Initialize the drupalgap json object.
var drupalgap = drupalgap || drupalgap_init(); // Do not remove this line.

/**
 * Initializes the drupalgap json object.
 * @return {Object}
 */
function drupalgap_init() {
  try {
    var dg = {
      modules: {
        core: [
           { name: 'block' },
           { name: 'comment' },
           { name: 'contact' },
           { name: 'entity' },
           { name: 'field' },
           { name: 'file' },
           { name: 'image' },
           { name: 'menu' },
           { name: 'mvc' },
           { name: 'node' },
           { name: 'search' },
           { name: 'system' },
           { name: 'taxonomy' },
           { name: 'user' },
           { name: 'views' }
         ]
      },
      module_paths: [],
      includes: [
          {name: 'common' },
          {name: 'form' },
          {name: 'menu' },
          {name: 'theme' }
      ],
      online: false,
      destination: '',
      api: {},
      back: false, /* moving backwards or not */
      back_path: '', /* the path to move back to */
      blocks: [],
      content_types_list: {}, /* holds info about each content type */
      date_formats: { }, /* @see system_get_date_formats() in Drupal core */
      date_types: { }, /* @see system_get_date_types() in Drupal core */
      entity_info: {},
      field_info_fields: {},
      field_info_instances: {},
      field_info_extra_fields: {},
      form_errors: {},
      form_states: [],
      loading: false, /* indicates if the loading message is shown or not */
      loader: 'loading', /* used to determine the jQM loader mode */
      messages: [],
      menus: {},
      menu_links: {},
      menu_router: {}, /* @todo - doesn't appear to be used at all, remove it */
      mvc: {
        models: {},
        views: {},
        controllers: {}
      },
      output: '', /* hold output generated by menu_execute_active_handler() */
      page: {
        jqm_events: [],
        title: '',
        variables: {},
        process: true,
        options: {} /* holds the current page's options, eg. reloadPage, etc. */
      },
      pages: [], /* Collection of page ids that are loaded into the DOM. */
      path: '', /* The current menu path. */
      remote_addr: null, /* php's $_SERVER['REMOTE_ADDR'] via system connect */
      router_path: '', /* The current menu router path. */
      services: {},
      sessid: null,
      settings: {},
      site_settings: {}, /* holds variable settings from the Drupal site */
      taxonomy_vocabularies: false, /* holds vocabs from system connect */
      theme_path: '',
      themes: [],
      theme_registry: {},
      views_datasource: {}
    };
    //if (drupalgap) { dg = $.extend({}, dg, drupalgap); }
    return dg;
  }
  catch (error) { console.log('drupalgap_init - ' + error); }
}

/**
 * This is called once the <body> element's onload is fired.
 */
function drupalgap_onload() {
  try {
    // At this point, the Drupal object has been initialized by jDrupal and has
    // loaded the app/settings.js into the <head>. Let's add DrupalGap's modules
    // onto the Drupal JSON object. Remember, all of the module source code is
    // included via the makefile's bin generation. However, the core modules
    // hook_install() implementations haven't been called yet, so we add them to
    // the module listing so they can be invoked later on.
    var modules = [
      'drupalgap',
      'block',
      'comment',
      'contact',
      'entity',
      'field',
      'file',
      'image',
      'menu',
      'mvc',
      'node',
      'search',
      'system',
      'taxonomy',
      'user',
      'views'
    ];
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      Drupal.modules.core[module] = module_object_template(module);
    }
    // Add PhoneGap's deviceready listener.
    document.addEventListener('deviceready', _drupalgap_deviceready, false);
  }
  catch (error) { console.log('drupalgap_onload - ' + error); }
}

/**
 * Implements PhoneGap's deviceready().
 */
function _drupalgap_deviceready() {
  try {
    // PhoneGap is loaded and it is now safe for DrupalGap to start...
    drupalgap_bootstrap();

    // Verify site path is set.
    if (!Drupal.settings.site_path || Drupal.settings.site_path == '') {
      var msg = 'No site_path to Drupal set in the app/settings.js file!';
      drupalgap_alert(msg, {
          title: 'Error'
      });
      return;
    }

    // Check device connection. If the device is offline, warn the user and then
    // go to the offline page.
    drupalgap_check_connection();
    if (!drupalgap.online) {
      module_invoke_all('device_offline');
      if (drupalgap.settings.offline_message) {
        drupalgap_alert(drupalgap.settings.offline_message, {
            title: 'Offline',
            alertCallback: function() { drupalgap_goto('offline'); }
        });
      }
      else {
        drupalgap_goto('offline');
      }
      return;
    }
    else {

      // Device is online, let's call any implementations of hook_deviceready().
      // If any implementation returns false, that means they don't want
      // DrupalGap to continue with the System Connect call, so we'll skip that
      // and go straight to the App's front page.
      var proceed = true;
      var invocation_results = module_invoke_all('deviceready');
      if (invocation_results && invocation_results.length > 0) {
        for (var i = 0; i < invocation_results.length; i++) {
          if (!invocation_results[i]) {
            proceed = false;
            break;
          }
        }
      }
      if (!proceed) {
        drupalgap_goto('');
        // @todo - if module's are going to skip the System Connect call, then
        // we need to make sure Drupal.user is set up with appropriate defaults.
      }
      else {
        // Device is online, let's build the default system connect options.
        var options = {
          success: function(result) {
            // Call all hook_device_connected implementations then go to
            // the front page.
            module_invoke_all('device_connected');
            drupalgap_goto('');
          },
          error: function(jqXHR, textStatus, errorThrown) {
            // Build an informative error message and display it.
            var msg = 'Failed connection to ' + drupalgap.settings.site_path;
            if (errorThrown != '') { msg += ' - ' + errorThrown; }
            msg += ' - Check your device\'s connection and check that ' +
                   Drupal.settings.site_path + ' is online.';
           drupalgap_alert(msg, {
               title: 'Unable to Connect',
               alertCallback: function() { drupalgap_goto('offline'); }
           });
          }
        };

        // Make the system connect call.
        system_connect(options);
      }
    }
  }
  catch (error) { console.log('_drupalgap_deviceready - ' + error); }
}

/**
 * Loads up all necessary assets to make DrupalGap ready.
 */
function drupalgap_bootstrap() {
  try {
    // Load up any contrib and/or custom modules (the DG core moodules have
    // already been loaded at this point), load the theme and all blocks. Then
    // build the menu router, load the menus, and build the theme registry.
    drupalgap_load_modules();
    drupalgap_load_theme();
    drupalgap_load_blocks();
    menu_router_build();
    drupalgap_menus_load();
    drupalgap_theme_registry_build();

    // Attach device back button handler (Android).
    document.addEventListener('backbutton', drupalgap_back, false);
  }
  catch (error) { console.log('drupalgap_bootstrap - ' + error); }
}

/**
 * Loads any contrib or custom modules specifed in the settings.js file. Then
 * invoke hook_install() on all modules, including core.
 */
function drupalgap_load_modules() {
  try {
    var module_types = ['contrib', 'custom'];
    // We only need to load contrib and custom modules because core modules are
    // already included in the binary.
    $.each(module_types, function(index, bundle) {
        // Let's be nice and try to load any old drupalgap.modules declarations
        // in developers settings.js files for a while, but throw a warning to
        // encourage them to update. This code can be removed after a few
        // releases to help developers get caught up without angering them.
        if (
          drupalgap.modules &&
          drupalgap.modules[bundle] &&
          drupalgap.modules[bundle].length != 0
        ) {
          $.each(drupalgap.modules[bundle], function(index, module) {
              if (module.name) {
                var msg = 'WARNING: The module "' + module.name + '" defined ' +
                  'in settings.js needs to be added to ' +
                  'Drupal.modules[\'' + bundle + '\'] instead! See ' +
                  'default.settings.js for examples on the new syntax!';
                console.log(msg);
                Drupal.modules[bundle][module.name] = module;
              }
          });
        }
        $.each(Drupal.modules[bundle], function(module_name, module) {
            // If the module object is empty, initialize a module object.
            if ($.isEmptyObject(module)) {
              Drupal.modules[bundle][module_name] =
                module_object_template(module_name);
              module = Drupal.modules[bundle][module_name];
            }
            // If the module's name isn't set, set it.
            if (!module.name) {
              Drupal.modules[bundle][module_name].name = module_name;
              module = Drupal.modules[bundle][module_name];
            }
            // Determine module directory.
            var dir = drupalgap_modules_get_bundle_directory(bundle);
            module_base_path = dir + '/' + module.name;
            // Add module .js file to array of paths to load.
            module_path = module_base_path + '/' + module.name + '.js';
            modules_paths = [module_path];
            // If there are any includes with this module, add them to the
            // list of paths to include.
            if (module.includes != null && module.includes.length != 0) {
              $.each(module.includes, function(include_index, include_object) {
                modules_paths.push(
                  module_base_path + '/' + include_object.name + '.js'
                );
              });
            }
            // Now load all the paths for this module.
            $.each(modules_paths,
              function(modules_paths_index, modules_paths_object) {
                jQuery.ajax({
                    async: false,
                    type: 'GET',
                    url: modules_paths_object,
                    data: null,
                    success: function() {
                        //console.log('Loaded module: ' + modules_paths_object);
                    },
                    dataType: 'script',
                    error: function(xhr, textStatus, errorThrown) {
                      var msg = 'Failed to load module! (' + module.name + ')';
                      drupalgap_alert(msg);
                    }
                });
              }
            );
      });
    });
    // Now invoke hook_install on all modules, including core.
    module_invoke_all('install');
  }
  catch (error) { console.log('drupalgap_load_modules - ' + error); }
}

/**
 * Load the theme specified by drupalgap.settings.theme into drupalgap.theme
 * Returns true on success, false if it fails.
 * @return {Boolean}
 */
function drupalgap_load_theme() {
  try {
    if (!drupalgap.settings.theme) {
      var msg = 'drupalgap_load_theme - no theme specified in settings.js';
      drupalgap_alert(msg);
    }
    else {
      // Pull the theme name from the settings.js file.
      var theme_name = drupalgap.settings.theme;
      var theme_path = 'themes/' + theme_name + '/' + theme_name + '.js';
      if (theme_name != 'easystreet3') {
        theme_path = 'app/themes/' + theme_name + '/' + theme_name + '.js';
      }
      if (!drupalgap_file_exists(theme_path)) {
        var error_msg = 'drupalgap_theme_load - Failed to load theme! ' +
          'The theme\'s JS file does not exist: ' + theme_path;
        drupalgap_alert(error_msg);
        return false;
      }
      // We found the theme's js file, add it to the page.
      drupalgap_add_js(theme_path);
      // Call the theme's template_info implementation.
      var template_info_function = theme_name + '_info';
      if (drupalgap_function_exists(template_info_function)) {
        var fn = window[template_info_function];
        drupalgap.theme = fn();
        // For each region in the name, set the 'name' value on the region JSON.
        $.each(drupalgap.theme.regions, function(name, region) {
            drupalgap.theme.regions[name].name = name;
        });
        // Make sure the theme implements the required regions.
        var regions = system_regions_list();
        for (var i = 0; i < regions.length; i++) {
          var region = regions[i];
          if (typeof drupalgap.theme.regions[region] === 'undefined') {
            console.log('WARNING: drupalgap_load_theme() - The "' +
                        theme_name + '" theme does not have the "' + region +
                        '" region specified in "' + theme_name + '_info()."');
          }
        }
        // Theme loaded successfully! Set the drupalgap.theme_path and return
        // true.
        drupalgap.theme_path = theme_path.replace('/' + theme_name + '.js', '');
        return true;
      }
      else {
        var error_msg = 'drupalgap_load_theme() - failed - ' +
          template_info_function + '() does not exist!';
        drupalgap_alert(error_msg);
      }
    }
    return false;
  }
  catch (error) { console.log('drupalgap_load_theme - ' + error); }
}

/**
 * Given a path to a javascript file relative to the app's www directory,
 * this will load the javascript file so it will be available in scope.
 */
function drupalgap_add_js() {
  try {
    var data;
    if (arguments[0]) { data = arguments[0]; }
    jQuery.ajax({
      async: false,
      type: 'GET',
      url: data,
      data: null,
      success: function() {
        if (drupalgap.settings.debug) {
          // Print the js path to the console.
          console.log(data);
        }
      },
      dataType: 'script',
      error: function(xhr, textStatus, errorThrown) {
        console.log(
          'drupalgap_add_js - error - (' +
            data + ' : ' + textStatus +
          ') ' + errorThrown
        );
      }
    });
  }
  catch (error) {
    console.log('drupalgap_add_js - ' + error);
  }
}

/**
 * Given a path to a css file relative to the app's www directory, this will
 * attempt to load the css file so it will be available in scope.
 */
function drupalgap_add_css() {
  try {
    var data;
    if (arguments[0]) { data = arguments[0]; }
    $('<link/>', {rel: 'stylesheet', href: data}).appendTo('head');
  }
  catch (error) { console.log('drupalgap_add_css - ' + error); }
}

/**
 * Alerts a message to the user using PhoneGap's alert. It is important to
 * understand this is an async function, so code will continue to execute while
 * the alert is displayed to the user.
 * You may optionally pass in a second argument as a JSON object with the
 * following properties:
 *   alertCallback - the function to call after the user presses OK
 *   title - the title to use on the alert box, defaults to 'Alert'
 *   buttonName - the text to place on the button, default to 'OK'
 * @param {String} message
 */
function drupalgap_alert(message) {
  try {
    var options = null;
    if (arguments[1]) { options = arguments[1]; }
    var alertCallback = function() { };
    var title = 'Alert';
    var buttonName = 'OK';
    if (options) {
      if (options.alertCallback) { alertCallback = options.alertCallback; }
      if (options.title) { title = options.title; }
      if (options.buttonName) { buttonName = options.buttonName; }
    }
    navigator.notification.alert(message, alertCallback, title, buttonName);
  }
  catch (error) { console.log('drupalgap_alert - ' + error); }
}

/**
 * Displays a confirmation message to the user using PhoneGap's confirm. It is
 * important to understand this is an async function, so code will continue to
 * execute while the confirmation is displayed to the user.
 * You may optionally pass in a second argument as a JSON object with the
 * following properties:
 *   confirmCallback - the function to call after the user presses a button. The
 *               button label is passed to the function.
 *   title - the title to use on the alert box, defaults to 'Alert'
 *   buttonLabels - the text to place on the OK, and Cancel buttons, separated
 *                  by comma.
 * @param {String} message
 */
function drupalgap_confirm(message) {
  try {
    var options = null;
    if (arguments[1]) { options = arguments[1]; }
    var confirmCallback = function(button) { };
    var title = 'Confirm';
    var buttonLabels = ['OK', 'Cancel'];
    if (options) {
      if (options.confirmCallback) {
        confirmCallback = options.confirmCallback;
      }
      if (options.title) { title = options.title; }
      if (options.buttonLabels) { buttonLabels = options.buttonLabels; }
    }
    navigator.notification.confirm(
        message,
        confirmCallback,
        title,
        buttonLabels
    );
  }
  catch (error) { console.log('drupalgap_confirm - ' + error); }
}

/**
 * Rounds up all blocks defined by hook_block_info and places them in the
 * drupalgap.blocks array.
 */
function drupalgap_load_blocks() {
  try {
    /*drupalgap.blocks[0] = {};
    var modules = module_implements('block_info');
    if (modules) {
      $.each(modules, function(index, module){
          var blocks = module_invoke(module, 'block_info');
          if (blocks) {
            $.each(blocks, function(delta, block){
              // Assign the delta as the name of the block, set the delta of the
              // block as well, and set the module name on the block for
              // reference.
              block.name = delta;
              block.delta = delta;
              block.module = module;
              // Add the block to drupalgap.blocks.
              eval("drupalgap.blocks[0]." + delta + " = block;");
              //drupalgap.blocks[delta] = block;
            });
          }
      });
    }*/
    drupalgap.blocks = module_invoke_all('block_info');
    if (drupalgap.settings.debug) {
      console.log(JSON.stringify(drupalgap.blocks));
    }
  }
  catch (error) { console.log('drupalgap_load_blocks - ' + error); }
}

/**
 * Checks the devices connection and sets drupalgap.online to true if the
 * device has a connection, false otherwise.
 * @return {String}
 *   A string indicating the type of connection according to PhoneGap.
 */
function drupalgap_check_connection() {
  try {
    // We'll assume that Ripple emulation always has a connection, for now.
    // http://stackoverflow.com/q/15950382/763010
    if (typeof parent.window.ripple === 'function') {
      drupalgap.online = true;
      return 'Ethernet connection';
    }

    var networkState = navigator.connection.type;
    var states = {};
    states[Connection.UNKNOWN] = 'Unknown connection';
    states[Connection.ETHERNET] = 'Ethernet connection';
    states[Connection.WIFI] = 'WiFi connection';
    states[Connection.CELL_2G] = 'Cell 2G connection';
    states[Connection.CELL_3G] = 'Cell 3G connection';
    states[Connection.CELL_4G] = 'Cell 4G connection';
    states[Connection.NONE] = 'No network connection';
    if (states[networkState] == 'No network connection') {
      drupalgap.online = false;
    }
    else {
      drupalgap.online = true;
    }
    return states[networkState];
  }
  catch (error) { console.log('drupalgap_check_connection - ' + error); }
}

/**
 * @deprecated Use empty() instead.
 * Returns true if given value is empty. A generic way to test for emptiness.
 * @param {*} value
 * @return {Boolean}
 */
function drupalgap_empty(value) {
  try {
    console.log(
      'WARNING: drupalgap_empty() is deprecated! ' +
      'Use empty() instead.'
    );
    return empty(value);
  }
  catch (error) { console.log('drupalgap_empty - ' + error); }
}

/**
 * Checks if a given file exists, returns true or false.
 * @param  {string} path
 *   A path to a file
 * @return {bool}
 *   True if file exists, else false.
 */
function drupalgap_file_exists(path) {
  try {
    var file_exists = false;
    jQuery.ajax({
      async: false,
      type: 'HEAD',
      url: path,
      success: function() { file_exists = true; },
      error: function(xhr, textStatus, errorThrown) { }
    });
    return file_exists;
  }
  catch (error) { console.log('drupalgap_file_exists - ' + error); }
}

/**
 * Reads entire file into a string and returns the string. Returns false if
 * it fails.
 * @param {String} path
 * @param {Object} options
 * @return {String}
 */
function drupalgap_file_get_contents(path, options) {
  try {
    var file = false;
    var default_options = {
      type: 'GET',
      url: path,
      dataType: 'html',
      data: null,
      async: false,
      success: function(data) { file = data; },
      error: function(xhr, textStatus, errorThrown) {
        console.log(
          'drupalgap_file_get_contents - failed to load file (' + path + ')'
        );
      }
    };
    $.extend(default_options, options);
    jQuery.ajax(default_options);
    return file;
  }
  catch (error) { console.log('drupalgap_file_get_contents - ' + error); }
}

/**
 * @see https://api.drupal.org/api/drupal/includes!common.inc/function/format_interval/7
 * @param {Number} interval The length of the interval in seconds.
 * @return {String}
 */
function drupalgap_format_interval(interval) {
  try {
    // @TODO - deprecate this and move it to jDrupal as format_interval().
    var granularity = 2; if (arguments[1]) { granularity = arguments[1]; }
    var langcode = null; if (arguments[2]) { langcode = langcode[2]; }
    var units = {
      '1 year|@count years': 31536000,
      '1 month|@count months': 2592000,
      '1 week|@count weeks': 604800,
      '1 day|@count days': 86400,
      '1 hour|@count hours': 3600,
      '1 min|@count min': 60,
      '1 sec|@count sec': 1
    };
    var output = '';
    $.each(units, function(key, value) {
      var key = key.split('|');
      if (interval >= value) {
        var count = Math.floor(interval / value);
        output +=
          (output ? ' ' : '') +
          drupalgap_format_plural(
            count,
            key[0],
            key[1]
          );
        if (output.indexOf('@count') != -1) {
          output = output.replace('@count', count);
        }
        interval %= value;
        granularity--;
      }
      if (granularity == 0) { return false; }
    });
    return output ? output : '0 sec';
  }
  catch (error) { console.log('drupalgap_format_interval - ' + error); }
}

/**
 * @see http://api.drupal.org/api/drupal/includes%21common.inc/function/format_plural/7
 * @param {Number} count
 * @param {String} singular
 * @param {String} plural
 * @return {String}
 */
function drupalgap_format_plural(count, singular, plural) {
  try {
    // @TODO - deprecate this and move it to jDrupal as format_plural().
    if (count == 1) { return singular; }
    return plural;
  }
  catch (error) { console.log('drupalgap_format_plural - ' + error); }
}

/**
 * @deprecated - Use function_exists() instead.
 * @param {String} name
 * @return {Boolean}
 */
function drupalgap_function_exists(name) {
  try {
    return function_exists(name);
  }
  catch (error) { console.log('drupalgap_function_exists - ' + error); }
}

/**
 * Given an html string from a *.tpl.html file, this will extract all of the
 * placeholders names and return them in an array. Returns false otherwise.
 * @param {String} html
 * @return {*}
 */
function drupalgap_get_placeholders_from_html(html) {
  try {
    var placeholders = false;
    if (html) {
      placeholders = html.match(/(?!{:)([\w]+)(?=:})/g);
    }
    return placeholders;
  }
  catch (error) {
    console.log('drupalgap_get_placeholders_from_html - ' + error);
  }
}

/**
 * Returns the current page's title.
 * @return {String}
 */
function drupalgap_get_title() {
  try {
    return drupalgap.page.title;
  }
  catch (error) { console.log('drupalgap_get_title - ' + error); }
}

/**
 * Returns the IP Address of the current user as reported by PHP via the last
 * System Connect call's $_SERVER['REMOTE_ADDR'] value.
 * @return {String|Null}
 */
function drupalgap_get_ip() {
  try {
    return drupalgap.remote_addr;
  }
  catch (error) { console.log('drupalgap_get_ip - ' + error); }
}

/**
 * Given a router path, this will return an array containing the indexes of
 * where the wildcards (%) are present in the router path. Returns false if
 * there are no wildcards present.
 * @param {String} router_path
 * @return {Boolean}
 */
function drupalgap_get_wildcards_from_router_path(router_path) {
  try {
    // @todo - Is this function even used? Doesn't look like it.
    var wildcards = false;
    return wildcards;
  }
  catch (error) {
    console.log('drupalgap_get_wildcards_from_router_path - ' + error);
  }
}


/**
 * Given a drupal image file uri, this will return the path to the image on the
 * Drupal site.
 * @param {String} uri
 * @return {String}
 */
function drupalgap_image_path(uri) {
  try {
    var altered = false;
    // If any modules want to alter the path, let them do it.
    var modules = module_implements('image_path_alter');
    if (modules) {
      $.each(modules, function(index, module) {
          var result = module_invoke(module, 'image_path_alter', uri);
          if (result) {
            altered = true;
            uri = result;
            return false;
          }
      });
    }
    if (!altered) {
      // No one modified the image path, we'll use the default approach to
      // generating the image src path.
      var src = Drupal.settings.site_path + Drupal.settings.base_path + uri;
      if (src.indexOf('public://') != -1) {
        src = src.replace('public://', Drupal.settings.file_public_path + '/');
      }
      return src;
    }
    else { return uri; }
  }
  catch (error) { console.log('drupalgap_image_path - ' + error); }
}

/**
 * @deprecated - This is no longer needed since the includes are built via the
 * makefile. Loads the js files in includes specified by drupalgap.includes.
 */
function drupalgap_includes_load() {
  try {
    if (drupalgap.includes != null && drupalgap.includes.length != 0) {
      $.each(drupalgap.includes, function(index, include) {
          var include_path = 'includes/' + include.name + '.inc.js';
          jQuery.ajax({
              async: false,
              type: 'GET',
              url: include_path,
              data: null,
              success: function() {
                if (drupalgap.settings.debug) {
                  // Print the include path to the console.
                  console.log(include_path);
                }
              },
              dataType: 'script',
              error: function(xhr, textStatus, errorThrown) {
                console.log(errorThrown);
              }
          });
      });
    }
  }
  catch (error) { console.log('drupalgap_includes_load - ' + error); }
}

/**
 * Given an html list element id and an array of items, this will clear the
 * list, populate it with the items, and then refresh the list.
 * @param {String} list_css_selector
 * @param {Array} items
 */
function drupalgap_item_list_populate(list_css_selector, items) {
  try {
    // @todo - This could use some validation and alerts for improper input.
    $(list_css_selector).html('');
    for (var i = 0; i < items.length; i++) {
      $(list_css_selector).append($('<li></li>', { html: items[i] }));
    }
    $(list_css_selector).listview('refresh').listview();
  }
  catch (error) { console.log('drupalgap_item_list_populate - ' + error); }
}

/**
 * Given an html table element id and an array of rows, this will clear the
 * table, populate it with the rows, and then refresh the table.
 * @param {String} table_css_selector
 * @param {Array} rows
 * rows follow the.
 */
function drupalgap_table_populate(table_css_selector, rows) {
  try {
    // Select only the body. Other things are already setup
    table_css_selector = table_css_selector + '> tbody ';
    $(table_css_selector).html('');
    for (var i = 0; i < rows.length; i++) {
      var row = rows[i];
      var rowhtml = '';
      for (var j = 0; j < row.length; j++) {
          rowhtml = rowhtml + '<td>' + row[j] + '</td>';
      }
      $('<tr>').html(rowhtml).appendTo($(table_css_selector));
    }
    $(table_css_selector).rebuild();
  }
  catch (error) { console.log('drupalgap_table_populate - ' + error); }
}

/**
 * Given a jQM page event, and the corresponding callback function name that
 * handles the event, this function will call the callback function, if it has
 * not already been called on the current page. This really is only used by
 * menu_execute_active_handler() to prevent jQM from firing inline page event
 * handlers more than once. You may optionally pass in a 4th argument, a string,
 * to append to the suffix of the unique key of recorded fired page events.
 * @param {String} event
 * @param {String} callback
 * @param {*} page_arguments
 */
function drupalgap_jqm_page_event_fire(event, callback, page_arguments) {
  try {
    // Concatenate the event name and the callback name together into a unique
    // key so multiple callbacks can handle the same event.
    var key = event + '-' + callback;
    // Is there an optional 4th argument coming in (the suffix)?
    if (typeof arguments[3] !== 'undefined') {
      if (arguments[3]) { key += '-' + arguments[3]; }
    }
    if ($.inArray(key, drupalgap.page.jqm_events) == -1 &&
      drupalgap_function_exists(callback)) {
      drupalgap.page.jqm_events.push(key);
      var fn = window[callback];
      if (page_arguments) {
        // If the page arguments aren't an array, place them into an array so
        // they can be applied to the callback function.
        if (!$.isArray(page_arguments)) { page_arguments = [page_arguments]; }
        fn.apply(null, Array.prototype.slice.call(page_arguments));
      }
      else { fn(); }
    }
  }
  catch (error) { console.log('drupalgap_jqm_page_event_fire - ' + error); }
}

/**
 * Returns array of jQM Page event names.
 * @return {Array}
 * @see http://api.jquerymobile.com/category/events/
 */
function drupalgap_jqm_page_events() {
  try {
    return [
      'pagebeforechange',
      'pagebeforecreate',
      'pagebeforehide',
      'pagebeforeload',
      'pagebeforeshow',
      'pagechange',
      'pagechangefailed',
      'pagecreate',
      'pagehide',
      'pageinit',
      'pageload',
      'pageloadfailed',
      'pageremove',
      'pageshow'
    ];
  }
  catch (error) { console.log('drupalgap_jqm_page_events - ' + error); }
}

/**
 * Given a JSON object with a page id, a jQM page event name, a callback
 * function to handle the jQM page event and any page arguments (as a JSON
 * string), this function will return the inline JS code needed to handle the
 * event. You may optionally pass in a unique second argument (string) to
 * allow the same page event handler to be fired more than once on a page.
 * @param {Object} options
 * @return {String}
 */
function drupalgap_jqm_page_event_script_code(options) {
  try {
    // Build the arguments to send to the event fire handler.
    var event_fire_args = '"' + options.jqm_page_event + '", "' +
      options.jqm_page_event_callback + '", ' +
      options.jqm_page_event_args;
    if (arguments[1]) { event_fire_args += ', "' + arguments[1] + '"'; }
    // Build the inline JS and return it.
    var script_code = '<script type="text/javascript">' +
      '$("#' + options.page_id + '").on("' +
        options.jqm_page_event + '", drupalgap_jqm_page_event_fire(' +
          event_fire_args +
        '));' +
    '</script>';
    return script_code;
  }
  catch (error) {
    console.log('drupalgap_jqm_page_event_script_code - ' + error);
  }
}

/**
 * Show the jQueryMobile loading message.
 * @see http://stackoverflow.com/a/16277865/763010
 */
function drupalgap_loading_message_show() {
  try {
    // Backwards compatability for versions prior to 7.x-1.6-alpha
    if (drupalgap.loading === 'undefined') { drupalgap.loading = false; }
    // Return if the loading message is already shown.
    if (drupalgap.loading) { return; }
    var options = drupalgap_loader_options();
    if (arguments[0]) { options = arguments[0]; }
    // Show the loading message.
    //$.mobile.loading('show', options);
    //drupalgap.loading = true;
    setTimeout(function() {
        $.mobile.loading('show', options);
        drupalgap.loading = true;
    }, 1);
  }
  catch (error) { console.log('drupalgap_loading_message_show - ' + error); }
}

/**
 * Hide the jQueryMobile loading message.
 */
function drupalgap_loading_message_hide() {
  try {
    /*$.mobile.loading('hide');
    drupalgap.loading = false;
    drupalgap.loader = 'loading';*/
    setTimeout(function() {
        $.mobile.loading('hide');
        drupalgap.loading = false;
        drupalgap.loader = 'loading';
    }, 100);
  }
  catch (error) { console.log('drupalgap_loading_message_hide - ' + error); }
}

/**
 * Returns the jQM loader options based on the current mode and settings.js.
 * @return {Object}
 */
function drupalgap_loader_options() {
  try {
    var mode = drupalgap.loader;
    var text = 'Loading...';
    var textVisible = true;
    if (mode == 'saving') { var text = 'Saving...'; }
    var options = {
      text: text,
      textVisible: textVisible
    };
    if (drupalgap.settings.loader && drupalgap.settings.loader[mode]) {
      options = drupalgap.settings.loader[mode];
    }
    return options;
  }
  catch (error) { console.log(' - ' + error); }
}

/**
 * Returns the suggested max width for elements within the content area.
 * @return {Number}
 */
function drupalgap_max_width() {
  try {
    var padding = parseInt($('.ui-content').css('padding'));
    if (isNaN(padding)) { padding = 16; } // use a 16px default if needed
    return $(document).width() - padding * 2;
  }
  catch (error) { console.log('drupalgap_max_width - ' + error); }
}

/**
 * Checks to see if the current user has access to the given path. Returns true
 * if the user has access, false otherwise. You may optionally pass in a user
 * account object as the second argument to check access on a specific user.
 * Also, you may optionally pass in an entity object as the third argument, if
 * that entity needs to be passed along to an 'access_callback' handler.
 * @param {String} path
 * @return {Boolean}
 */
function drupalgap_menu_access(path) {
  try {

    // User #1 is allowed to do anything, I mean anything.
    if (Drupal.user.uid == 1) { return true; }
    // Everybody else will not have access unless we prove otherwise.
    var access = false;
    if (drupalgap.menu_links[path]) {
      // Check to see if there is an access callback specified with the menu
      // link.
      if (typeof drupalgap.menu_links[path].access_callback === 'undefined') {
        // No access call back specified, if there are any access arguments
        // on the menu link, then it is assumed they are user permission machine
        // names, so check that user account's role(s) for that permission to
        // grant access.
        if (drupalgap.menu_links[path].access_arguments) {
          if ($.isArray(drupalgap.menu_links[path].access_arguments)) {
            $.each(drupalgap.menu_links[path].access_arguments, function(index, 
              permission) {
              access = user_access(permission);
              if (access) { return false; }
            });
          }
        }
        else {
          // There is no access callback and no access arguments specified with
          // the menu link, so we'll assume everyone has access.
          access = true;
        }
      }
      else {

        // An access callback function is specified for this path...

        // START HERE: https://github.com/signalpoint/DrupalGap/issues/191
        var function_name = drupalgap.menu_links[path].access_callback;
        if (drupalgap_function_exists(function_name)) {
          // Grab the access callback function. If there are any access args
          // send them along, or just call the function directly.
          // access arguments.
          var fn = window[function_name];
          if (drupalgap.menu_links[path].access_arguments) {
            var access_arguments =
              drupalgap.menu_links[path].access_arguments.slice(0);
            // If we have an entity loaded, replace the first integer we find
            // in the page arguments with the loaded entity.
            if (arguments[2]) {
              var entity = arguments[2];
              $.each(access_arguments, function(index, page_argument) {
                  if (is_int(parseInt(page_argument))) {
                    access_arguments[index] = entity;
                    return false;
                  }
              });
            }
            return fn.apply(null, Array.prototype.slice.call(access_arguments));
          }
          else { return fn(); }
        }
        else {
          console.log('drupalgap_menu_access - access call back (' +
            function_name + ') does not exist'
          );
        }
      }
    }
    else {
      console.log('drupalgap_menu_access - path (' + path + ') does not exist');
    }
    return access;
  }
  catch (error) { console.log('drupalgap_menu_access - ' + error); }
}

/**
 * @deprecated Use drupal_module_load() instead.
 * @param {String} name
 * @return {Object}
 */
function drupalgap_module_load(name) {
  try {
    return module_load(name);
  }
  catch (error) { console.log('drupalgap_module_load - ' + error); }
}

/**
 * Given a module bundle type, this will return the path to that module bundle's
 * directory.
 * @param {String} bundle
 * @return {String}
 */
function drupalgap_modules_get_bundle_directory(bundle) {
  try {
    dir = '';
    if (bundle == 'core') { dir = 'modules'; }
    else if (bundle == 'contrib') { dir = 'app/modules'; }
    else if (bundle == 'custom') { dir = 'app/modules/custom'; }
    return dir;
  }
  catch (error) {
    console.log('drupalgap_modules_get_bundle_directory - ' + error);
  }
}

/**
 * Given a router path (and optional path, defaults to current drupalgap path if
 * one isn't provided), this takes the path's arguments and replaces any
 * wildcards (%) in the router path with the corresponding path argument(s). It
 * then returns the assembled path. Returns false otherwise.
 * @param {String} input_path
 * @return {*}
 */
function drupalgap_place_args_in_path(input_path) {
  try {
    var assembled_path = false;
    if (input_path) {

      // Determine path to use and break it up into its args.
      var path = drupalgap_path_get();
      if (arguments[1]) { path = arguments[1]; }
      var path_args = arg(null, path);

      // Grab wild cards from router path then replace each wild card with
      // the corresponding path arg.
      var wildcards;
      var input_path_args = arg(null, input_path);
      if (input_path_args && input_path_args.length > 0) {
        $.each(input_path_args, function(index, arg) {
            if (arg == '%') {
              if (!wildcards) { wildcards = []; }
              wildcards.push(index);
            }
        });
        if (wildcards && wildcards.length > 0) {
          $.each(wildcards, function(index, wildcard) {
              if (path_args[wildcard]) {
                input_path_args[wildcard] = path_args[wildcard];
              }
          });
          assembled_path = input_path_args.join('/');
        }
      }
    }
    return assembled_path;
  }
  catch (error) {
    console.log('drupalgap_place_args_in_path - ' + error);
  }
}

/**
 * Given an args array, this returns true if the path in the array will have an
 * entity (id) present in it.
 * @param {Array} args
 * @return {Boolean}
 */
function drupalgap_path_has_entity_arg(args) {
  try {
    if (args.length > 1 &&
        (
          args[0] == 'comment' ||
          args[0] == 'file' ||
          args[0] == 'node' ||
          (args[0] == 'taxonomy' &&
            (args[1] == 'vocabulary' || args[1] == 'term')
          ) ||
          args[0] == 'user' ||
          args[0] == 'item'
        )
    ) { return true; }
    return false;
  }
  catch (error) { console.log('drupalgap_path_has_entity_arg - ' + error); }
}

/**
 * Given a page id, this will remove it from the DOM.
 * @param {String} page_id
 */
function drupalgap_remove_page_from_dom(page_id) {
  try {
    $('#' + page_id).empty().remove();
  }
  catch (error) { console.log('drupalgap_remove_page_from_dom - ' + error); }
}

/**
 * Sets a message to display to the user. Optionally pass in a second argument
 * to specify the message type: status, warning, error
 * @param {String} message
 */
function drupalgap_set_message(message) {
  try {
    if (empty(message)) { return; }
    var type = 'status';
    if (arguments[1]) { type = arguments[1]; }
    var msg = {
      message: message,
      type: type
    };
    drupalgap.messages.push(msg);
  }
  catch (error) { console.log('drupalgap_set_message - ' + error); }
}

/**
 * Clears the messages from the current page. Optionally pass in a page id to
 * clear messages from a particular page.
 */
function drupalgap_clear_messages() {
  try {
    var page_id = arguments[0];
    if (empty(page_id)) { page_id = drupalgap_get_page_id(); }
    $('#' + page_id + ' div.messages').remove();
  }
  catch (error) { console.log('drupalgap_clear_messages - ' + error); }
}

/**
 * Implementation of drupal_set_title().
 * @param {String} title
 */
function drupalgap_set_title(title) {
  try {
    if (title) { drupalgap.page.title = title; }
  }
  catch (error) { console.log('drupalgap_set_title - ' + error); }
}

/**
 * Implements hook_services_preprocess().
 * @param {Object} options
 */
function drupalgap_services_preprocess(options) {
  try {
    // Show the loading icon.
    drupalgap_loading_message_show();
  }
  catch (error) { console.log('drupalgap_services_preprocess - ' + error); }
}

/**
 * Implements hook_services_postprocess().
 * @param {Object} options
 * @param {Object} result
 */
function drupalgap_services_postprocess(options, result) {
  try {
    // Hide the loading icon.
    drupalgap_loading_message_hide();
  }
  catch (error) { console.log('drupalgap_services_postprocess - ' + error); }
}

/**
 * Implements hook_services_request_pre_postprocess_alter().
 * @param {Object} options
 * @param {*} result
 */
function drupalgap_services_request_pre_postprocess_alter(options, result) {
  try {
    // Extract drupalgap system connect service resource results.
    if (options.service == 'system' && options.resource == 'connect') {
      drupalgap.remote_addr = result.remote_addr;
      drupalgap.entity_info = result.entity_info;
      drupalgap.field_info_instances = result.field_info_instances;
      drupalgap.field_info_fields = result.field_info_fields;
      drupalgap.field_info_extra_fields = result.field_info_extra_fields;
      drupalgap.taxonomy_vocabularies =
        drupalgap_taxonomy_vocabularies_extract(
          result.taxonomy_vocabularies
        );
      drupalgap_service_resource_extract_results({
        service: options.service,
        resource: options.resource,
        data: result
      });
    }
    // Whenever a user logs in, out or registers, remove all pages from the DOM.
    else if (options.service == 'user' &&
      (options.resource == 'logout' || options.resource == 'login' ||
        options.resource == 'register')) {
      drupalgap_remove_pages_from_dom();
    }
    // Whenever an entity is created, updated or deleted, remove the
    // corresponing DrupalGap core page(s) from the DOM so the pages will be
    // rebuilt properly next time they are loaded.
    else if (
      in_array(options.resource, ['create', 'update', 'delete']) &&
      in_array(options.service, entity_types())
    ) {
      var entity_type = options.entity_type;
      var entity_id = options.entity_id;
      var bundle = options.bundle || null;
      var paths = [];
      if (options.resource != 'create') {
        var prefix = entity_type;
        if (in_array(entity_type, ['taxonomy_vocabulary', 'taxonomy_term'])) {
          prefix = prefix.replace('_', '/', prefix);
        }
        paths.push(prefix + '/' + entity_id);
        paths.push(prefix + '/' + entity_id + '/view');
        // @todo This page won't get removed since it is the current page...
        // maybe when an entity is updated or deleted, we need a transitional
        // page that says "Deleting [entity]..." that way we can remove this
        // page (since it is not possible to remove the current page in jQM).
        // Actually now that I think about, we should have a confirmation page
        // when deleting an entity just like Drupal, and that should take care
        // of the deletion case. Not sure what to do about the update case...
        // maybe some type of pageshow handler on entity view pages that can
        // remove the edit form for the entity.
        paths.push(prefix + '/' + entity_id + '/edit');
      }
      else {
        switch (entity_type) {
          case 'node':
            // @todo This page won't get removed since it is the current page...
            paths.push('node/add/' + bundle);
            break;
        }
      }
      // Add extras depending on the entity type.
      switch (entity_type) {
        case 'node': paths.push('node'); break;
        case 'taxonomy_vocabulary': paths.push('taxonomy/vocabularies'); break;
        case 'user': paths.push('user-listing'); break;
      }
      // Convert the paths to page ids, then remove them from the DOM.
      var pages = [];
      $.each(paths, function(index, path) {
          pages.push(drupalgap_get_page_id(path));
      });
      $.each(pages, function(index, page_id) {
          drupalgap_remove_page_from_dom(page_id);
      });
    }
  }
  catch (error) {
    console.log('drupalgap_services_request_pre_postprocess_alter - ' + error);
  }
}

/**
 * @deprecated - Loads the settings specified in app/settings.js into the app.
 */
function drupalgap_settings_load() {
  try {
    console.log('WARNING: drupalgap_settings_load() is deprecated!');
    //drupal_settings_load();
  }
  catch (error) {
    console.log('drupalgap_settings_load - ' + error);
  }
}

/**
 * This calls all implementations of hook_theme and builds the DrupalGap theme
 * registry.
 */
function drupalgap_theme_registry_build() {
  try {
    var modules = module_implements('theme');
    $.each(modules, function(index, module) {
        var function_name = module + '_theme';
        var fn = window[function_name];
        var hook_theme = fn();
        $.each(hook_theme, function(element, variables) {
            variables.path = drupalgap_get_path(
              'theme',
              drupalgap.settings.theme
            );
            drupalgap.theme_registry[element] = variables;
        });
    });
  }
  catch (error) { console.log('drupalgap_theme_registry_build - ' + error); }
}

/**
 * Given a variable name and value, this will save the value to local storage,
 * keyed by its name.
 * @param {String} name
 * @param {*} value
 * @return {*}
 */
function variable_set(name, value) {
  try {
    if (!value) { value = ' '; } // store null values as a single space*
    else if (is_int(value)) { value = value.toString(); }
    else if (typeof value === 'object') { value = JSON.stringify(value); }
    return window.localStorage.setItem(name, value);
    // * phonegap won't store an empty string in local storage
  }
  catch (error) { drupalgap_error(error); }
}

/**
 * Given a variable name and a default value, this will first attempt to load
 * the variable from local storage, if it can't then the default value will be
 * returned.
 * @param {String} name
 * @param {*} default_value
 * @return {*}
 */
function variable_get(name, default_value) {
  try {
    var value = window.localStorage.getItem(name);
    if (!value) { value = default_value; }
    if (value == ' ') { value = ''; } // Convert single spaces to empty strings.
    return value;
  }
  catch (error) { drupalgap_error(error); }
}

/**
 * Given a variable name, this will remove the value from local storage.
 * @param {String} name
 * @return {*}
 */
function variable_del(name) {
  try {
    return window.localStorage.removeItem(name);
  }
  catch (error) { drupalgap_error(error); }
}

/**
 * Returns the current time as a string with the format: "yyyy-mm-dd hh:mm:ss".
 * @return {String}
 */
function date_yyyy_mm_dd_hh_mm_ss() {
  try {
    var result;
    if (arguments[0]) { result = arguments[0]; }
    else { result = date_yyyy_mm_dd_hh_mm_ss_parts(); }
    return result['year'] + '-' + result['month'] + '-' + result['day'] + ' ' +
           result['hour'] + ':' + result['minute'] + ':' + result['second'];
  }
  catch (error) { console.log('date_yyyy_mm_dd_hh_mm_ss - ' + error); }
}

/**
 * Returns an array with the parts for the current time. You may optionally
 * pass in a JS date object to use that date instead.
 * @return {Array}
 */
function date_yyyy_mm_dd_hh_mm_ss_parts() {
  try {
    var result = [];
    var now = null;
    if (arguments[0]) { now = arguments[0]; }
    else { now = new Date(); }
    var year = '' + now.getFullYear();
    var month = '' + (now.getMonth() + 1);
    if (month.length == 1) { month = '0' + month; }
    var day = '' + now.getDate();
    if (day.length == 1) { day = '0' + day; }
    var hour = '' + now.getHours();
    if (hour.length == 1) { hour = '0' + hour; }
    var minute = '' + now.getMinutes();
    if (minute.length == 1) { minute = '0' + minute; }
    var second = '' + now.getSeconds();
    if (second.length == 1) { second = '0' + second; }
    result['year'] = year;
    result['month'] = month;
    result['day'] = day;
    result['hour'] = hour;
    result['minute'] = minute;
    result['second'] = second;
    return result;
  }
  catch (error) { console.log('date_yyyy_mm_dd_hh_mm_ss_parts - ' + error); }
}

/**
 * Given a year and month (0-11), this will return the number of days in that
 * month.
 * @see http://stackoverflow.com/a/1810990/763010
 * @param {Number} year
 * @param {Number} month
 * @return {Number}
 */
function date_number_of_days_in_month(year, month) {
  try {
    var d = new Date(year, month, 0);
    return d.getDate();
  }
  catch (error) { console.log('date_number_of_days_in_month - ' + error); }
}

/**
 * @see http://www.dconnell.co.uk/blog/index.php/2012/03/12/scroll-to-any-element-using-jquery/
 */
function scrollToElement(selector, time, verticalOffset) {
  try {
    time = typeof(time) != 'undefined' ? time : 1000;
    verticalOffset = typeof(verticalOffset) != 'undefined' ? verticalOffset : 0;
    element = $(selector);
    offset = element.offset();
    offsetTop = offset.top + verticalOffset;
    $('html, body').animate({
        scrollTop: offsetTop
    }, time);
  }
  catch (error) { console.log('scrollToElement - ' + error); }
}

/**
 * Given a page id, and the theme's page.tpl.html string, this takes the page
 * template html and adds it to the DOM. It doesn't actually render the page,
 * that is taken care of by pagebeforechange when it calls the template system.
 * @param {String} page_id
 * @param {String} html
 */
function drupalgap_add_page_to_dom(page_id, html) {
  try {
    // Set the page id, the page class name and add the page to the dom body.
    html = html.replace(/{:drupalgap_page_id:}/g, page_id);
    html = html.replace(
      /{:drupalgap_page_class:}/g,
      drupalgap_page_class_get(drupalgap.router_path)
    );
    $('body').append(html);
    // Add the page id to drupalgap.pages.
    drupalgap.pages.push(page_id);
  }
  catch (error) { console.log('drupalgap_add_page_to_dom - ' + error); }
}

/**
 * Attempts to remove given page from the DOM, will not remove the current page.
 * You may force the removal by passing in a second argument as a JSON object
 * with a 'force' property set to true.
 * @param {String} page_id
 */
function drupalgap_remove_page_from_dom(page_id) {
  try {
    var current_page_id = drupalgap_get_page_id(drupalgap_path_get());
    var options = {};
    if (arguments[1]) { options = arguments[1]; }
    if (current_page_id != page_id || options.force) {
      $('#' + page_id).empty().remove();
      delete drupalgap.pages[page_id];
    }
    else {
      console.log('WARNING: drupalgap_remove_page_from_dom() - not removing ' +
        'the current page (' + page_id + ') from the DOM!');
    }
  }
  catch (error) { console.log('drupalgap_remove_page_from_dom - ' + error); }
}

/**
 * Removes all pages from the DOM except the current one.
 */
function drupalgap_remove_pages_from_dom() {
  try {
    var current_page_id = drupalgap_get_page_id(drupalgap_path_get());
    $.each(drupalgap.pages, function(index, page_id) {
        if (current_page_id != page_id) {
          $('#' + page_id).empty().remove();
        }
    });
    // Reset drupalgap.pages to only contain the current page id.
    drupalgap.pages = [current_page_id];
  }
  catch (error) { console.log('drupalgap_remove_pages_from_dom - ' + error); }
}

/**
 * Converts a JSON object to an XML/HTML tag attribute string and returns the
 * string.
 * @param {Object} attributes
 * @return {String{
 */
function drupalgap_attributes(attributes) {
  try {
    var attribute_string = '';
    if (attributes) {
      $.each(attributes, function(name, value) {
          if (value != '') {
            // @todo - if someone passes in a value with double quotes, this
            // will break. e.g.
            // 'onclick':'_drupalgap_form_submit("' + form.id + "');'
            // will break, but
            // 'onclick':'_drupalgap_form_submit(\'' + form.id + '\');'
            // will work.
            attribute_string += name + '="' + value + '" ';
          }
          else {
            // The value was empty, just place the attribute name on the
            // element.
            attribute_string += name + ' ';
          }
      });
    }
    return attribute_string;
  }
  catch (error) { console.log('drupalgap_attributes - ' + error); }
}

/**
 * Used by drupalgap_render_region to check the visibility settings on region
 * links and blocks. Just like Drupal Blocks, this function checks the
 * visibility rules specified by role or pages specified in data. Returns true
 * by default, otherwise it will return true or false depending on the first
 * visibility setting present in data.
 * @param {String} type
 * @param {Object} data
 * @return {Boolean}
 */
function drupalgap_check_visibility(type, data) {
  try {
    var visible = true;
    if (typeof data === 'undefined') {
      console.log(
        'drupalgap_check_visibility - WARNING - no data provided for type (' +
        type + ')'
      );
    }
    // Roles.
    else if (typeof data.roles !== 'undefined' &&
      data.roles && data.roles.value && data.roles.value.length != 0) {
      $.each(data.roles.value, function(role_index, role) {
          if (drupalgap_user_has_role(role)) {
            // User has role, show/hide the block accordingly.
            if (data.roles.mode == 'include') { visible = true; }
            if (data.roles.mode == 'exclude') { visible = false; }
          }
          else {
            // User does not have role, show/hide the block accordingly.
            if (data.roles.mode == 'include') { visible = false; }
            if (data.roles.mode == 'exclude') { visible = true; }
          }
          // Break out of the loop if already determined to be visible.
          if (visible) { return false; }
      });
    }
    // Pages.
    else if (typeof data.pages !== 'undefined' && data.pages &&
      data.pages.value && data.pages.value.length != 0) {
      var current_path = drupalgap_path_get();
      var current_path_parts = current_path.split('/');
      $.each(data.pages.value, function(page_index, path) {
          if (path == '') { path = drupalgap.settings.front; }
          if (path == current_path) {
            if (data.pages.mode == 'include') { visible = true; }
            else if (data.pages.mode == 'exclude') { visible = false; }
            return false;
          }
          else {
            // It wasn't a direct path match, is there a wildcard that matches
            // the router path?
            if (path.indexOf('*') != -1) {
              var router_path =
                drupalgap_get_menu_link_router_path(current_path);
              if (router_path.replace(/%/g, '*') == path) {
                if (data.pages.mode == 'include') { visible = true; }
                else if (data.pages.mode == 'exclude') { visible = false; }
                return false;
              }
              else {
                var path_parts = path.split('/');
                var match = true;
                if (path_parts.length == 0) { match = false; }
                else if (path_parts.length == current_path_parts.length) {
                  for (var i = 0; i < path_parts.length; i++) {
                    if (path_parts[i] != current_path_parts[i]) {
                      match = false;
                      break;
                    }
                  }
                }
                if (data.pages.mode == 'include') { visible = false; }
                else if (data.pages.mode == 'exclude') { visible = true; }
                if (!match) { visible = !visible; }
              }
            }
            else {
              // There's no wildcard in the rule, and it wasn't a direct path
              // match.
              if (data.pages.mode == 'include') { visible = false; }
              else if (data.pages.mode == 'exclude') { visible = true; }
            }
          }
      });
    }
    return visible;
  }
  catch (error) { console.log('drupalgap_check_visibility - ' + error); }
}

/**
 * Given an entity type and entity, this will return the bundle name as a
 * string for the given entity, or null if the bundle is N/A.
 * @param {String} entity_type The entity type.
 * @param {Object} entity The entity JSON object.
 * @return {*}
 */
function drupalgap_get_bundle(entity_type, entity) {
  try {
    var bundle = null;
    switch (entity_type) {
      case 'node': bundle = entity.type; break;
      case 'comment':
      case 'file':
      case 'user':
      case 'taxonomy_vocabulary':
      case 'taxonomy_term':
        // These entity types don't have a bundle.
        break;
      default:
        console.log(
          'WARNING: drupalgap_get_bundle - unsupported entity type (' +
            entity_type +
          ')'
        );
        break;
    }
    return bundle;
  }
  catch (error) { console.log('drupalgap_get_bundle - ' + error); }
}

/**
 * Given a path, this will return the id for the page's div element.
 * For example, a string path of 'foo/bar' would result in an id of 'foo_bar'.
 * If no path is provided, it will return the current page's id.
 * @param {String} path
 * @return {String}
 */
function drupalgap_get_page_id(path) {
  try {
    if (!path) { path = drupalgap_path_get(); }
    var id = path.toLowerCase().replace(/\//g, '_').replace(/-/g, '_');
    return id;
  }
  catch (error) { console.log('drupalgap_get_page_id - ' + error); }
}

/**
 * Returns the path to a system item (module, theme, etc.), returns false if it
 * can't find it.
 * @param {String} type
 * @param {String} name
 * @return {*}
 */
function drupalgap_get_path(type, name) {
  try {
    var path = null;
    if (type == 'module') {
      var found_module = false;
      $.each(Drupal.modules, function(bundle, modules) {
          if (found_module) { return false; }
          else {
            $.each(modules, function(index, module) {
                if (module.name == name) {
                  found_module = true;
                  path = '';
                  if (bundle == 'core') { path += 'modules'; }
                  else if (bundle == 'contrib') { path += 'app/modules'; }
                  else if (bundle == 'custom') { path += 'app/modules/custom'; }
                  else {
                    var msg = 'drupalgap_get_path - unknown module bundle (' +
                      bundle +
                    ')';
                    drupalgap_alert(msg);
                    return false;
                  }
                  path += '/' + name;
                  return false;
                }
            });
          }
      });
    }
    else if (type == 'theme') {
      if (name == 'easystreet3') { path = 'themes/' + name; }
      else { path = 'app/themes/' + name; }
    }
    else {
      console.log(
        'WARNING: drupalgap_get_path - unsupported type (' + type + ')'
      );
    }
    return path;
  }
  catch (error) { console.log('drupalgap_get_path - ' + error); }
}

/**
 * Change the page to the previous page.
 */
function drupalgap_back() {
  try {
    if (drupalgap_path_get() != drupalgap.settings.front) {
      drupalgap.back = true;
      history.back();
      drupalgap_path_set(drupalgap.back_path);
    }
  }
  catch (error) { console.log('drupalgap_back' + error); }
}

/**
 * Given an error message, this will log the message to the console and goto
 * the error page, if it isn't there already. If drupalgap.settings.debug is set
 * to true, this function will also alert the error. You may optionally send in
 * a second message that will be displayed to the user via an alert dialog box.
 * @param {String} message
 */
function drupalgap_error(message) {
  try {
    // Generate a developer error message, log it to the console, then alert
    // the message if debugging is enabled.
    var error_message = 'drupalgap_error() - ' +
                        arguments.callee.caller.name + ' - ' +
                        message;
    console.log(error_message);
    if (drupalgap.settings.debug) { drupalgap_alert(error_message); }
    // If a message for the user was passed in, display it to the user.
    if (arguments[1]) { drupalgap_alert(arguments[1]); }
    // Goto the error page if we are not already there.
    if (drupalgap_path_get() != 'error') { drupalgap_goto('error'); }
  }
  catch (error) { console.log('drupalgap_error - ' + error); }
}

/**
 * Given a path, this will change the current page in the app.
 * @param {String} path
 * @return {*}
 */
function drupalgap_goto(path) {
  try {

    // Extract any incoming options, set any defaults that weren't provided,
    // then populate the global page options variable.
    var options = {};
    if (arguments[1]) {
      options = arguments[1];
      if (typeof options.form_submission === 'undefined') {
        options.form_submission = false;
      }
    }
    drupalgap.page.options = options;

    // Prepare the path.
    path = drupalgap_goto_prepare_path(path);
    if (!path) { return false; }

    // Invoke all implementations of hook_drupalgap_goto_preprocess().
    module_invoke_all('drupalgap_goto_preprocess', path);

    // Determine the router path.
    var router_path = drupalgap_get_menu_link_router_path(path);

    // Make sure we have a menu link item that can handle this router path,
    // otherwise we'll goto the 404 page.
    if (!drupalgap.menu_links[router_path]) {
      // Is anyone trying to handle this 404?
      var new_path = false;
      var invocation_results = module_invoke_all('404', router_path);
      if (invocation_results) {
        $.each(invocation_results, function(index, result) {
            if (result !== false) {
              new_path = result;
              return false;
            }
        });
      }
      // If a 404 handler provided a new path use it, otherwise just use the
      // system 404 page. Either way, update the router path before continuing
      // with a normal page build.
      if (new_path) { path = new_path; }
      else { path = '404'; }
      router_path = drupalgap_get_menu_link_router_path(path);
    }

    // Make sure the user has access to this router path, if they don't send
    // them to the 401 page.
    // @TODO - for now we're going to skip access checks on local tasks, since
    // they are covered by menu_block_view(), but if someone were to navigate
    // directly to e.g. a node's edit page, they would be able to see the page.
    // Of course Drupal would actually prevent them from updating the node on
    // the live site, but nonetheless this needs to be fixed. It's a tough issue
    // though and related to https://github.com/signalpoint/DrupalGap/issues/257
    if (
      drupalgap.menu_links[router_path].type != 'MENU_DEFAULT_LOCAL_TASK' &&
      drupalgap.menu_links[router_path].type != 'MENU_LOCAL_TASK' &&
      !drupalgap_menu_access(router_path)
    ) {
      path = '401';
      router_path = drupalgap_get_menu_link_router_path(path);
    }

    // If the new router path is the same as the current router path and the new
    // path is the same as the current path, don't go anywhere, unless it is a
    // form submission, then continue.
    if (router_path == drupalgap_router_path_get() &&
        drupalgap_path_get() == path &&
        !options.form_submission) {
      return false;
    }

    // Grab the page id.
    var page_id = drupalgap_get_page_id(path);

    // Return if we are trying to go to the path we are already on, unless this
    // was a form submission, then we'll let the page rebuild itself. For
    // accurracy we compare the jQM active page url with the destination page
    // id.
    // @todo - this boolean doesn't match the comment description of the code
    // block, i.e. the form_submission check is opposite of what it says
    if (drupalgap_jqm_active_page_url() == page_id && options.form_submission) {
      // Clear any messages from the page before returning.
      drupalgap_clear_messages();
      return false;
    }

    // Save the back path.
    drupalgap.back_path = drupalgap_path_get();

    // Set the current menu path to the path input.
    drupalgap_path_set(path);

    // Set the drupalgap router path.
    drupalgap_router_path_set(router_path);

    // If the page is already in the DOM and we're asked to reload it, then
    // remove the page and let it rebuild itself. If we're not reloading the
    // page and we're not in the middle of a form submission, prevent the page
    // from processing then change to it.
    if (drupalgap_page_in_dom(page_id)) {
      // If there are any hook_menu() item options for this router path, bring
      // them into the current options without overwriting any existing values.
      if (drupalgap.menu_links[router_path].options) {
        options = $.extend(
          {},
          drupalgap.menu_links[router_path].options,
          options
        );
      }
      // Reload the page? If so, remove the page from the DOM, delete the
      // reloadPage option, then set the reloadingPage option to true so others
      // down the line will know the page is reloading. We can't pass along the
      // actual reloadPage option since it may collide with jQM later on. We
      // have to use 'force' when removing the page from the DOM since DG won't
      // remove it since it thinks we are already on the page, so it won't
      // remove it.
      if (typeof options.reloadPage !== 'undefined' && options.reloadPage) {
        drupalgap_remove_page_from_dom(page_id, { force: true });
        delete options.reloadPage;
        options.reloadingPage = true;
      }
      else if (!options.form_submission) {
        // Clear any messages from the page.
        drupalgap_clear_messages();
        drupalgap.page.process = false;
        $.mobile.changePage('#' + page_id, options);
        // Invoke all implementations of hook_drupalgap_goto_post_process().
        module_invoke_all('drupalgap_goto_post_process', path);
        return;
      }
    }
    else if (typeof options.reloadPage !== 'undefined' && options.reloadPage) {
      // The page is not in the DOM, and we're being asked to reload it, this
      // can't happen, so we'll just delete the reloadPage option.
      delete options.reloadPage;
    }

    // Generate the page.
    drupalgap_goto_generate_page_and_go(path, page_id, options);

  }
  catch (error) { console.log('drupalgap_goto - ' + error); }
}

/**
 * Generate a JQM page by running it through the theme then attach the
 * page to the <body> of the document, then change to the page. Remember,
 * the rendering of the page does not take place here, that is covered by
 * the pagebeforechange event in theme.inc.js which happens after we change
 * the page here.
 * @param {String} path
 * @param {String} page_id
 * @param {Object} options
 */
function drupalgap_goto_generate_page_and_go(path, page_id, options) {
  try {
    var page_template_path = path_to_theme() + '/page.tpl.html';
    if (!drupalgap_file_exists(page_template_path)) {
      console.log(
        'drupalgap_goto_generate_page_and_go - ' +
        'page template does not exist! (' + page_template_path + ')'
      );
    }
    else {

      // If options wasn't set, set it as an empty JSON object.
      if (typeof options === 'undefined') { options = {}; }

      // Load the page template html file. Determine if we are going to cache
      // the template file or not.
      var file_options = {};
      if (drupalgap.settings.cache &&
          drupalgap.settings.cache.theme_registry !== 'undefined' &&
          !drupalgap.settings.cache.theme_registry) {
          file_options.cache = false;
       }
      var html = drupalgap_file_get_contents(page_template_path, file_options);

      if (html) {

        // Add page to DOM.
        drupalgap_add_page_to_dom(page_id, html);

        // Setup change page options if necessary.
        if (drupalgap_path_get() == path && options.form_submission) {
          options.allowSamePageTransition = true;
        }

        // Let's change to the page.
        if (typeof parent.window.ripple === 'function') {
          // The Ripple emulator seems to not like the 'index.html' prefix,
          // so we'll remove that.
          $.mobile.changePage('#' + page_id, options);
        }
        else {
          // Default change page.
          $.mobile.changePage('index.html#' + page_id, options);
        }

        // Invoke all implementations of hook_drupalgap_goto_post_process().
        module_invoke_all('drupalgap_goto_post_process', path);
      }
      else {
        drupalgap_alert(
          'drupalgap_goto_generate_page_and_go - ' +
          'failed to load theme\'s page.tpl.html file'
        );
      }
    }
  }
  catch (error) {
    console.log('drupalgap_goto_generate_page_and_go - ' + error);
  }
}

/**
 * Given a path, this function will do any necessary conversions to the path so
 * it is better understood by the menu system. For example, a path of "" in
 * Drupal is used to represent the front page, so this function would turn the
 * "" value into the App's actual front page (drupalgap.settings.front) path
 * value so the menu system routes it correctly.
 * @param {String} path
 * @return {String}
 */
function drupalgap_goto_prepare_path(path) {
  try {
    // If the path is an empty string, change it to the front page path.
    if (path == '') {
      if (!drupalgap.settings.front) {
        drupalgap_alert(
          'drupalgap_goto_prepare_path - ' +
          'no front page specified in settings.js!'
        );
        return false;
      }
      else { path = drupalgap.settings.front; }
    }
    // Change 'user' to 'user/login' for anonymous users, or change it to
    // e.g. 'user/123/view' for authenticated users.
    else if (path == 'user') {
      if (Drupal.user.uid != 0) {
        path = 'user/' + Drupal.user.uid + '/view';
      }
      else {
        path = 'user/login';
      }
    }
    return path;
  }
  catch (error) { console.log('drupalgap_goto_prepare_path - ' + error); }
}

/**
 * Given a router path, this will return the CSS class name that can be used for
 * the page container.
 * @param {String} router_path The page router path.
 * @return {String} A css class name.
 */
function drupalgap_page_class_get(router_path) {
  try {
    // Replace '/' and '%' with underscores, then trim any trailing underscores.
    var class_name = router_path.replace(/[\/%]/g, '_');
    while (class_name.lastIndexOf('_') == class_name.length - 1) {
      class_name = class_name.substr(0, class_name.length - 1);
    }
    return class_name;
  }
  catch (error) { console.log('drupalgap_page_class_get - ' + error); }
}

/**
 * Returns true if the given page id's page div already exists in the DOM.
 * @param {String} page_id
 * @return {Boolean}
 */
function drupalgap_page_in_dom(page_id) {
  try {
    var pages = $("body div[data-role$='page']");
    var page_in_dom = false;
    if (pages && pages.length > 0) {
      $.each(pages, function(index, page) {
          if (($(page).attr('id')) == page_id) {
            page_in_dom = true;
            return false;
          }
      });
    }
    return page_in_dom;
  }
  catch (error) { console.log('drupalgap_page_in_dom - ' + error); }
}

/**
 * Returns the URL of the active jQuery Mobile page.
 * @return {String}
 */
function drupalgap_jqm_active_page_url() {
  try {
    // WARNING: when the app first loads, this value may be much different than
    // you expect. It certainly is not the front page path, because on Android
    // for example it returns '/android_asset/www/index.html'. Also, when the
    // app first loads, activePage is null, so just return an empty string.
    if (!$.mobile.activePage) { return ''; }
    return $.mobile.activePage.data('url');
  }
  catch (error) { console.log('drupalgap_jqm_active_page_url - ' + error); }
}

/**
 * Get the current DrupalGap path.
 * @return {String}
 */
function drupalgap_path_get() {
  try {
    var path = drupalgap.path;
    return path;
  }
  catch (error) { console.log('drupalgap_path_get - ' + error); }
}

/**
 * Set the current DrupalGap path.
 * @param {String} path
 */
function drupalgap_path_set(path) {
  try { drupalgap.path = path; }
  catch (error) { console.log('drupalgap_path_set - ' + error); }
}

/**
 * Get the current DrupalGap router_path.
 * @return {String}
 */
function drupalgap_router_path_get() {
  try {
    var router_path = drupalgap.router_path;
    return router_path;
  }
  catch (error) { console.log('drupalgap_router_path_get - ' + error); }
}

/**
 * Set the current DrupalGap router_path.
 * @param {String} router_path
 */
function drupalgap_router_path_set(router_path) {
  try { drupalgap.router_path = router_path; }
  catch (error) { console.log('drupalgap_router_path_set - ' + error); }
}

/**
 * Renders the html string of the page content that is stored in
 * drupalgap.output.
 * @return {String}
 */
function drupalgap_render_page() {
  try {
    // Since the page output has already been assembled, render the content
    // based on the output type. The output type will either be an html string
    // or a drupalgap render object.
    var output = drupalgap.output;
    var output_type = $.type(output);
    var content = '';

    // If the output came back as a string, we can render it as is. If the
    // output came back as on object, render each element in it through the
    // theme system.
    if (output_type === 'string') {
      // The page came back as an html string.
      content = output;
    }
    else if (output_type === 'object') {
      // The page came back as a render object. Let's define the names of
      // variables that are reserved for theme processing.
      var render_variables = ['theme', 'view_mode', 'language'];

      // Is there a theme value specified in the output and the registry?
      if (output.theme && drupalgap.theme_registry[output.theme]) {

        // Extract the theme object template and determine the template file
        // name and path.
        var template = drupalgap.theme_registry[output.theme];
        var template_file_name = output.theme.replace(/_/g, '-') + '.tpl.html';
        var template_file_path = template.path + '/' + template_file_name;

        // Make sure the template file exists.
        if (drupalgap_file_exists(template_file_path)) {

          // Loads the template file's content into a string.
          var template_file_html = drupalgap_file_get_contents(
            template_file_path
          );
          if (template_file_html) {

            // What variable placeholders are present in the template file?
            var placeholders = drupalgap_get_placeholders_from_html(
              template_file_html
            );
            if (placeholders) {

              // Replace each placeholder with html.
              // @todo - each placeholder should have its own container div and
              // unique id.
              $.each(placeholders, function(index, placeholder) {
                  var html = '';
                  if (output[placeholder]) {
                    // Grab the element variable from the output.
                    var element = output[placeholder];
                    // If it is markup, render it as is, if it is themeable,
                    // then theme it.
                    if (output[placeholder].markup) {
                      html = output[placeholder].markup;
                    }
                    else if (output[placeholder].theme) {
                      html = theme(output[placeholder].theme, element);
                    }
                    // Now remove the variable from the output.
                    delete output[placeholder];
                  }
                  // Now replace the placeholder with the html, even if it was
                  // empty.
                  eval(
                    'template_file_html = template_file_html.replace(/{:' +
                      placeholder +
                    ':}/g,html);'
                  );
              });
            }
            else {
              // There were no place holders found, do nothing, ok.
            }

            // Finally add the rendered template file to the content.
            content += template_file_html;
          }
          else {
            console.log(
              'drupalgap_render_page - failed to get file contents (' +
                template_file_path +
              ')'
            );
          }
        }
        else {
          console.log(
            'drupalgap_render_page - template file does not exist (' +
              template_file_path +
              ')'
            );
        }
      }

      // Iterate over any remaining variables and theme them.
      // @todo - each remaining variables should have its own container div and
      // unique id, similar to the placeholder div containers mentioned above.
      $.each(output, function(element, variables) {
          if ($.inArray(element, render_variables) == -1) {
            content += theme(variables.theme, variables);
          }
      });
    }

    // Now that we are done assembling the content into an html string, we can
    // return it.
    return content;
  }
  catch (error) { console.log('drupalgap_render_page - ' + error); }
}

/**
 * Given a region, this renders it and all the blocks in it. The blocks are
 * specified in the settings.js file, they are bundled under a region, which in
 * turn is bundled under a theme name. Returns an empty string if it fails.
 * @param {Object} region
 * @return {String}
 */
function drupalgap_render_region(region) {
  try {
    // Make sure there are blocks specified for this theme in settings.js.
    if (!drupalgap.settings.blocks[drupalgap.settings.theme]) {
      var msg = 'drupalgap_render_region - there are no blocks for the "' +
        drupalgap.settings.theme + '" theme in the settings.js file!';
      drupalgap_alert(msg);
      return '';
    }
    // Grab the current path.
    var current_path = drupalgap_path_get();
    // Let's render the region...
    var region_html = '';
    // If the region has blocks specified for it in the theme in settings.js...
    if (drupalgap.settings.blocks[drupalgap.settings.theme][region.name]) {
      // If a class attribute hasn't yet been provided, set a default, then
      // append a system class name for the region onto its attributes array.
      if (!region.attributes['class']) { region.attributes['class'] = ''; }
      region.attributes['class'] += ' region_' + region.name + ' ';
      // Open the region container.
      region_html += '<div ' + drupalgap_attributes(region.attributes) + '>';
      // If there are any links attached to this region, render them first.
      if (region.links && region.links.length > 0) {
        for (var i = 0; i < region.links.length; i++) {
          // Extract the data associated with this link. If it has a 'region'
          // property then it is coming from a hook_menu, if it doesn't then it
          // is coming from settings.js.
          var data = null;
          if (typeof region.links[i].region === 'undefined') {
            data = region.links[i]; // link defined in settings.js
            // TODO - we need to warn people that they can't make a custom menu
            // with a machine name of 'regions' now that this machine name is a
            // "system" name for rendering links in regions.
          }
          else {
            data = region.links[i].region; // link defined via hook_menu()
          }
          // Check link's region visiblity settings. Links will not be rendered
          // on the system 'offline' or 'error' pages.
          var render_link = false;
          if (drupalgap_check_visibility('region', data)) {
            render_link = true;
            if (current_path == 'offline' || current_path == 'error') {
              render_link = false;
            }
            if (render_link) {
              region_html += l(
                region.links[i].title,
                region.links[i].path,
                data.options
              );
            }
          }
        }
      }
      // Render each block in the region.
      $.each(drupalgap.settings.blocks[drupalgap.settings.theme][region.name],
        function(block_delta, block_settings) {
          // Check the block's visibility settings.
          var render_block = false;
          if (drupalgap_check_visibility('block', block_settings)) {
            render_block = true;
            // The 'offline' and 'error' pages only have the 'main' system
            // block visible.
            if (block_delta != 'main' && (
              current_path == 'offline' || current_path == 'error')
            ) { render_block = false; }
          }
          if (render_block) {
            var block = drupalgap_block_load(block_delta);
            if (block) {
              region_html += module_invoke(
                block.module,
                'block_view',
                block_delta,
                region
              );
            }
          }
      });
      // Close the region container.
      region_html += '</div><!-- ' + region.name + ' -->';
    }
    return region_html;
  }
  catch (error) { console.log('drupalgap_render_region - ' + error); }
}

/**
 * An interal callback used to handle the setting of the page title during the
 * pageshow event.
 * @param {*} page_arguments
 */
function _drupalgap_page_title_pageshow(page_arguments) {
  try {
    var router_path = drupalgap_router_path_get();
    // Set the page title. First we'll see if the hook_menu() item has a
    // title variable set, then check for a title_callback function.
    var title_arguments = [];
    if (typeof drupalgap.menu_links[router_path].title !== 'undefined') {
      drupalgap_set_title(drupalgap.menu_links[router_path].title);
    }
    if (
      typeof drupalgap.menu_links[router_path].title_callback !== 'undefined'
    ) {
      var function_name = drupalgap.menu_links[router_path].title_callback;
      if (drupalgap_function_exists(function_name)) {
        // Grab the title callback function.
        var fn = window[function_name];
        // Place the internal success callback handler on the front of the
        // title arguments.
        title_arguments.unshift(_drupalgap_page_title_pageshow_success);
        // Are there any additional arguments to send to the title callback?
        if (drupalgap.menu_links[router_path].title_arguments) {
          // For each title argument, if the argument is an integer, grab the
          // corresponding arg(#), otherwise just push the arg onto the title
          // arguments.
          var args = arg(null, drupalgap_path_get());
          $.each(
            drupalgap.menu_links[router_path].title_arguments,
            function(index, object) {
              if (is_int(object) && args[object]) {
                title_arguments.push(args[object]);
              }
              else { title_arguments.push(object); }
          });
        }
        // Call the title callback function with the title arguments.
        drupalgap_set_title(
          fn.apply(
            null,
            Array.prototype.slice.call(title_arguments)
          )
        );
      }
    }
    else {
      _drupalgap_page_title_pageshow_success(drupalgap_get_title());
    }
  }
  catch (error) { console.log('_drupalgap_page_title_pageshow - ' + error); }
}

/**
 * An internal function used to set the page title when the page title callback
 * function is successful.
 * @param {String} title
 */
function _drupalgap_page_title_pageshow_success(title) {
  try {
    var id = system_title_block_id(drupalgap_path_get());
    $('h1#' + id).html(title);
  }
  catch (error) {
    console.log('_drupalgap_page_title_pageshow_success - ' + error);
  }
}

/**
 * Implementation of arg(index = null, path = null).
 * @return {*}
 */
function arg() {
  try {
    var result = null;
    // If there were zero or one arguments provided.
    if (arguments.length == 0 || arguments.length == 1) {
      // Split the path into parts.
      var drupalgap_path = drupalgap_path_get();
      var args = drupalgap_path.split('/');
      // If no arguments were provided just return the split array, otherwise
      // return whichever argument was requested.
      if (arguments.length == 0) { result = args; }
      else if (args[arguments[0]]) { result = args[arguments[0]]; }
    }
    else {
      // A path was provided, split it into parts, then return the split array
      // if they didn't request a specific index, otherwise return the value of
      // the specific index inside the split array.
      var path = arguments[1];
      var args = path.split('/');
      if (arguments[0] && args[arguments[0]]) { result = args[arguments[0]]; }
      else { result = args; }
    }
    return result;
  }
  catch (error) { console.log('arg - ' + error); }
}

/**
 * Implemtation of l().
 * @return {String}
 */
function l() {
  try {
    // Grab the text and the path from the arguments and then build a simple
    // link object.
    var text = arguments[0];
    var path = arguments[1];
    var link = {'text': text, 'path': path};
    // Determine if there are any incoming link options, if there are, attach
    // them to the link object. If there are any attributes, extract them from
    // the options and attach them directly to the link object.
    var options = null;
    if (arguments[2]) {
      options = arguments[2];
      if (options.attributes) { link.attributes = options.attributes; }
      link.options = options;
    }
    return theme('link', link);
  }
  catch (error) { console.log('l - ' + error); }
}

/**
 * Internal function used to dynamically add another element item to a form for
 * unlimited value fields.
 * @param {String} form_id
 * @param {String} name
 * @param {Number} delta
 */
function _drupalgap_form_add_another_item(form_id, name, delta) {
  try {
    // Locate the last item, load the form, extract the element from
    // the form, generate default variables for the new item, determine the next
    // delta value.
    var selector = '.' + drupalgap_form_get_element_container_class(name) +
      ' .drupalgap_form_add_another_item';
    var add_another_item_button = $(selector);
    var form = drupalgap_form_local_storage_load(form_id);
    var language = language_default();
    var item = drupalgap_form_element_item_create(
      name,
      form,
      language,
      delta + 1
    );
    form.elements[name][language][delta + 1] = item;
    var element = form.elements[name];
    var variables = {
      attributes: {},
      field_info_field: element.field_info_field,
      field_info_instance: element.field_info_instance
    };
    var field_widget_form_function =
      element.field_info_instance.widget.module + '_field_widget_form';
    window[field_widget_form_function].apply(
      null,
      _drupalgap_form_element_items_widget_arguments(
        form,
        null,
        element,
        language,
        delta + 1
      )
    );
    drupalgap_form_local_storage_save(form);
    $(add_another_item_button).before(
      _drupalgap_form_render_element_item(form, element, variables, item)
    );
  }
  catch (error) { console.log('_drupalgap_form_add_another_item - ' + error); }
}

/**
 * Returns a 'Cancel' button object that can be used on most forms.
 * @return {Object}
 */
function drupalgap_form_cancel_button() {
  try {
    return {
      'title': 'Cancel',
      attributes: {
        onclick: 'javascript:drupalgap_back();'
      }
    };
  }
  catch (error) { console.log('drupalgap_form_cancel_button - ' + error); }
}

/**
 * Given a jQuery selector to a form, this will clear all the elements on
 * the UI.
 * @see http://stackoverflow.com/a/6364313/763010
 */
function drupalgap_form_clear(form_selector) {
  try {
    $(':input', form_selector)
     .not(':button, :submit, :reset, :hidden')
     .val('')
     .removeAttr('checked')
     .removeAttr('selected');
  }
  catch (error) { console.log('drupalgap_form_clear - ' + error); }
}

/**
 * Given a form id, this will assemble and return the default form JSON object.
 * @param {String} form_id
 * @return {Object}
 */
function drupalgap_form_defaults(form_id) {
  try {
    var form = {};
    // Set the form id, elements and buttons.
    form.id = form_id;
    form.elements = {};
    form.buttons = {};
    // Create a prefix and suffix.
    form.prefix = '';
    form.suffix = '';
    // Create empty arrays for the form's validation and submission handlers,
    // then add the default call back functions to their respective array, if
    // they exist.
    form.validate = [];
    form.submit = [];
    var validate_function_name = form.id + '_validate';
    if (drupalgap_function_exists(validate_function_name)) {
      form.validate.push(validate_function_name);
    }
    var submit_function_name = form.id + '_submit';
    if (drupalgap_function_exists(submit_function_name)) {
      form.submit.push(submit_function_name);
    }
    // Finally, return the form.
    return form;
  }
  catch (error) { console.log('drupalgap_form_defaults - ' + error); }
}

/**
 * Given a form element, this will return true if access to the element is
 * permitted, false otherwise.
 * @param {Object} element
 * @return {Boolean}
 */
function drupalgap_form_element_access(element) {
  try {
    var access = true;
    if (element.access == false) { access = false; }
    return access;
  }
  catch (error) { console.log('drupalgap_form_element_access - ' + error); }
}

/**
 * Given a form element type, this will return the name of the module that
 * implements the hook_field_widget_form() for the element. Keep in mind for now
 * some of the module names don't exist, and are actually implemented inside
 * the field module. If no module is found, it returns false.
 * @param {String} type
 * @return {String}
 */
function drupalgap_form_element_get_module_name(type) {
  try {
    var module = false;
    switch (type) {
      case 'checkbox':
      case 'radios':
      case 'select':
        module = 'options';
        break;
      case 'image':
        module = 'image';
        break;
    }
    return module;
  }
  catch (error) {
    console.log('drupalgap_form_element_get_module_name - ' + error);
  }
}

/**
 * Given a form element name and the form_id, this generates an html id
 * attribute value to be used in the DOM. An optional third argument is a
 * string language code to use. An optional fourth argument is an integer delta
 * value to use on field elements.
 * @param {String} name
 * @param {String} form_id
 * @return {String}
 */
function drupalgap_form_get_element_id(name, form_id) {
  try {
    if (name == null || name == '') { return ''; }
    var id =
      'edit-' +
      form_id.toLowerCase().replace(/_/g, '-') + '-' +
      name.toLowerCase().replace(/_/g, '-');
    // Any language code to append to the id?
    if (arguments[2]) { id += '-' + arguments[2]; }
    // Any delta value to append to the id?
    if (typeof arguments[3] !== 'undefined') {
      id += '-' + arguments[3] + '-value';
    }
    return id;
  }
  catch (error) { console.log('drupalgap_form_get_element_id - ' + error); }
}

/**
 * Given an element name, this will return the class name to use on the
 * element's container.
 * @param {String} name
 * @return {String}
 */
function drupalgap_form_get_element_container_class(name) {
  try {
    return 'form-item field-name-' + name.replace(/_/g, '-');
  }
  catch (error) {
    console.log('drupalgap_form_get_element_container_class - ' + error);
  }
}

/**
 * Given a drupalgap form, this renders the form html and returns it.
 * @param {Object} form
 * @return {String}
 */
function drupalgap_form_render(form) {
  try {
    // @todo - we may possibly colliding html element ids!!! For example, I
    // think the node edit page gets an id of "node_edit" and possibly so does
    // the node edit form, which also may get an id of "node_edit". We may want
    // to prefix both the template page and form ids with prefixes, e.g.
    // drupalgap_page_* and drupalgap_form_*, but adding these prefixes could
    // get annoying for css selectors used in jQuery and CSS. What to do?

    // If no form id is provided, warn the user.
    if (!form.id) {
      return '<p>drupalgap_form_render() - missing form id!</p>' +
        JSON.stringify(form);
    }
    // If the form already exists in the DOM, remove it.
    if ($('form#' + form.id).length) { $('form#' + form.id).remove(); }
    // Render the prefix and suffix and wrap them in their own div.
    var prefix = form.prefix;
    if (!empty(prefix)) {
      prefix = '<div class="form_prefix">' + prefix + '</div>';
    }
    var suffix = form.suffix;
    if (!empty(suffix)) {
      suffix = '<div class="form_suffix">' + suffix + '</div>';
    }
    // Render the form's input elements.
    var form_elements = _drupalgap_form_render_elements(form);
    // Return the form html.
    var form_html =
    '<form id="' + form.id + '">' + prefix + '<div>' +
      '<div id="drupalgap_form_errors"></div>' +
      form_elements +
    '</div>' + suffix + '</form>';
    return form_html;
  }
  catch (error) { console.log('drupalgap_form_render - ' + error); }
}

/**
 * Given a form element name and an error message, this attaches the error
 * message to the drupalgap.form_errors array, keyed by the form element name.
 * @param {String} name
 * @param {String} message
 */
function drupalgap_form_set_error(name, message) {
  try {
    drupalgap.form_errors[name] = message;
  }
  catch (error) { console.log('drupalgap_form_set_error - ' + error); }
}

/**
 * Given a form, this function iterates over the form's elements and assembles
 * each element and value and places them into the form state's values. This
 * is similar to $form_state['values'] in Drupal.
 * @param {Object} form
 * @return {Object}
 */
function drupalgap_form_state_values_assemble(form) {
  try {
    var lng = language_default();
    var form_state = {'values': {}};
    $.each(form.elements, function(name, element) {
      if (name == 'submit') { return; } // Always skip the form 'submit'.
      var id = null;
      if (element.is_field) {
        form_state.values[name] = {};
        form_state.values[name][lng] = {};
        var allowed_values = element.field_info_field.cardinality;
        if (allowed_values == -1) {
          allowed_values = 1; // Convert unlimited value field to one for now...
        }
        for (var delta = 0; delta < allowed_values; delta++) {
          id = drupalgap_form_get_element_id(name, form.id, lng, delta);
          form_state.values[name][lng][delta] =
            _drupalgap_form_state_values_assemble_get_element_value(
              id,
              element
            );
        }
      }
      else {
        id = drupalgap_form_get_element_id(name, form.id);
        form_state.values[name] =
          _drupalgap_form_state_values_assemble_get_element_value(
            id,
            element
          );
      }
    });
    // Attach the form state to drupalgap.form_states keyed by the form id.
    drupalgap.form_states[form.id] = form_state;
    return form_state;
  }
  catch (error) {
    console.log('drupalgap_form_state_values_assemble - ' + error);
  }
}

/**
 *
 * @param {String} id
 * @param {Object} element
 * @return {String|Number}
 */
function _drupalgap_form_state_values_assemble_get_element_value(id, element) {
  try {
    var value = null;
    var selector = '';
    if (element.type == 'radios') {
      selector = 'input:radio[name="' + id + '"]:checked';
    }
    else { selector = '#' + id; }
    switch (element.type) {
      case 'checkbox':
        var _checkbox = $(selector);
        if ($(_checkbox).is(':checked')) { value = 1; }
        else { value = 0; }
        break;
      case 'list_boolean':
        var _checkbox = $(selector);
        if ($(_checkbox).is(':checked')) { value = $(_checkbox).attr('on'); }
        else { value = $(_checkbox).attr('off'); }
        break;
    }
    if (value === null) { value = $(selector).val(); }
    if (typeof value === 'undefined') { value = null; }
    return value;
  }
  catch (error) {
    console.log(
      '_drupalgap_form_state_values_assemble_get_element_value - ' +
      error
    );
  }
}

/**
 * Given a form id, this will render the form and return the html for the form.
 * Any additional arguments will be sent along to the form.
 * @param {String} form_id
 * @return {String}
 */
function drupalgap_get_form(form_id) {
  try {
    var html = '';
    var form = drupalgap_form_load.apply(
      null,
      Array.prototype.slice.call(arguments)
    );
    if (form) {
      // Render the form.
      html = drupalgap_form_render(form);
    }
    else {
      var msg = 'drupalgap_get_form - failed to get form (' + form_id + ')';
      drupalgap_alert(msg);
    }
    return html;
  }
  catch (error) { console.log('drupalgap_get_form - ' + error); }
}

/**
 * Given a form id, this will return the form JSON object assembled by the
 * form's call back function. If the form fails to load, this returns false.
 * @param {String} form_id
 * @return {Object}
 */
function drupalgap_form_load(form_id) {
  try {

    var form = drupalgap_form_defaults(form_id);

    // The form's call back function will be equal to the form id.
    var function_name = form_id;
    if (eval('typeof ' + function_name) == 'function') {

      // Grab the form's function.
      var fn = window[function_name];

      // Determine the language code.
      var language = language_default();

      // Build the form arguments by iterating over each argument then adding
      // each to to the form arguments, afterwards remove the argument at index
      // zero because that is the form id.
      var form_arguments = [];
      $.each(arguments, function(index, argument) {
            form_arguments.push(argument);
      });
      form_arguments.splice(0, 1);

      // Attach the form arguments to the form object.
      form.arguments = form_arguments;

      // If there were no arguments to pass along, call the function directly to
      // retrieve the form, otherwise call the function and pass along any
      // arguments to retrieve the form.
      if (form_arguments.length == 0) { form = fn(form, null); }
      else {
        // We must consolidate the form, form_state and arguments into one array
        // and then pass it along to the form builder.
        var consolidated_arguments = [];
        var form_state = null;
        consolidated_arguments.push(form);
        consolidated_arguments.push(form_state);
        $.each(form_arguments, function(index, argument) {
          consolidated_arguments.push(argument);
        });
        form = fn.apply(
          null,
          Array.prototype.slice.call(consolidated_arguments)
        );
      }

      // Set empty options and attributes properties on each form element if the
      // element does not yet have any. This allows others to more easily modify
      // options and attributes on an element without having to worry about
      // testing for nulls and creating empty properties first.
      $.each(form.elements, function(name, element) {
          // If this element is a field, load its field_info_field and
          // field_info_instance onto the element.
          var element_is_field = false;
          var field_info_field = drupalgap_field_info_field(name);
          if (field_info_field) {
            element_is_field = true;
            form.elements[name].field_info_field = field_info_field;
            form.elements[name].field_info_instance =
              drupalgap_field_info_instance(
                form.entity_type,
                name,
                form.bundle
              );
          }
          form.elements[name].is_field = element_is_field;
          // Set the name property on the element if it isn't already set.
          if (!form.elements[name].name) { form.elements[name].name = name; }
          // If the element is a field, we'll append a language code and delta
          // value to the element id, along with the field items appended
          // onto the element using the language code and delta values.
          var id = null;
          if (element_is_field) {
            // What's the number of allowed values (cardinality) on this field?
            // A cardinality of -1 means the field has unlimited values.
            var cardinality = parseInt(element.field_info_field.cardinality);
            if (cardinality == -1) {
              cardinality = 1; // we'll just add one element for now, until we
                               // figure out how to handle the 'add another
                               // item' feature.
            }
            // Initialize the item collections language code if it hasn't been.
            if (!form.elements[name][language]) {
              form.elements[name][language] = {};
            }
            // Prepare the item(s) for this element.
            for (var delta = 0; delta < cardinality; delta++) {
              // Prepare some item defaults.
              var item = drupalgap_form_element_item_create(
                name,
                form,
                language,
                delta
              );
              // If the delta for this item hasn't been created on the element,
              // create it using the default item values. Otherwise, merge the
              // default values into the pre existing item on the element.
              if (!form.elements[name][language][delta]) {
                form.elements[name][language][delta] = item;
              }
              else {
                $.extend(true, form.elements[name][language][delta], item);
              }
            }
          }
          else {
            // This element is not a field, setup default options if none
            // have been provided. Then set the element id.
            if (!element.options) {
              form.elements[name].options = {attributes: {}};
            }
            else if (!element.options.attributes) {
              form.elements[name].options.attributes = {};
            }
            id = drupalgap_form_get_element_id(name, form.id);
            form.elements[name].id = id;
            form.elements[name].options.attributes.id = id;
          }
      });

      // Give modules an opportunity to alter the form.
      module_invoke_all('form_alter', form, null, form_id);

      // Place the assembled form into local storage so _drupalgap_form_submit
      // will have access to the assembled form.
      drupalgap_form_local_storage_save(form);
    }
    else {
      var error_msg = 'drupalgap_form_load - no callback function (' +
                       function_name + ') available for form (' + form_id + ')';
      drupalgap_alert(error_msg);
    }
    return form;
  }
  catch (error) { console.log('drupalgap_form_load - ' + error); }
}

/**
 * Given a form id, this will delete the form from local storage.
 * If the form isn't in local storage, this returns false.
 * @param {String} form_id
 * @return {Object}
 */
function drupalgap_form_local_storage_delete(form_id) {
  try {
    var result = window.localStorage.removeItem(
      drupalgap_form_id_local_storage_key(form_id)
    );
    return result;
  }
  catch (error) {
    console.log('drupalgap_form_local_storage_delete - ' + error);
  }
}

/**
 * Given a form id, this will load the form from local storage and return it.
 * If the form isn't in local storage, this returns false.
 * @param {String} form_id
 * @return {Object}
 */
function drupalgap_form_local_storage_load(form_id) {
  try {
    var form = false;
    form = window.localStorage.getItem(
      drupalgap_form_id_local_storage_key(form_id)
    );
    if (!form) { form = false; }
    else { form = JSON.parse(form); }
    return form;
  }
  catch (error) { console.log('drupalgap_form_local_storage_load - ' + error); }
}

/**
 * Given a form, this will save the form to local storage, overwriting any
 * previously saved forms.
 * @param {Object} form
 */
function drupalgap_form_local_storage_save(form) {
  try {
    window.localStorage.setItem(
      drupalgap_form_id_local_storage_key(form.id),
      JSON.stringify(form)
    );
  }
  catch (error) { console.log('drupalgap_form_local_storage_save - ' + error); }
}

/**
 * Given a form id, this will return the local storage key used by DrupalGap
 * to save the assembled form to the device's local storage.
 * @param {String} form_id
 * @return {String}
 */
function drupalgap_form_id_local_storage_key(form_id) {
  try {
    return 'drupalgap_form_' + form_id;
  }
  catch (error) {
    console.log('drupalgap_form_id_local_storage_key - ' + error);
  }
}

/**
 * Renders all the input elements in a form.
 * @param {Object} form
 * @return {String}
 */
function _drupalgap_form_render_elements(form) {
  try {
    var content = '';
    var content_weighted = [];
    // For each form element, if the element objects name property isn't set,
    // set it, then render the element if access is permitted. While rendering
    // the elements, set them aside according to their widget weight so they
    // can be appended to the content string in the correct order later.
    $.each(form.elements, function(name, element) {
        if (!element.name) { element.name = name; }
        if (drupalgap_form_element_access(element)) {
          if (element.is_field && element.field_info_instance.widget.weight) {
            content_weighted[element.field_info_instance.widget.weight] =
              _drupalgap_form_render_element(form, element);
          }
          else {
            // Extract the bundle. Note, on comments the bundle is prefixed with
            // 'comment_node_' so we need to remove that to correctly map to the
            // potential extra fields data.
            var bundle = null;
            if (form.bundle) {
              bundle = form.bundle;
              if (
                form.entity_type == 'comment' &&
                form.bundle.indexOf('comment_node_') != -1
              ) {
                bundle = form.bundle.replace('comment_node_', '');
              }
            }
            // This is not a field, if it has a weight in
            // field_info_extra_fields use it, otherwise just append it to the
            // content.
            if (
              form.entity_type && bundle &&
              typeof drupalgap.field_info_extra_fields[bundle][name] !==
                'undefined' &&
              typeof
                drupalgap.field_info_extra_fields[bundle][name].weight !==
                'undefined'
            ) {
              var weight =
                drupalgap.field_info_extra_fields[bundle][name].weight;
              content_weighted[weight] =
              _drupalgap_form_render_element(form, element);
            }
            else { content += _drupalgap_form_render_element(form, element); }
          }
        }
    });
    // Prepend the weighted elements to the content.
    if (!empty(content_weighted)) {
      content = content_weighted.join('\n') + content;
    }
    // Add any form buttons to the form elements html, if access to the button
    // is permitted.
    if (form.buttons && form.buttons.length != 0) {
      $.each(form.buttons, function(name, button) {
          if (drupalgap_form_element_access(button)) {
            var attributes = {
              type: 'button',
              id: drupalgap_form_get_element_id(name, form.id)
            };
            if (button.attributes) { $.extend(attributes, button.attributes); }
            content += '<button ' + drupalgap_attributes(attributes) + '">' +
              button.title +
            '</button>';
          }
      });
    }
    return content;
  }
  catch (error) { console.log('_drupalgap_form_render_elements - ' + error); }
}

/**
 * Renders an input element for a form.
 * @param {Object} form
 * @param {Object} element
 * @return {String}
 */
function _drupalgap_form_render_element(form, element) {
  try {
    var html = '';

    if (!element) { return html; }

    // Extract the element name.
    var name = element.name;

    // Grab the language.
    var language = language_default();

    // We'll assume the element has no items (e.g. title, nid, vid, etc), unless
    // we determine later that this element is a field, then it'll have items.
    var items = false;

    // If this element is a field, extract the items from the language code and
    // determine what module and hook will handle the items. If the element is
    // not a field, just flatten it into a single item collection and determine
    // which module handles this element type. Keep in mind not all the modules
    // actually exist, and we've placed implementations into the field module.
    var module = false;
    var field_widget_form_function_name = false;
    var field_widget_form_function = false;
    if (element.is_field) {
      items = element[language];
      module = element.field_info_instance.widget.module;
    }
    else {
      items = {0: element};
      module = drupalgap_form_element_get_module_name(element.type);
    }
    if (module) {
      field_widget_form_function_name = module + '_field_widget_form';

      if (drupalgap_function_exists(field_widget_form_function_name)) {
        field_widget_form_function = window[field_widget_form_function_name];
      }
      else {
        console.log(
          'WARNING: _drupalgap_form_render_element() - ' +
          field_widget_form_function_name +
          '() does not exist for the "' + element.type + '" form element!'
        );
      }
    }

    // If there were no items, just return.
    if (!items || items.length == 0) { return html; }

    // Generate default variables.
    var variables = {
      attributes: {}
    };

    // Grab the info instance and info field for the field, then attach them
    // both to the variables object so all theme functions will have access
    // to that data.
    variables.field_info_field = element.field_info_field;
    variables.field_info_instance = element.field_info_instance;

    // Render the element item(s). Remember the final delta value for later.
    var delta = 0;
    var item_html = '';
    var item_label = '';
    $.each(items, function(delta, item) {

        // Overwrite the variable's attributes id with the item's id.
        variables.attributes.id = item.id;

        // Attach the item as the element onto variables.
        variables.element = item;

        // Create an array for the item's children if it doesn't exist already.
        // This is used by field widget forms to extend form elements.
        if (!items[delta].children) { items[delta].children = []; }

        // Generate the label for field items on delta zero only.
        if (element.is_field && delta == 0) {
          item.title = element.title;
          item_label = theme('form_element_label', {'element': item});
        }

        // If there wasn't a default value provided, set one. Then set the
        // default value into the variables' attributes. Although, if we have an
        // item value, just use that.
        if (!item.default_value) { item.default_value = ''; }
        variables.attributes.value = item.default_value;
        if (typeof item.value !== 'undefined') {
          variables.attributes.value = item.value;
        }

        // Call the hook_field_widget_form() if necessary. Merge any changes
        // to the item back into this item.
        if (field_widget_form_function) {
          field_widget_form_function.apply(
            null, [
              form,
              null,
              element.field_info_field,
              element.field_info_instance,
              language,
              items,
              delta,
              element
          ]);
          // @TODO - sometimes an item gets merged without a type here, why?
          // @UPDATE - did the recursive extend fix this?
          item = $.extend(true, item, items[delta]);
          // If the item type got lost, replace it.
          if (!item.type && element.type) { item.type = element.type; }
        }

        // Merge element attributes into the variables object.
        variables.attributes = $.extend(
          true,
          variables.attributes,
          item.options.attributes
        );

        // Render the element item.
        item_html = _drupalgap_form_render_element_item(
          form,
          element,
          variables,
          item
        );
    });

    // Show the 'Add another item' button on unlimited value fields.
    /*if (element.field_info_field &&
      element.field_info_field.cardinality == -1) {
      var add_another_item_variables = {
        text: 'Add another item',
        attributes: {
          'class': 'drupalgap_form_add_another_item',
          onclick:
            "javascript:_drupalgap_form_add_another_item('" +
              form.id + "', '" +
              element.name + "', " +
              delta +
            ')'
        }
      };
      html += theme('button', add_another_item_variables);
    }*/

    // Open the element container.
    var container_attributes = {
      'class': drupalgap_form_get_element_container_class(name)
    };
    if (element.type != 'hidden') {
      html += '<div ' + drupalgap_attributes(container_attributes) + '>';
    }

    // Add a label to the element, except submit and hidden elements. Any field
    // labels have already been rendered, other element labels must be manually
    // rendered here.
    if (element.type != 'submit' && element.type != 'hidden') {
      if (element.is_field) { html += item_label; }
      else {
        html += theme('form_element_label', {'element': element});
      }
    }

    // Add the item html if it isn't empty.
    if (item_html != '') { html += item_html; }

    // Add element description.
    if (element.description && element.type != 'hidden') {
      html += '<div>' + element.description + '</div>';
    }

    // Close the element container.
    if (element.type != 'hidden') { html += '</div>'; }

    // Return the element html.
    return html;

  }
  catch (error) { console.log('_drupalgap_form_render_element - ' + error); }
}

/**
 * Given a form, an element, the variables for a theme function, and the element
 * item, this will return the html rendering of the element item.
 * @param {Object} form
 * @param {Object} element
 * @param {Object} variables
 * @param {Object} item
 * @return {String}
 */
function _drupalgap_form_render_element_item(form, element, variables, item) {
  try {
    var html = '';
    // Depending on the element type, if necessary, adjust the variables and/or
    // theme function to be used, then render the element by calling its theme
    // function.
    // @TODO - this block of code should be moved into their respective
    // implementations of hook_field_widget_form().
    switch (item.type) {
      case 'text':
        item.type = 'textfield';
        break;
      case 'list_text':
      case 'list_float':
      case 'list_integer':
        item.type = 'select';
        break;
    }

    // Set the theme function.
    var theme_function = item.type;

    // If the element is disabled, add the 'disabled' attribute.
    if (element.disabled) { variables.attributes.disabled = ''; }

    // Make any preprocess modifications to the elements so they will map
    // cleanly to their theme function.
    // @todo A hook_field_widget_form() should be used instead here.
    if (item.type == 'submit') {
      // @todo - convert this to a field widget form hook?
      variables.attributes.onclick =
        '_drupalgap_form_submit(\'' + form.id + '\');';
      if (!variables.attributes['data-theme']) {
        variables.attributes['data-theme'] = 'b';
      }
      if (typeof variables.attributes.type === 'undefined') {
        variables.attributes.type = 'button';
      }
    }

    // Merge the item into variables.
    $.extend(variables, item);

    // If a value isn't set on variables, try to set it with the default value
    // on the item.
    if (typeof variables.value === 'undefined' || variables.value == null) {
      if (typeof item.default_value !== 'undefined') {
        variables.value = item.default_value;
      }
    }

    // Run the item through the theme system if a theme function exists, or try
    // to use the item markup, or let the user know the field isn't supported.
    if (drupalgap_function_exists('theme_' + theme_function)) {
      html += theme(theme_function, variables);
    }
    else {
      if (item.markup || item.markup == '') { html += item.markup; }
      else {
        // @todo - the reason for this warning sometimes happens because the
        // item.type is lost with $.extend in _drupalgap_form_render_element().
        // @update - if an item doesn't have a type, it gets set by the parent
        // element, so we should now always have a type available here.
        var msg = 'Field ' + item.type + ' not supported.';
        html += '<div><em>' + msg + '</em></div>';
        console.log('WARNING: _drupalgap_form_render_element_item() - ' + msg);
        dpm(item);
      }
    }

    // Render any item children. If the child has markup, just use the html,
    // otherwise run the child through theme().
    if (item.children && item.children.length > 0) {
      for (var i = 0; i < item.children.length; i++) {
        if (item.children[i].markup) { html += item.children[i].markup; }
        else if (item.children[i].type || item.children[i].theme) {
          var theme_type = item.children[i].type;
          if (!theme_type) { theme_type = item.children[i].theme; }
          // Is there a title for a label?
          if (item.children[i].title) {
            html += theme('form_element_label', {
                element: item.children[i]
            });
          }
          // Render the child with the theme system.
          html += theme(theme_type, item.children[i]);
        }
        else {
          console.log(
            'WARNING: _drupalgap_form_render_element_item - ' +
            'failed to render child ' + i + ' for ' + element.name
          );
        }
      }
    }

    return html;
  }
  catch (error) {
    console.log('_drupalgap_form_render_element_item - ' + error);
  }
}

/**
 * Given an element name, the form, a language code and a delta value, this
 * will return default values that can be used to place an item element into a
 * Forms API object.
 * @param {String} name
 * @param {Object} form
 * @param {String} language
 * @param {Number} delta
 * @return {Object}
 */
function drupalgap_form_element_item_create(name, form, language, delta) {
  try {
    // Generate the id for this element field item and set it and
    // some default options onto the element item.
    var id = drupalgap_form_get_element_id(name, form.id, language, delta);
    return {
      id: id,
      options: {
        attributes: {
          id: id
        }
      },
      required: form.elements[name].required
    };
  }
  catch (error) {
    console.log('drupalgap_form_element_item_create - ' + error);
  }
}

/**
 *
 * @param {Object} form
 * @param {Object} form_state
 * @param {Object} element
 * @param {String} language
 * @param {Number} delta
 * @return {Array}
 */
function _drupalgap_form_element_items_widget_arguments(form, form_state,
  element, language, delta) {
  try {
    var widget_arguments = [];
    widget_arguments.push(form); // form
    widget_arguments.push(form_state); // form state
    widget_arguments.push(element.field_info_field); // field
    widget_arguments.push(element.field_info_instance); // instance
    widget_arguments.push(language); // language
    widget_arguments.push(form.elements[element.name][language]); // items
    widget_arguments.push(delta); // delta
    widget_arguments.push(element); // element
    return widget_arguments;
  }
  catch (error) {
    console.log('_drupalgap_form_element_items_widget_arguments - ' + error);
  }
}

/**
 * Handles a drupalgap form's submit button click.
 * @param {String} form_id
 * @return {*}
 */
function _drupalgap_form_submit(form_id) {
  try {
    // Load the form from local storage.
    var form = drupalgap_form_local_storage_load(form_id);
    if (!form) {
      var msg = '_drupalgap_form_submit - failed to load form: ' + form_id;
      drupalgap_alert(msg);
      return false;
    }

    // Assemble the form state values.
    var form_state = drupalgap_form_state_values_assemble(form);

    // Clear out previous form errors.
    drupalgap.form_errors = {};

    // Build the form validation wrapper function.
    var form_validation = function() {
      try {

        // Call the form's validate function(s), if any.
        $.each(form.validate, function(index, function_name) {
            if (drupalgap.settings.debug) { console.log(function_name + '()'); }
            var fn = window[function_name];
            fn.apply(null, Array.prototype.slice.call([form, form_state]));
        });

        // Call drupalgap form's api validate.
        _drupalgap_form_validate(form, form_state);

        // If there were validation errors, show the form errors and stop the
        // form submission. Otherwise submit the form.
        if (!jQuery.isEmptyObject(drupalgap.form_errors)) {
          var html = '';
          $.each(drupalgap.form_errors, function(name, message) {
              html += message + '\n\n';
          });
          drupalgap_alert(html);
        }
        else { form_submission(); }
      }
      catch (error) {
        console.log('_drupalgap_form_submit - form_validation - ' + error);
      }
    };

    // Build the form submission wrapper function.
    var form_submission = function() {
      try {
        // Call the form's submit function(s), if any.
        $.each(form.submit, function(index, function_name) {
            var fn = window[function_name];
            fn.apply(null, Array.prototype.slice.call([form, form_state]));
        });
        // Remove the form from local storage.
        // @todo - we can't do this here because often times a form's submit
        // handler makes asynchronous calls (i.e. user login) and although the
        // form validated, server side may say the input was invalid, so the
        // user will still be on the form, except we already removed the form.
        //drupalgap_form_local_storage_delete(form_id);
      }
      catch (error) {
        console.log('_drupalgap_form_submit - form_submission - ' + error);
      }
    };

    // Get ready to validate and submit the form, but first...

    // If this is an entity form, and there is an image field on the form, we
    // need to asynchronously process the image field, then continue onward
    // with normal form validation and submission.
    if (form.entity_type &&
      image_fields_present_on_entity_type(form.entity_type, form.bundle)
    ) {
      _image_field_form_process(form, form_state, {
          success: form_validation
      });
    }
    else {
      // There were no image fields on the form, proceed normally with form
      // validation, which will in turn process the submission if there are no
      // validation errors.
      form_validation();
    }
  }
  catch (error) { console.log('_drupalgap_form_submit - ' + error); }
}

/**
 * When a service call results in an error, this function is used to extract the
 * request's response form errors into a human readble string and returns it. If
 * there are no form errors, it will return false.
 * @param {Object} form
 * @param {Object} form_state
 * @param {Object} xhr
 * @param {String} status
 * @param {String} message
 * @return {String|Boolean}
 */
function _drupalgap_form_submit_response_errors(form, form_state, xhr, status,
  message) {
  try {
    var responseText = JSON.parse(xhr.responseText);
    if (typeof responseText === 'object' && responseText.form_errors) {
      var msg = '';
      $.each(responseText.form_errors, function(element_name, error_msg) {
          if (error_msg != '') {
            // The element name tends to come back weird, e.g.
            // "field_art_type][und", so let's trim anything at and after
            // the first "]".
            var pos = element_name.indexOf(']');
            if (pos != -1) {
              element_name = element_name.substr(0, pos);
            }
            var label = element_name;
            if (
              form.elements[element_name] &&
              form.elements[element_name].title
            ) { label = form.elements[element_name].title; }
            msg += $('<div>(' + label + ') - ' +
              error_msg + '</div>').text() + '\n';
          }
      });
      if (msg != '') { return msg; }
    }
    return false;
  }
  catch (error) {
    console.log('_drupalgap_form_submit_response_errors - ' + error);
  }
}

/**
 * An internal function used by the DrupalGap forms api to validate all the
 * elements on a form.
 * @param {Object} form
 * @param {Object} form_state
 */
function _drupalgap_form_validate(form, form_state) {
  try {
    $.each(form.elements, function(name, element) {
        if (name == 'submit') { return; }
        if (element.required) {
          var valid = true;
          var value = null;
          if (element.is_field) {
            value = form_state.values[name][language_default()][0];
          }
          else { value = form_state.values[name]; }
          // Check for empty values.
          if (empty(value)) { valid = false; }
          // Check for a -1 value on a select list.
          else if (element.type == 'select' && value == -1) {
            // @todo - this approach to select list validation will not allow
            // a developer to have a select list option with a -1 value.
            valid = false;
          }
          if (!valid) {
            var field_title = name;
            if (element.title) { field_title = element.title; }
            drupalgap_form_set_error(
              name,
              'The ' + field_title + ' field is required.'
            );
          }
        }
    });
  }
  catch (error) { console.log('_drupalgap_form_validate - ' + error); }
}

/**
 * Themes a checkbox input.
 * @param {Object} variables
 * @return {String}
 */
function theme_checkbox(variables) {
  try {
    variables.attributes.type = 'checkbox';
    // Check the box?
    if (variables.checked) {
      variables.attributes.checked = 'checked';
    }
    var output = '<input ' + drupalgap_attributes(variables.attributes) + ' />';
    return output;
  }
  catch (error) { console.log('theme_checkbox - ' + error); }
}

/**
 * Themes a email input.
 * @param {Object} variables
 * @return {String}
 */
function theme_email(variables) {
  try {
    variables.attributes.type = 'email';
    var output = '<input ' + drupalgap_attributes(variables.attributes) + ' />';
    return output;
  }
  catch (error) { console.log('theme_email - ' + error); }
}

/**
 * Themes a form element label.
 * @param {Object} variables
 * @return {String}
 */
function theme_form_element_label(variables) {
  try {
    var element = variables.element;
    // By default, use the element id as the label for, unless the element is
    // a radio, then use the name.
    var label_for = '';
    if (element.id) { label_for = element.id; }
    else if (element.attributes && element.attributes['for']) {
      label_for = element.attributes['for'];
    }
    if (element.type == 'radios') { label_for = element.name; }
    // Render the label.
    var html =
      '<label for="' + label_for + '"><strong>' + element.title + '</strong>';
    if (element.required) { html += '*'; }
    html += '</label>';
    return html;
  }
  catch (error) { console.log('theme_form_element_label - ' + error); }
}

/**
 * Themes a number input.
 * @param {Object} variables
 * @return {String}
 */
function theme_number(variables) {
  try {
    variables.attributes.type = 'number';
    var output = '<input ' + drupalgap_attributes(variables.attributes) + ' />';
    return output;
  }
  catch (error) { console.log('theme_number - ' + error); }
}

/**
 * Themes a hidden input.
 * @param {Object} variables
 * @return {String}
 */
function theme_hidden(variables) {
  try {
    variables.attributes.type = 'hidden';
    if (!variables.attributes.value && variables.value != null) {
      variables.attributes.value = variables.value;
    }
    var output = '<input ' + drupalgap_attributes(variables.attributes) + ' />';
    return output;
  }
  catch (error) { console.log('theme_hidden - ' + error); }
}

/**
 * Themes a password input.
 * @param {Object} variables
 * @return {String}
 */
function theme_password(variables) {
  try {
    variables.attributes.type = 'password';
    var output = '<input ' + drupalgap_attributes(variables.attributes) + ' />';
    return output;
  }
  catch (error) { console.log('theme_password - ' + error); }
}

/**
 * Themes radio buttons.
 * @param {Object} variables
 * @return {String}
 */
function theme_radios(variables) {
  try {
    var radios = '';
    if (variables.options) {
      variables.attributes.type = 'radio';
      // Determine an id prefix to use.
      var id = 'radio';
      if (variables.attributes.id) {
        id = variables.attributes.id;
        delete variables.attributes.id;
      }
      // Set the radio name equal to the id if one doesn't exist.
      if (!variables.attributes.name) {
        variables.attributes.name = id;
      }
      // Init a delta value so each radio button can have a unique id.
      var delta = 0;
      $.each(variables.options, function(value, label) {
          if (value == 'attributes') { return; } // Skip the attributes.
          var checked = '';
          if (variables.value && variables.value == value) {
            checked = ' checked="checked" ';
          }
          var input_id = id + '_' + delta.toString();
          var input_label =
            '<label for="' + input_id + '">' + label + '</label>';
          radios += '<input id="' + input_id + '" value="' + value + '" ' +
                                 drupalgap_attributes(variables.attributes) +
                                 checked + ' />' + input_label;
          delta++;
      });
    }
    return radios;
  }
  catch (error) { console.log('theme_radios - ' + error); }
}

/**
 * Themes a select list input.
 * @param {Object} variables
 * @return {String}
 */
function theme_select(variables) {
  try {
    var options = '';
    if (variables.options) {
      $.each(variables.options, function(value, label) {
          if (value == 'attributes') { return; } // Skip the attributes.
          var selected = '';
          if (variables.value && variables.value == value) {
            selected = ' selected ';
          }
          options += '<option value="' + value + '" ' + selected + '>' +
            label +
          '</option>';
      });
    }
    return '<select ' + drupalgap_attributes(variables.attributes) + '>' +
      options +
    '</select>';
  }
  catch (error) { console.log('theme_select - ' + error); }
}

/**
 * Themes a text input.
 * @param {Object} variables
 * @return {String}
 */
function theme_textfield(variables) {
  try {
    variables.attributes.type = 'text';
    var output = '<input ' + drupalgap_attributes(variables.attributes) + ' />';
    return output;
  }
  catch (error) { console.log('theme_textfield - ' + error); }
}

/**
 * Themes a textarea input.
 * @param {Object} variables
 * @return {String}
 */
function theme_textarea(variables) {
  try {
    var output =
      '<div><textarea ' + drupalgap_attributes(variables.attributes) + '>' +
        variables.value +
      '</textarea></div>';
    return output;
  }
  catch (error) { console.log('theme_textarea - ' + error); }
}

/**
 * Execute the page callback associated with the current path and return its
 * content.
 * @return {Object}
 */
function menu_execute_active_handler() {
  try {

    // Determine the path and then grab the page id.
    var path = null;
    if (arguments[0]) { path = arguments[0]; }
    if (!path) { path = drupalgap_path_get(); }
    var page_id = drupalgap_get_page_id(path);

    // @todo - Make sure the user has access to this DrupalGap menu path!

    // Get the router path.
    var router_path = drupalgap_router_path_get();

    if (router_path) {

      // Call the page call back for this router path and send along any
      // arguments.
      var function_name = drupalgap.menu_links[router_path].page_callback;
      var page_arguments = [];
      if (drupalgap_function_exists(function_name)) {

        // Grab the page callback function and get ready to build the html.
        var fn = window[function_name];
        var content = '';

        // Are there any arguments to send to the page callback?
        if (drupalgap.menu_links[router_path].page_arguments) {
          // For each page argument, if the argument is an integer, grab the
          // corresponding arg(#), otherwise just push the arg onto the page
          // arguments. Then try to prepare any entity that may be present in
          // the url so the entity is sent via the page arguments to the page
          // callback, instead of just sending the integer.
          var args = arg(null, path);
          $.each(
            drupalgap.menu_links[router_path].page_arguments,
            function(index, object) {
              if (is_int(object) && args[object]) {
                page_arguments.push(args[object]);
              }
              else { page_arguments.push(object); }
            }
          );

          // Call the page callback function with the page arguments.
          content = fn.apply(null, Array.prototype.slice.call(page_arguments));
        }
        else {
          // There are no arguments, just return the page callback result.
          content = fn();
        }

        // If the content came back as a string, convert it to a render object
        // so any jQM page events can be attached to the content if necessary.
        if (typeof content === 'string') {
          content = {
            content: {
              markup: content
            }
          };
        }

        // Clear out any previous jQM page events, then if there are any jQM
        // event callback functions attached to the menu link for this page, set
        // each event up to be fired with inline JS on the page. We pass along
        // any page arguments to the jQM event handler function.
        drupalgap.page.jqm_events = [];
        var jqm_page_events = drupalgap_jqm_page_events();
        var jqm_page_event_args = null;
        if (page_arguments.length > 0) {
          jqm_page_event_args = JSON.stringify(page_arguments);
        }
        for (var i = 0; i < jqm_page_events.length; i++) {
          if (drupalgap.menu_links[router_path][jqm_page_events[i]]) {
            var jqm_page_event = jqm_page_events[i];
            var jqm_page_event_callback =
              drupalgap.menu_links[router_path][jqm_page_event];
            if (drupalgap_function_exists(jqm_page_event_callback)) {
              var options = {
                'page_id': page_id,
                'jqm_page_event': jqm_page_event,
                'jqm_page_event_callback': jqm_page_event_callback,
                'jqm_page_event_args': jqm_page_event_args
              };
              content[jqm_page_event] = {
                markup: drupalgap_jqm_page_event_script_code(options)
              };
            }
            else {
              console.log(
                'menu_execute_active_handler (' + path + ') - the jQM ' +
                jqm_page_event + ' call back function ' +
                jqm_page_event_callback + ' does not exist!'
              );
            }
          }
        }

        // Add a pageshow handler for the page title.
        var options = {
          'page_id': page_id,
          'jqm_page_event': 'pageshow',
          'jqm_page_event_callback': '_drupalgap_page_title_pageshow',
          'jqm_page_event_args': jqm_page_event_args
        };
        content['drupalgap_page_title_pageshow'] = {
          markup: drupalgap_jqm_page_event_script_code(options)
        };

        // And finally return the content.
        if (drupalgap.settings.debug) { dpm(content); }
        return content;
      }
      else {
        // No page call back specified.
        console.log(
          'menu_execute_active_handler - no page callback (' + router_path + ')'
        );
        console.log(JSON.stringify(drupalgap.menu_links[router_path]));
      }
    }
    else {
      // No router path.
      console.log(
        'menu_execute_active_handler - no router path (' + path + ')'
      );
    }
  }
  catch (error) {
    console.log('menu_execute_active_handler(' + path + ') - ' + error);
  }
}

/**
 * Gets a router item.
 * @return {Object}
 */
function menu_get_item() {
  try {
    var path = null;
    var router_item = null;
    if (arguments[0]) { path = arguments[0]; }
    if (arguments[1]) { router_item = arguments[1]; }
    if (path && drupalgap.menu_links[path]) {
      return eval('drupalgap.menu_links.' + path + ';');
    }
    else { return null; }
  }
  catch (error) { console.log('menu_get_item - ' + error); }
}


/**
 * Returns an array containing the names of system-defined (default) menus.
 * @return {Object}
 */
function menu_list_system_menus() {
  try {
    var system_menus = {
      'user_menu_anonymous': {
        'title': 'User menu authenticated'
      },
      'user_menu_authenticated': {
        'title': 'User menu authenticated'
      },
      'main_menu': {
        'title': 'Main menu'
      },
      'primary_local_tasks': {
        'title': 'Primary Local Tasks'
      }
    };
    // Add the menu_name to each menu as a property.
    $.each(system_menus, function(menu_name, menu) {
        menu.menu_name = menu_name;
    });
    return system_menus;
  }
  catch (error) { console.log('menu_list_system_menus - ' + error); }
}

/**
 * Collects and alters the menu definitions.
 */
function menu_router_build() {
  //  Calls all hook_menu implementations and builds a collection of menu links.
  try {
    // For each module that implements hook_menu, iterate over each of the
    // menu links defined by the hook, then add each menu item to
    // drupalgap.menu_links keyed by the path.
    var modules = module_implements('menu');
    var function_name;
    var fn;
    var menu_links;
    $.each(modules, function(index, module) {
        // Determine the hook function name, grab the function, and call it
        // to retrieve the hook's menu links.
        function_name = module + '_menu';
        fn = window[function_name];
        menu_links = fn();
        // Iterate over each item.
        $.each(menu_links, function(path, menu_item) {
            // Attach module name to item.
            menu_item.module = module;
            // Set a default type for the item if one isn't provided.
            if (typeof menu_item.type === 'undefined') {
              menu_item.type = 'MENU_NORMAL_ITEM';
            }
            // Make the path available as a property in the menu link.
            menu_item.path = path;
            // Determine any parent, sibling, and child paths for the item.
            drupalgap_menu_router_build_menu_item_relationships(
              path,
              menu_item
            );
            // Attach item to menu links.
            drupalgap.menu_links[path] = menu_item;
        });
    });
  }
  catch (error) { console.log('menu_router_build - ' + error); }
}

/**
 * Given a menu link path, this determines and returns the router path as a
 * string.
 * @param {String} path
 * @return {String}
 */
function drupalgap_get_menu_link_router_path(path) {
  try {

    // @TODO - Why is this function called twice sometimes? E.G. via an MVC item
    // view item/local_users/user/0, this function gets called twice in one page
    // load, that can't be good.

    // @TODO - this function has a limitation in the types of menu paths it can
    // handle, for example a menu path of 'collection/%/%/list' with a path of
    // 'collection/local_users/user/list' can't find eachother. So we had to
    // change the mvc_menu() item path to be collection/list/%/%.

    // @TODO - each time this function is called, we should create a static
    // record of the result router path, keyed by the incoming path, that way
    // this heavy function can be called more often with less resource.

    // Is this path defined in drupalgap.menu_links? If it is, use it's router
    // path if it is defined, otherwise just set its router path to its own
    // path.
    if (drupalgap.menu_links[path]) {
      if (typeof drupalgap.menu_links[path].router_path === 'undefined') {
        return path;
      }
      else {
        return drupalgap.menu_links[path].router_path;
      }
    }

    // Let's figure out where to route this menu item, and attach the
    // router to the item.
    var router_path = null;
    var args = arg(null, path);

    // If there is an integer in the path, replace it with the wildcard
    // defined via hook_menu implementation.
    if (args) {
      var args_size = args.length;
      switch (args[0]) {
        case 'comment':
        case 'user':
        case 'node':
          if (args_size > 1 && is_int(parseInt(args[1]))) {
            args[1] = '%';
            router_path = args.join('/');
          }
          break;
        case 'taxonomy':
          if (args_size > 2 && (args[1] == 'vocabulary' || args[1] == 'term') &&
              is_int(parseInt(args[2]))
          ) {
            args[2] = '%';
            router_path = args.join('/');
          }
          break;
        default:
          if (drupalgap.settings.debug) {
            console.log(
              'drupalgap_get_menu_link_router_path - ' +
              'default case, will try round two (' + path + ')'
            );
          }
          break;
      }
    }

    // If we haven't found a router path yet, try some other techniques to find
    // it. If all else fails, just set the router path to the path itself.
    if (!router_path) {
      // Are there any paths in drupalgap.menu_links that would be good
      // candidates as the router for this path? Let's start at the back of the
      // argument list and start replacing each with a wildcard (%) and then
      // see if there is a path in drupalgap.menu_links that can handle it.
      if (args && args.length > 1) {
        var temp_router_path;
        for (var i = args.length - 1; i != -1; i--) {
          temp_router_path = '';
          for (var j = 0; j < args.length; j++) {
            if (j < i) {
              temp_router_path += args[j];
            }
            else {
              temp_router_path += '%';
            }
            if (j != args.length - 1) {
              temp_router_path += '/';
            }
          }
          // If we found a router path, let's use it.
          if (drupalgap.menu_links[temp_router_path]) {
            router_path = temp_router_path;
            break;
          }
        }
      }
    }

    // If the router path is a default menu local task, inherit its parent
    // router path.
    if (drupalgap.menu_links[router_path] &&
        drupalgap.menu_links[router_path].type == 'MENU_DEFAULT_LOCAL_TASK' &&
        drupalgap.menu_links[router_path].parent) {
      router_path = drupalgap.menu_links[router_path].parent;
    }

    // If there isn't a router and we couldn't find one, we'll just route
    // to the path itself.
    if (!router_path) { router_path = path; }

    // Finally, return the router path.
    return router_path;
  }
  catch (error) {
    console.log('drupalgap_get_menu_link_router_path - ' + error);
  }
}


/**
 * Loads all of the menus specified in drupalgap.settings.menus into
 * drupalgap.menus. This is called after menu_router_build(), so any system
 * defined menus will already be present and should be overwritten with any
 * customizations present in the settings. It then iterates over the menu links
 * specified in drupalgap.menu_links and attaches any of them that have a
 * menu_name to their corresponding menu in drupalgap.menus. Any menu link items
 * that have a 'region' property specified will be added to
 * drupalgap.theme.regions[region].
 */
function drupalgap_menus_load() {
  try {
    if (drupalgap.settings.menus) {
      // Process each menu defined in the settings.
      $.each(drupalgap.settings.menus, function(menu_name, menu) {
          // If the menu does not already exist, it is a custom menu, so create
          // the menu and its corresponding block.
          if (!eval('drupalgap.menus.' + menu_name)) {
            // If the custom menu doesn't have its machine name set, set it.
            if (!menu.menu_name) { menu.menu_name = menu_name; }
            // Save the custom menu, as long is its name isn't 'regions',
            // because that is a special "system" menu that allows menu links to
            // be placed directly in regions via settings.js. Keep in mind the
            // 'regions' menu is in fact NOT a system menu.
            if (menu_name != 'regions') {
              menu_save(menu);
              // Make a block for this custom menu.
              var block_delta = menu.menu_name;
              drupalgap.blocks[0][block_delta] = {
                name: block_delta,
                delta: block_delta,
                module: 'menu'
              };
            }
          }
          else {
            // The menu is a system defined menu, merge it together with any
            // custom settings.
            $.extend(true, eval('drupalgap.menus.' + menu_name), menu);
          }
      });
      // Now that we have all of the menus loaded up, and the menu router is
      // built, let's iterate over all the menu links and perform various
      // operations on them.
      $.each(drupalgap.menu_links, function(path, menu_link) {
          // Let's grab any links from the router that have a menu specified,
          // and add the link to the router.
          if (menu_link.menu_name) {
            if (eval('drupalgap.menus.' + menu_link.menu_name)) {
              // Create a links array for the menu if one doesn't exist already.
              if (!eval('drupalgap.menus.' + menu_link.menu_name + '.links')) {
                eval('drupalgap.menus.' + menu_link.menu_name + '.links = [];');
              }
              // Add the path to the menu link inside the menu.
              menu_link.path = path;
              // Now push the link onto the menu. We only care about the title,
              // path and options, as this is just a link. The rest of the
              // menu link data can be retrieved from drupalgap.menu_links.
              var link =
                drupalgap_menus_load_convert_menu_link_to_link_json(menu_link);
              eval(
                'drupalgap.menus.' + menu_link.menu_name + '.links.push(link);'
              );
            }
            else {
              console.log(
                'drupalgap_menus_load - menu does not exist (' +
                menu_link.menu_name + '), cannot attach link to it (' +
                path + ')'
              );
            }
          }
          // If the menu link is set to a specific region, create a links array
          // for the region if one doesn't exist already, then add the menu item
          // to the links array as a link.
          if (menu_link.region) {
            if (!drupalgap.theme.regions[menu_link.region.name].links) {
              drupalgap.theme.regions[menu_link.region.name].links = [];
            }
            drupalgap.theme.regions[menu_link.region.name].links.push(
              menu_link
            );
          }
      });
      // If there are any region menu links defined in settings.js, create a
      // links array for the region if one doesn't exist already, then add the
      // menu item to the links array as a link.
      if (typeof drupalgap.settings.menus.regions !== 'undefined') {
        $.each(drupalgap.settings.menus.regions, function(region, menu) {
            if (
              typeof menu.links !== 'undefined' &&
              $.isArray(menu.links) &&
              menu.links.length > 0
            ) {
              if (!drupalgap.theme.regions[region].links) {
                drupalgap.theme.regions[region].links = [];
              }
              $.each(menu.links, function(index, link) {
                  drupalgap.theme.regions[region].links.push(link);
              });
            }
        });
      }
    }
  }
  catch (error) { console.log('drupalgap_menus_load - ' + error); }
}

/**
 * Given a menu link item from drupalgap_menus_load(), this will return a JSON
 * object representing a link object compatable with theme_link(). It contains
 * the link title, path and options.
 * @param {Object} menu_link
 * @return {Object}
 */
function drupalgap_menus_load_convert_menu_link_to_link_json(menu_link) {
  try {
    var link = {};
    if (menu_link.title) {
      // TODO - this is strange, we have to fill the 'text' value so theme_link
      // will play nice. These two properties, and their usage, need a thorough
      // review, only one should probably be used.
      // UPDATE - the link.text property is probably no longer used, it should
      // be safe to get rid of. In fact, this whole function is dumb and should
      // go away.
      link.title = menu_link.title;
      link.text = menu_link.title;
    }
    if (menu_link.path) { link.path = menu_link.path; }
    if (menu_link.options) { link.options = menu_link.options; }
    // If it is a menu link on a region, and it has options, set the link
    // options to the ones provided in the menu link region settings.
    if (menu_link.region && menu_link.region.options) {
      link.options = menu_link.options = menu_link.region.options;
    }
    return link;
  }
  catch (error) {
    console.log(
      'drupalgap_menus_load_convert_menu_link_to_link_json - ' + error
    );
  }
}


/**
 * Given a path, and its corresponding menu item, this will determine any
 * parent, sibling, and/or child menu item paths and set the references on each
 * so they are all aware of eachother's paths.
 * @param {String} path
 * @param {Object} menu_item
 */
function drupalgap_menu_router_build_menu_item_relationships(path, menu_item) {
  try {
    // Split up the path arguments.
    var args = arg(null, path);
    // Any parent?
    if (args.length > 1) {
      // Set the parent path.
      var parent = args.splice(0, args.length - 1).join('/');
      menu_item.parent = parent;
      // Make sure the parent exists.
      if (drupalgap.menu_links[parent]) {
        // Now tell the parent about this child. If the parent doesn't yet have
        // any children, setup the children array on the parent.
        if (typeof drupalgap.menu_links[parent].children === 'undefined') {
          drupalgap.menu_links[parent].children = [];
        }
        drupalgap.menu_links[parent].children.push(path);
        // Now tell any siblings about this item, and tell this item about any
        // siblings.
        if (typeof menu_item.siblings === 'undefined') {
          menu_item.siblings = [];
        }
        $.each(drupalgap.menu_links[parent].children, function(index, sibling) {
            if (sibling != path && drupalgap.menu_links[sibling]) {
              if (
                typeof drupalgap.menu_links[sibling].siblings === 'undefined'
              ) {
                drupalgap.menu_links[sibling].siblings = [];
              }
              drupalgap.menu_links[sibling].siblings.push(path);
              menu_item.siblings.push(sibling);
            }
        });
      }
    }
  }
  catch (error) {
    console.log('drupalgap_menu_router_build_relationships - ' + error);
  }
}
/**
 * Each time we use drupalgap_goto to change a page, this function is called on
 * the pagebeforehange event. If we're not moving backwards, or navigating to
 * the same page, this will preproccesses the page, then processes it.
 */
$(document).on('pagebeforechange', function(e, data) {
    try {
      // If we're moving backwards, reset drupalgap.back and return.
      if (drupalgap && drupalgap.back) {
        drupalgap.back = false;
        return;
      }
      // If the jqm active page url is the same as the page id of the current
      // path, return.
      if (
        drupalgap_jqm_active_page_url() ==
        drupalgap_get_page_id(drupalgap_path_get())
      ) { return; }
      // We only want to process the page we are going to, not the page we are
      // coming from. When data.toPage is a string that is our destination page.
      if (typeof data.toPage === 'string') {

        // If drupalgap_goto() determined that it is necessary to prevent the
        // default page from reloading, then we'll skip the page
        // processing and reset the prevention boolean.
        if (drupalgap && !drupalgap.page.process) {
          drupalgap.page.process = true;
        }
        else if (drupalgap) {
          // Pre process, then process the page.
          template_preprocess_page(drupalgap.page.variables);
          template_process_page(drupalgap.page.variables);
        }
      }
    }
    catch (error) { console.log('pagebeforechange - ' + error); }
});

/**
 * Returns the path to the current DrupalGap theme, false otherwise.
 * @return {String|Boolean}
 */
function path_to_theme() {
  try {
    if (drupalgap.theme_path) {
      return drupalgap.theme_path;
    }
    else {
      console.log('path_to_theme - drupalgap.theme_path is not set!');
      return false;
    }
  }
  catch (error) { console.log('path_to_theme - ' + error); }
}

/**
 * Implementation of theme().
 * @param {String} hook
 * @param {Object} variables
 * @return {String}
 */
function theme(hook, variables) {
  try {

    // If there is HTML markup present, just return it as is. Otherwise, run
    // the theme hook and send along the variables.
    if (!variables) { variables = {}; }
    if (variables.markup) { return variables.markup; }
    var content = '';

    // First see if the current theme implements the hook, if it does use it, if
    // it doesn't fallback to the core theme implementation of the hook.
    var theme_function = drupalgap.settings.theme + '_' + hook;
    if (!function_exists(theme_function)) {
      theme_function = 'theme_' + hook;
      if (!function_exists(theme_function)) {
        var caller = null;
        if (arguments.callee.caller) {
          caller = arguments.callee.caller.name;
        }
        var msg = 'WARNING: ' + theme_function + '() does not exist.';
        if (caller) { msg += ' Called by: ' + caller + '().' }
        console.log(msg);
        return content;
      }
    }

    // If no attributes are coming in, look to variables.options.attributes
    // as a secondary option, otherwise setup an empty JSON object for them.
    if (
      typeof variables.attributes === 'undefined' ||
      !variables.attributes
    ) {
      if (variables.options && variables.options.attributes) {
        variables.attributes = variables.options.attributes;
      }
      else {
        variables.attributes = {};
      }
    }
    // If there is no class name, set an empty one.
    if (!variables.attributes.class) {
      variables.attributes.class = '';
    }
    var fn = window[theme_function];
    content = fn.call(null, variables);
    return content;
  }
  catch (error) { console.log('theme - ' + error); }
}

/**
 * Autocomplete global variables. Used to hold onto various global variables
 * needed for an autocomplete.
 */
// The autocomplete text field input selector.
var _theme_autocomplete_input_selector;

// The autocomplete remote boolean.
var _theme_autocomplete_remote;

// The theme autocomplete variables.
var _theme_autocomplete_variables;

/**
 * Themes an autocomplete.
 * @param {Object} variables
 * @return {String}
 */
function theme_autocomplete(variables) {
  try {
    var html = '';

    // Hold onto a copy of the variables.
    _theme_autocomplete_variables = variables;

    // Are we dealing with a remote data set.
    var remote = false;
    if (variables.remote) { remote = true; }
    variables.remote = remote;
    _theme_autocomplete_remote = variables.remote;

    // Make sure we have an id to use on the list.
    var id = null;
    if (variables.attributes.id) { id = variables.attributes.id; }
    else {
      id = 'autocomplete_' + user_password();
      variables.attributes.id = id;
    }

    // We need a hidden input to hold the value.
    html += theme('hidden', { attributes: { id: id } });

    // Now we need an id for the list.
    var list_id = id + '-list';

    // Build the widget variables.
    var widget = {
      attributes: {
        'id': list_id,
        'data-role': 'listview',
        'data-filter': 'true',
        'data-inset': 'true',
        'data-filter-placeholder': '...'
      }
    };

    // Handle a remote data set.
    var js = '';
    if (variables.remote) {
      widget.items = [];
      // We have a remote data set.
      js += '<script type="text/javascript">' +
        '$("#' + list_id + '").on("filterablebeforefilter", function(e, d) { ' +
          '_theme_autocomplete(this, e, d); ' +
        '});' +
      '</script>';
    }
    else {
      // Prepare the items then set the data filter reveal attribute.
      widget.items = _theme_autocomplete_prepare_items(variables);
      widget.attributes['data-filter-reveal'] = true;
    }

    // Save a reference to the autocomplete text field input.
    var selector = '#' + drupalgap_get_page_id() +
      ' input[data-type="search"]';
    js += '<script type="text/javascript">' +
      '_theme_autocomplete_input_selector = \'' + selector + '\';' +
    '</script>';

    // Theme the list and add the js to it, then return the html.
    html += theme('item_list', widget);
    html += js;
    return html;
  }
  catch (error) { console.log('theme_autocomplete - ' + error); }
}

/**
 * An internal function used to handle remote data for an autocomplete.
 * @param {Object} list The unordered list that displays the items.
 * @param {Object} e
 * @param {Object} data
 */
function _theme_autocomplete(list, e, data) {
  try {
    // Make sure a filter is present.
    if (typeof _theme_autocomplete_variables.filter === 'undefined') {
      console.log(
        '_theme_autocomplete - A "filter" was not supplied.'
      );
      return;
    }
    // Make sure a value and/or label has been supplied so we know how to render
    // the items in the autocomplete list.
    var value_provided =
      typeof _theme_autocomplete_variables.value !== 'undefined' ? true : false;
    var label_provided =
      typeof _theme_autocomplete_variables.label !== 'undefined' ? true : false;
    if (!value_provided && !label_provided) {
      console.log(
        '_theme_autocomplete - A "value" and/or "label" was not supplied.'
      );
      return;
    }
    else {
      // We have a value and/or label. If one isn't provided, set it equal to
      // the other.
      if (!value_provided) {
        _theme_autocomplete_variables.value =
          _theme_autocomplete_variables.label;
      }
      else if (!label_provided) {
        _theme_autocomplete_variables.label =
          _theme_autocomplete_variables.value;
      }
    }
    // Setup the vars to handle this widget.
    var $ul = $(list),
        $input = $(data.input),
        value = $input.val(),
        html = '';
    // Clear the list.
    $ul.html('');
    // If a value has been input, start the autocomplete search.
    if (value && value.length > 0) {
      // Show the loader icon.
      $ul.html('<li><div class="ui-loader">' +
        '<span class="ui-icon ui-icon-loading"></span>' +
        '</div></li>');
      $ul.listview('refresh');
      // Prepare the path to the view.
      var path = _theme_autocomplete_variables.path + '?' +
        _theme_autocomplete_variables.filter + '=' + encodeURIComponent(value);
      // Any extra params to send along?
      if (_theme_autocomplete_variables.params) {
        path += '&' + _theme_autocomplete_variables.params;
      }
      // Retrieve JSON results. Keep in mind, we use this for retrieving Views
      // JSON results and custom hook_menu() path results in Drupal.
      views_datasource_get_view_result(path, {
          success: function(results) {
            // If this was a custom path, don't use a wrapper around the
            // results like the one used by Views Datasource.
            var wrapped = true;
            if (_theme_autocomplete_variables.custom) { wrapped = false; }

            // Extract the result items based on the presence of the wrapper or
            // not.
            var result_items = null;
            if (wrapped) { result_items = results[results.view.root]; }
            else { result_items = results; }

            // If there are no results, just return.
            if (result_items.length == 0) { return; }

            // Convert the result into an items array for a list. Each item will
            // be a JSON object with a "value" and "label" properties.
            var items = [];
            var _value = _theme_autocomplete_variables.value;
            var _label = _theme_autocomplete_variables.label;
            $.each(result_items, function(index, object) {
                var _item = null;
                if (wrapped) { _item = object[results.view.child]; }
                else { _item = object; }
                var item = {
                  value: _item[_value],
                  label: _item[_label]
                };
                items.push(item);
            });

            // Now render the items, add them to list and refresh the list.
            if (items.length == 0) { return; }
            _theme_autocomplete_variables.items = items;
            var _items = _theme_autocomplete_prepare_items(
              _theme_autocomplete_variables
            );
            $.each(_items, function(index, item) {
              html += '<li>' + item + '</li>';
            });
            $ul.html(html);
            $ul.listview('refresh');
            $ul.trigger('updatelayout');
          }
      });
    }
  }
  catch (error) { console.log('_theme_autocomplete - ' + error); }
}

/**
 * An internal function used to prepare the items for an autocomplete list.
 * @param {Object} variables
 * @return {*}
 */
function _theme_autocomplete_prepare_items(variables) {
  try {
    // Make sure we have an items array.
    var items = [];
    if (variables.items) { items = variables.items; }

    // Prepare the items, and return them.
    var _items = [];
    if (items.length > 0) {
      $.each(items, function(index, item) {
          var value = '';
          var label = '';
          if (typeof item === 'string') {
            value = item;
            label = item;
          }
          else {
            value = item.value;
            label = item.label;
          }
          var options = {
            attributes: {
              value: value,
              onclick: '_theme_autocomplete_click(\'' +
                variables.attributes.id +
              '\', this)'
            }
          };
          var _item = l(label, null, options);
          _items.push(_item);
      });
    }
    return _items;
  }
  catch (error) { console.log('_theme_autocomplete_prepare_items - ' + error); }
}

/**
 * An internal function used to handle clicks on items in autocomplete results.
 * @param {String} id The id of the hidden input that holds the value.
 * @param {Object} item The list item anchor that was just clicked.
 */
function _theme_autocomplete_click(id, item) {
  try {
    // Set the hidden input with the value, and the text field with the text.
    var list_id = id + '-list';
    $('#' + id).val($(item).attr('value'));
    $(_theme_autocomplete_input_selector).val($(item).html());
    if (_theme_autocomplete_remote) {
      $('#' + list_id).html('');
    }
    else {
      $('#' + list_id + ' li').addClass('ui-screen-hidden');
      $('#' + list_id).listview('refresh');
    }
    // Now fire the item onclick handler, if one was provided.
    if (
      _theme_autocomplete_variables.item_onclick &&
      drupalgap_function_exists(_theme_autocomplete_variables.item_onclick)
    ) {
      var fn = window[_theme_autocomplete_variables.item_onclick];
      fn(id, $(item));
    }
  }
  catch (error) { console.log('_theme_autocomplete_click - ' + error); }
}

/**
 * Themes a button.
 * @param {Object} variables
 * @return {String}
 */
function theme_button(variables) {
  try {
    variables.attributes['data-role'] = 'button';
    var html = '<a ' + drupalgap_attributes(variables.attributes) + '>' +
      variables.text +
    '</a>';
    return html;
  }
  catch (error) { console.log('theme_button_link - ' + error); }
}

/**
 * Themes a button link.
 * @param {Object} variables
 * @return {String}
 */
function theme_button_link(variables) {
  try {
    variables.attributes['data-role'] = 'button';
    return theme_link(variables);
  }
  catch (error) { console.log('theme_button_link - ' + error); }
}


/**
 * Implementation of theme_image().
 * @param {Object} variables
 * @return {String}
 */
function theme_image(variables) {
  try {
    // Turn the path, alt and title into attributes if they are present.
    if (variables.path) { variables.attributes.src = variables.path; }
    if (variables.alt) { variables.attributes.alt = variables.alt; }
    if (variables.title) { variables.attributes.title = variables.title; }
    // Make sure the image width doesn't exceed the device's width.
    if (!variables.attributes.style) { variables.attributes.style = ''; }
    variables.attributes.style +=
      ' max-width: ' + drupalgap_max_width() + 'px; ';
    // Render the image.
    return '<img ' + drupalgap_attributes(variables.attributes) + ' />';
  }
  catch (error) { console.log('theme_image - ' + error); }
}

/**
 * Implementation of theme_image_style().
 * @param {Object} variables
 * @return {String}
 */
function theme_image_style(variables) {
  try {
    variables.path = image_style_url(variables.style_name, variables.path);
    return theme_image(variables);
  }
  catch (error) { console.log('theme_image - ' + error); }
}

/**
 * Theme's an item from an MVC collection.
 * @param {Object} variables
 * @return {String}
 */
function theme_item(variables) {
  try {
    var html = '';
    //var mvc_model_system_fields
    $.each(variables.item, function(field, value) {
        html +=
          '<h2>' + variables.model.fields[field].title + '</h2>' +
          '<p>' + value + '</p>';
    });
    return html;
  }
  catch (error) { console.log('theme_item - ' + error); }

}

/**
 * Implementation of theme_item_list().
 * @param {Object} variables
 * @return {String}
 */
function theme_item_list(variables) {
  try {
    // We'll theme an empty list unordered list by default, if there is a type
    // of list specified we'll use that, and if there are some items we'll
    // theme them too.
    var type = 'ul';
    if (variables.type) { type = variables.type; }
    var html = '';
    if (variables.title) { html += '<h2>' + variables.title + '</h2>'; }
    html += '<' + type + ' ' +
      drupalgap_attributes(variables.attributes) + '>';
    if (variables.items && variables.items.length > 0) {
      var listview = typeof variables.attributes['data-role'] !== 'undefined' &&
          variables.attributes['data-role'] == 'listview';
      $.each(variables.items, function(index, item) {
          var icon;
          html += '<li';
          if (listview && (icon = $(item).attr('data-icon'))) {
            // If we're in a listview and the item specifies an icon,
            // add the icon attribute to the list item element.
            html += ' data-icon="' + icon + '"';
          }
          html += '>' + item + '</li>';
      });
    }
    html += '</' + type + '>';
    return html;
  }
  catch (error) { console.log('theme_item_list - ' + error); }
}

/**
 * Identical to theme_item_list, except this turns the list into a jQM listview.
 * @param {Object} variables
 * @return {String}
 */
function theme_jqm_item_list(variables) {
  try {
    if (variables.attributes) {
      if (
        variables.attributes['data-role'] &&
        variables.attributes['data-role'] != 'listview'
      ) { }
      else {
        variables.attributes['data-role'] = 'listview';
      }
    }
    else {
      variables.attributes['data-role'] = 'listview';
    }
    return theme_item_list(variables);
  }
  catch (error) { console.log('theme_jqm_item_list - ' + error); }
}

/**
 * Implementation of theme_link().
 * @param {Object} variables
 * @return {String}
 */
function theme_link(variables) {
  try {
    var text = '';
    if (variables.text) { text = variables.text; }
    if (typeof variables.path !== 'undefined' && variables.path != null) {
      // By default our onclick will use a drupalgap_goto(). If we have any
      // incoming link options, then modify the link accordingly.
      var onclick = 'drupalgap_goto(\'' + variables.path + '\');';
      if (variables.options) {
        // Use an InAppBrowser?
        if (variables.options.InAppBrowser) {
          onclick =
            "window.open('" + variables.path + "', '_blank', 'location=yes');";
        }
        else {
          // All other options need to be extracted into a JSON string for the
          // onclick handler.
          var goto_options = '';
          $.each(variables.options, function(option, value) {
              if (option == 'attributes') { return; }
              if (typeof value === 'string') { value = "'" + value + "'"; }
              goto_options += option + ':' + value + ',';
          });
          onclick =
            'drupalgap_goto(\'' +
              variables.path + '\', ' +
              '{' + goto_options + '});';
        }
      }
      return '<a href="#" onclick="javascript:' + onclick + '"' +
        drupalgap_attributes(variables.attributes) + '>' + text + '</a>';
    }
    else {
      // The link has no path, so just render the text and attributes.
      if (typeof variables.attributes.href === 'undefined') {
        variables.attributes.href = '#';
      }
      return '<a ' + drupalgap_attributes(variables.attributes) + '>' +
        text +
      '</a>';
    }
  }
  catch (error) { console.log('theme_link - ' + error); }
}

/**
 * Implementation of theme_submit().
 * @param {Object} variables
 * @return {String}
 */
function theme_submit(variables) {
  try {
    return '<button ' + drupalgap_attributes(variables.attributes) + '>' +
      variables.element.value +
    '</button>';
  }
  catch (error) { console.log('theme_submit - ' + error); }
}

/**
 * Implementation of theme_table().
 * @param {Object} variables
 * @return {String}
 */
function theme_table(variables) {
  try {
    var html = '<table ' + drupalgap_attributes(variables.attributes) + '>';
    if (variables.header) {
      html += '<thead><tr>';
      $.each(variables.header, function(index, column) {
          if (column.data) {
            html += '<td>' + column.data + '</td>';
          }
      });
      html += '</tr></thead>';
    }
    html += '<tbody>';
    if (variables.rows) {
      $.each(variables.rows, function(row_index, row) {
          html += '<tr>';
          if (row) {
            $.each(row, function(column_index, column) {
                html += '<td>' + column + '</td>';
            });
          }
          html += '</tr>';
      });
    }
    return html + '</tbody></table>';
  }
  catch (error) { console.log('theme_table - ' + error); }
}

/**
 * Theme a jQueryMobile table.
 * @param {Object} variables
 * @return {String}
 */
function theme_jqm_table(variables) {
  try {
    variables.attributes['data-role'] = 'table';
    variables.attributes['data-mode'] = 'reflow';
    return theme_table(variables);
  }
  catch (error) { console.log('theme_jqm_table - ' + error); }
}

/**
 * Implementation of template_preprocess_page().
 * @param {Object} variables
 */
function template_preprocess_page(variables) {
  try {
    // Set up default attribute's for the page's div container.
    if (typeof variables.attributes === 'undefined') {
      variables.attributes = {};
    }

    // @todo - is this needed?
    variables.attributes['data-role'] = 'page';

    // Call all hook_preprocess_page functions.
    module_invoke_all('preprocess_page');

    // Place the variables into drupalgap.page
    drupalgap.page.variables = variables;
  }
  catch (error) { console.log('template_preprocess_page - ' + error); }
}

/**
 * Implementation of template_process_page().
 * @param {Object} variables
 */
function template_process_page(variables) {
  try {
    var drupalgap_path = drupalgap_path_get();
    // Execute the active menu handler to assemble the page output. We need to
    // do this before we render the regions below.
    drupalgap.output = menu_execute_active_handler();
    // For each region, render it, then replace the placeholder in the page's
    // html with the rendered region.
    var page_id = drupalgap_get_page_id(drupalgap_path);
    $.each(drupalgap.theme.regions, function(index, region) {
        var page_html = $('#' + page_id).html();
        eval(
          'page_html = page_html.replace(/{:' + region.name + ':}/g,' +
          'drupalgap_render_region(region));'
        );
        $('#' + page_id).html(page_html);
    });
  }
  catch (error) { console.log('template_process_page - ' + error); }
}

/**
 * Given a block delta, this will return the corresponding
 * block from drupalgap.blocks.
 * @param {String} delta
 * @return {Object}
 */
function drupalgap_block_load(delta) {
  try {
    var block = null;
    if (drupalgap.blocks) {
      $.each(drupalgap.blocks, function(index, object) {
          if (object[delta]) {
            block = object[delta];
            return false;
          }
      });
    }
    if (block == null) {
      var msg = 'drupalgap_block_load - failed to load "' + delta + '" block!';
      drupalgap_alert(msg);
    }
    return block;
  }
  catch (error) { console.log('drupalgap_block_load - ' + error); }
}

/**
 * Implements hook_menu().
 * @return {Object}
 */
function comment_menu() {
  try {
    var items = {
      'comment/%': {
        title: 'Comment',
        page_callback: 'comment_page_view',
        page_arguments: [1],
        pageshow: 'comment_page_view_pageshow',
        title_callback: 'comment_page_title',
        title_arguments: [1]
      },
      'comment/%/view': {
        title: 'View',
        type: 'MENU_DEFAULT_LOCAL_TASK',
        weight: -10
      },
      'comment/%/edit': {
        title: 'Edit',
        page_callback: 'entity_page_edit',
        pageshow: 'entity_page_edit_pageshow',
        page_arguments: ['comment_edit', 'comment', 1],
        weight: 0,
        type: 'MENU_LOCAL_TASK',
        access_callback: 'comment_access',
        access_arguments: [1],
        options: { reloadPage: true }
      }
    };
    return items;
  }
  catch (error) { console.log('comment_menu - ' + error); }
}

/**
 * Given a comment, this determines if the current user has access to it.
 * Returns true if so, false otherwise.
 * @param {Object} comment
 * @return {Boolean}
 */
function comment_access(comment) {
  try {
    if (comment.uid == Drupal.user.uid && user_access('edit own comments') ||
      user_access('administer comments')) {
      return true;
    }
    else { return false; }
  }
  catch (error) { console.log('comment_access - ' + error); }
}

/**
 * Page callback for comment/%.
 * @param {Number} cid
 * @return {Object}
 */
function comment_page_view(cid) {
  try {
    if (cid) {
      var content = {
        container: _drupalgap_entity_page_container('comment', cid, 'view')
      };
      return content;
    }
    else { drupalgap_error('No comment id provided!'); }
  }
  catch (error) { console.log('comment_page_view - ' + error); }
}

/**
 * jQM pageshow handler for comment/% pages.
 * @param {Number} cid
 */
function comment_page_view_pageshow(cid) {
  try {
    comment_load(cid, {
        success: function(comment) {
          var item = theme('comment', { comment: comment });
          var content = theme('jqm_item_list', {items: [item]});
          _drupalgap_entity_page_container_inject(
            'comment',
            cid,
            'view',
            content
          );
        }
    });
  }
  catch (error) { console.log('comment_page_view_pageshow - ' + error); }
}

/**
 * The title call back function for the comment view page.
 * @param {Function} callback
 * @param {Number} cid
 */
function comment_page_title(callback, cid) {
  try {
    // Try to load the comment subject, then send it back to the given callback.
    var title = '';
    var comment = comment_load(cid, {
        success: function(comment) {
          if (comment && comment.subject) { title = comment.subject; }
          callback.call(null, title);
        }
    });
  }
  catch (error) { console.log('comment_page_title - ' + error); }
}

/**
 * The comment edit form.
 * @param {Object} form
 * @param {Object} form_state
 * @param {Object} comment
 * @param {Object} node
 * @return {Object}
 */
function comment_edit(form, form_state, comment, node) {
  try {

    // If there is no comment object coming in, make an empty one with a node
    // id. Note, once the form.js submit handler is aware of its own entity and
    // can pass it along to this function (and others) when loading a form
    // during the submission process, this little chunk of code will no longer
    // be needed.
    if (!comment) { comment = {'nid': arg(1)}; }

    // Determine the comment bundle from the node type.
    var node_type = null;
    if (node && node.type) { node_type = node.type; }
    else { node_type = comment.node_type.replace('comment_node_', ''); }
    var bundle = 'comment_node_' + node_type;

    // Setup form defaults.
    form.entity_type = 'comment';
    form.bundle = bundle;
    form.action = 'node/' + comment.nid;

    // Add the entity's core fields to the form.
    drupalgap_entity_add_core_fields_to_form(
      'comment',
      bundle,
      form,
      comment
    );

    // Add the fields for this content type to the form.
    drupalgap_field_info_instances_add_to_form(
      'comment',
      bundle,
      form,
      comment
    );

    // Add submit to form.
    form.elements.submit = {
      'type': 'submit',
      'value': 'Save'
    };

    // Add cancel and delete button to form if we're editing a comment. Also
    // figure out a form title to use in the prefix.
    var form_title = 'Add comment';
    if (comment && comment.cid) {
      form_title = 'Edit comment';
      form.buttons['cancel'] = drupalgap_form_cancel_button();
      form.buttons['delete'] =
        drupalgap_entity_edit_form_delete_button('comment', comment.cid);
    }

    // Add a prefix.
    form.prefix += '<h2>' + form_title + '</h2>';

    return form;
  }
  catch (error) { console.log('comment_edit - ' + error); }
}

/**
 * The comment edit submit function.
 * @param {Object} form
 * @param {Object} form_state
 */
function comment_edit_submit(form, form_state) {
  try {
    var comment = drupalgap_entity_build_from_form_state(form, form_state);
    drupalgap_entity_form_submit(form, form_state, comment);
  }
  catch (error) { console.log('comment_edit_submit - ' + error); }
}

/**
 * Given a node id, this will return the id to use on the html list for the
 * comments.
 * @param {Number} nid
 * @return {String}
 */
function comment_list_id(nid) {
  try {
    return 'comment_listing_items_' + nid;
  }
  catch (error) { console.log('comment_list_id - ' + error); }
}

/**
 * Implements hook_services_postprocess().
 * @param {Object} options
 * @param {Object} result
 */
function comment_services_postprocess(options, result) {
  try {
    if (options.service == 'comment' && options.resource == 'create') {
      // If we're on the node view page, inject the comment into the comment
      // listing, then scroll the page to the newly inserted/rendered comment,
      // then clear the form input.
      var path = drupalgap_path_get();
      var router_path = drupalgap_get_menu_link_router_path(path);
      if (router_path == 'node/%') {
        node_load(arg(1), {
            reset: true,
            success: function(node) {
              comment_load(result.cid, {
                  success: function(comment) {
                    var list_id = comment_list_id(node.nid);
                    $('#' + list_id).append(
                      '<li>' + theme('comment', {
                          comment: comment
                      }) + '</li>'
                    ).listview('refresh');
                    scrollToElement('#' + list_id + ' li:last-child', 500);
                    var form_selector = '#' + drupalgap_get_page_id() +
                      ' #comment_edit';
                    drupalgap_form_clear(form_selector);
                  }
              });
            }
        });
      }
    }
  }
  catch (error) { console.log('comment_services_postprocess - ' + error); }
}

/**
 * Theme's a comment.
 * @param {Object} variables
 * @return {String}
 */
function theme_comment(variables) {
  try {
    var comment = variables.comment;
    var html = '';
    var comment_content = '';
    var picture = '';
    if (comment.picture_uri) {
      comment_content += theme(
        'image',
        { path: drupalgap_image_path(comment.picture_uri) }
      );
    }
    var created = new Date(comment.created * 1000);
    created = created.toLocaleDateString() + ' at ' +
      created.toLocaleTimeString();
    comment_content +=
      '<h2>' + comment.name + '</h2>' +
      '<h3>' + comment.subject + '<h3/>' +
      '<p>' + comment.content + '</p>' +
      '<p class="ui-li-aside">' + created + '</p>';
    // Comments will link to the user's profile, unless they are anonymous.
    var comment_link_path = 'user/' + comment.uid;
    if (comment.uid == 0) { comment_link_path = null; }
    html += l(comment_content, comment_link_path);
    if (user_access('administer comments')) {
      html += l('Edit', 'comment/' + comment.cid + '/edit', {
          attributes: {
            'data-icon': 'gear'
          }
      });
    }
    return html;
  }
  catch (error) { console.log('theme_comment - ' + error); }
}

/**
 * Implements hook_menu().
 * @return {Object}
 */
function contact_menu() {
  try {
    var items = {};
    items['contact'] = {
      title: 'Contact',
      page_callback: 'drupalgap_get_form',
      page_arguments: ['contact_site_form'],
      pageshow: 'contact_site_form_pageshow',
      access_arguments: ['access site-wide contact form']
    };
    items['user/%/contact'] = {
      title: 'User contact',
      page_callback: 'drupalgap_get_form',
      page_arguments: ['contact_personal_form', 1],
      pageshow: 'contact_personal_form_pageshow',
      access_arguments: ['access user contact forms'],
      weight: 10,
      type: 'MENU_LOCAL_TASK'
    };
    return items;
  }
  catch (error) { console.log('contact_menu - ' + error); }
}

/**
 * The contact index service resource.
 * @param {Object} options
 */
function contact_index(options) {
  try {
    options.method = 'GET';
    options.path = 'contact.json';
    options.service = 'contact';
    options.resource = 'index';
    Drupal.services.call(options);
  }
  catch (error) { console.log('contact_index - ' + error); }
}

/**
 * The contact site service resource.
 * @param {Object} options
 */
function contact_site(options) {
  try {
    options.method = 'POST';
    options.path = 'contact/site.json';
    options.service = 'contact';
    options.resource = 'site';
    Drupal.services.call(options);
  }
  catch (error) { console.log('contact_site - ' + error); }
}

/**
 * The contact personal service resource.
 * @param {Object} options
 */
function contact_personal(options) {
  try {
    options.method = 'POST';
    options.path = 'contact/personal.json';
    options.service = 'contact';
    options.resource = 'personal';
    Drupal.services.call(options);
  }
  catch (error) { console.log('contact_personal - ' + error); }
}

/**
 * The site contact form.
 * @param {Object} form
 * @param {Object} form_state
 * @return {Object}
 */
function contact_site_form(form, form_state) {
  try {
    form.elements.name = {
      title: 'Your name',
      type: 'textfield',
      required: true
    };
    form.elements.mail = {
      title: 'Your e-mail address',
      type: 'email',
      required: true
    };
    form.elements.subject = {
      title: 'Subject',
      type: 'textfield',
      required: true
    };
    form.elements.category = {
      title: 'Category',
      type: 'select',
      required: true
    };
    form.elements.message = {
      title: 'Message',
      type: 'textarea',
      required: true
    };
    form.elements.copy = {
      title: 'Send yourself a copy?',
      type: 'checkbox',
      default_value: 0,
      access: false
    };
    form.elements.submit = {
      type: 'submit',
      value: 'Send message'
    };
    // If the user is logged in, set the default values.
    if (Drupal.user.uid != 0) {
      form.elements.name.default_value = Drupal.user.name;
      form.elements.name.disabled = true;
      form.elements.mail.default_value = Drupal.user.mail;
      form.elements.mail.disabled = true;
      form.elements.copy.access = true;
    }
    return form;
  }
  catch (error) { console.log('contact_site_form - ' + error); }
}

/**
 * The pageshow callback for the contact site form.
 */
function contact_site_form_pageshow() {
  try {
    contact_index({
        success: function(results) {
          if (!results || !results.length) { return; }
          $.each(results, function(index, result) {
              var selected = result.selected == 1 ? 'selected' : '';
              var option =
                '<option value="' + result.cid + '" ' + selected + '>' +
                  result.category +
                '</option>';
              $('#edit-contact-site-form-category').append(option);
          });
          $('#edit-contact-site-form-category').selectmenu('refresh');
          if (results.length == 1) {
            $('#contact_site_form .field-name-category').hide();
          }
        }
    });
  }
  catch (error) { console.log('contact_site_form_pageshow - ' + error); }
}

/**
 * The site wide contact form submit handler.
 * @param {Ojbect} form
 * @param {Ojbect} form_state
 */
function contact_site_form_submit(form, form_state) {
  var data = {
    name: form_state.values['name'],
    mail: form_state.values['mail'],
    subject: form_state.values['subject'],
    category: form_state.values['category'],
    message: form_state.values['message'],
    copy: form_state.values['copy']
  };
  contact_site({
      data: JSON.stringify(data),
      success: function(result) {
        if (result[0]) {
          drupalgap_alert('Your message has been sent!');
        }
        else {
          drupalgap_alert(
            'There was a problem sending your message!',
            { title: 'Error' }
          );
        }
        drupalgap_form_clear();
      },
      error: function(xhr, status, message) {
        if (message) {
          message = JSON.parse(message);
          if (message.form_errors) {
            var errors = '';
            $.each(message.form_errors, function(element, error) {
                errors += error + '\n';
            });
            if (errors != '') { drupalgap_alert(errors); }
          }
        }
      }
  });
}

/**
 * The personal contact form.
 * @param {Object} form
 * @param {Object} form_state
 * @param {Number} recipient
 * @return {Object}
 */
function contact_personal_form(form, form_state, recipient) {
  try {
    // @TODO - when providing a personal contact form, make sure the user has
    // their personal contact form enabled.
    form.elements.name = {
      title: 'Your name',
      type: 'textfield',
      required: true
    };
    form.elements.mail = {
      title: 'Your e-mail address',
      type: 'email',
      required: true
    };
    form.elements.to = {
      type: 'hidden',
      required: true
    };
    var container_id = contact_personal_form_to_container_id(recipient);
    form.elements.to_display = {
      title: 'To',
      markup: '<div id="' + container_id + '"></div>'
    };
    form.elements.subject = {
      title: 'Subject',
      type: 'textfield',
      required: true
    };
    form.elements.message = {
      title: 'Message',
      type: 'textarea',
      required: true
    };
    form.elements.copy = {
      title: 'Send yourself a copy?',
      type: 'checkbox',
      default_value: 0,
      access: false
    };
    form.elements.submit = {
      type: 'submit',
      value: 'Send message'
    };
    // If the user is logged in, set the default values.
    if (Drupal.user.uid != 0) {
      form.elements.name.default_value = Drupal.user.name;
      form.elements.name.disabled = true;
      form.elements.mail.default_value = Drupal.user.mail;
      form.elements.mail.disabled = true;
      form.elements.copy.access = true;
    }
    return form;
  }
  catch (error) { console.log('contact_personal_form - ' + error); }
}

/**
 * The pageshow callback for the personal contact form.
 * @param {Object} form
 * @param {Number} recipient
 */
function contact_personal_form_pageshow(form, recipient) {
  try {
    user_load(recipient, {
        success: function(account) {
          // Make sure the user has their contact form enabled.
          if (!account.data.contact) {
            $('#' + drupalgap_get_page_id() + ' #drupalgap_form_errors').html(
              "<div class='messages warning'>" +
                "Sorry, this user's contact form is disabled." +
              '</div>'
            );
            return;
          }
          // Populate hidden value for the 'to' field.
          var container_id = contact_personal_form_to_container_id(recipient);
          $('#' + container_id).html(l(account.name, 'user/' + account.uid));
          var hidden_selector = '#' + drupalgap_get_page_id() +
            ' #edit-contact-personal-form-to';
          $(hidden_selector).val(account.name);
        }
    });
  }
  catch (error) { console.log('contact_personal_form_pageshow - ' + error); }
}

/**
 * The personal contact form submit handler.
 * @param {Ojbect} form
 * @param {Ojbect} form_state
 */
function contact_personal_form_submit(form, form_state) {
  var data = {
    name: form_state.values['name'],
    mail: form_state.values['mail'],
    to: form_state.values['to'],
    subject: form_state.values['subject'],
    category: form_state.values['category'],
    message: form_state.values['message'],
    copy: form_state.values['copy']
  };
  contact_personal({
      data: JSON.stringify(data),
      success: function(result) {
        if (result[0]) { drupalgap_alert('Your message has been sent!'); }
        else {
          drupalgap_alert(
            'There was a problem sending your message!',
            { title: 'Error' }
          );
        }
        drupalgap_form_clear();
      },
      error: function(xhr, status, message) {
        if (message) {
          message = JSON.parse(message);
          if (message.form_errors) {
            var errors = '';
            $.each(message.form_errors, function(element, error) {
                errors += error + '\n';
            });
            if (errors != '') { drupalgap_alert(errors); }
          }
        }
      }
  });
}

/**
 * Returns the div container id to use on the "to" markup on the personal
 * contact form.
 * @param {Number} recipient
 * @return {String}
 */
function contact_personal_form_to_container_id(recipient) {
  try {
    return 'contact_personal_form_user_' + recipient;
  }
  catch (error) {
    console.log('contact_personal_form_to_container_id - ' + error);
  }
}

/**
 * Given an entity type, bundle name, form and entity, this will add the
 * entity's core fields to the form via the DrupalGap forms api.
 * @param {String} entity_type
 * @param {String} bundle
 * @param {Object} form
 * @param {Object} entity
 */
function drupalgap_entity_add_core_fields_to_form(entity_type, bundle,
  form, entity) {
  try {
    // Grab the core fields for this entity type and bundle.
    var fields = drupalgap_entity_get_core_fields(entity_type, bundle);
    // Iterate over each core field in the entity and add it to the form. If
    // there is a value present in the entity, then set the field's form element
    // default value equal to the core field value.
    $.each(fields, function(name, field) {
      var default_value = field.default_value;
      if (entity && entity[name]) { default_value = entity[name]; }
      form.elements[name] = field;
      form.elements[name].default_value = default_value;
    });
  }
  catch (error) {
    console.log('drupalgap_entity_add_core_fields_to_form - ' + error);
  }
}

/**
 * Deprecated! Given an entity type, the bundle, the entity (assembled from form
 * state values) and any options, this assembles the ?data= string for the
 * entity service resource call URLs.
 * @param {String} entity_type
 * @param {String} bundle
 * @param {Object} entity
 * @param {Object} options
 */
function drupalgap_entity_assemble_data(entity_type, bundle, entity, options) {
  try {
    console.log('WARNING: drupalgap_entity_assemble_data() has been ' +
      'deprecated! Now just call e.g. node_save() for auto assembly.');
    return;
  }
  catch (error) { console.log('drupalgap_entity_assemble_data - ' + error); }
}

/**
 * Returns the 'Delete' button object that is used on entity edit forms.
 * @param {String} entity_type
 * @param {Number} entity_id
 * @return {Object}
 */
function drupalgap_entity_edit_form_delete_button(entity_type, entity_id) {
  try {
    return {
      'title': 'Delete',
      attributes: {
        onclick: "javascript:drupalgap_entity_edit_form_delete_confirmation('" +
          entity_type + "', " + entity_id +
        ');'
      }
    };
  }
  catch (error) {
    console.log('drupalgap_entity_edit_form_delete_button - ' + error);
  }
}

/**
 * Given an entity type and id, this will display a confirmation dialogue and
 * will subsequently delete the entity if the user confirms the dialogue box.
 * The Services module retains Drupal user permissions so users without proper
 * permissions will not be able to delete the entities from the server.
 * @param {String} entity_type
 * @param {Number} entity_id
 * @return {*}
 */
function drupalgap_entity_edit_form_delete_confirmation(entity_type,
  entity_id) {
  try {
    var confirm_msg =
      'Delete this content, are you sure? This action cannot be undone...';
    if (confirm(confirm_msg)) {
      // Change the jQM loader mode to saving.
      drupalgap.loader = 'deleting';
      // Set up the api call arguments and success callback.
      var call_arguments = {};
      call_arguments.success = function(result) {
        // Remove the entities page from the DOM, if it exists.
        var entity_page_path = entity_type + '/' + entity_id;
        var entity_page_id = drupalgap_get_page_id(entity_page_path);
        if (drupalgap_page_in_dom(entity_page_id)) {
          drupalgap_remove_page_from_dom(entity_page_id);
        }
        // Remove the entity from local storage.
        // @todo - this should be moved to jDrupal.
        window.localStorage.removeItem(
          entity_local_storage_key(entity_type, entity_id)
        );
        // Go to the front page.
        drupalgap_goto('', {'form_submission': true});
      };
      // Call the delete function.
      var name = services_get_resource_function_for_entity(
        entity_type,
        'delete'
      );
      var fn = window[name];
      fn(entity_id, call_arguments);
    }
  }
  catch (error) {
    console.log('drupalgap_entity_edit_form_delete_confirmation - ' + error);
  }
}

/**
 * Given an entity, this will render the content of the entity and place it in
 * the entity JSON object as the 'content' property.
 * @param {String} entity_type
 * @param {Object} entity
 */
function drupalgap_entity_render_content(entity_type, entity) {
  try {
    entity.content = '';
    // Render each field on the entity, using the default display. The fields
    // need to be appended accorind to their weight, so we'll keep track of
    // the weights and rendered field content as we iterate through the fields,
    // then at the end will append them in order onto the entity's content.
    var bundle = entity.type;
    if (entity_type == 'comment') { bundle = entity.bundle; }
    var field_info = drupalgap_field_info_instances(entity_type, bundle);
    if (!field_info) { return; }
    var field_content = {};
    var field_weights = {};
    $.each(field_info, function(field_name, field) {
        // Determine which display mode to use. The default mode will be used
        // if the drupalgap display mode is not present.
        if (!field.display) { return false; }
        var display = field.display['default'];
        if (field.display['drupalgap']) {
          display = field.display['drupalgap'];
          // If a module isn't listed on the drupalgap display, use the default
          // display's module.
          if (
            typeof display.module === 'undefined' &&
            typeof field.display['default'].module !== 'undefined'
          ) { display.module = field.display['default'].module; }
        }
        // Skip hidden fields.
        if (display.type == 'hidden') { return; }
        // Save the field name and weight.
        field_weights[field_name] = display.weight;
        // Save the field content.
        field_content[field_name] = drupalgap_entity_render_field(
          entity_type, entity, field_name, field, display
        );
    });
    // Extract the field weights and sort them.
    var extracted_weights = [];
    $.each(field_weights, function(field_name, weight) {
        extracted_weights.push(weight);
    });
    extracted_weights.sort(function(a, b) { return a - b; });
    // For each sorted weight, locate the field with the corresponding weight,
    // then add that field's content to the entity, if it hasn't already been
    // added.
    var completed_fields = [];
    $.each(extracted_weights, function(weight_index, target_weight) {
        $.each(field_weights, function(field_name, weight) {
            if (target_weight == weight) {
              if (completed_fields.indexOf(field_name) == -1) {
                completed_fields.push(field_name);
                entity.content += field_content[field_name];
                return false;
              }
            }
        });
    });
    // Give modules a chance to alter the content.
    module_invoke_all(
      'entity_post_render_content',
      entity,
      entity_type,
      bundle
    );
    // @TODO - I think we need to update this entity in local storage so this
    // content property sticks.
    // @UPDATE - I don't think this is working...
    /*_entity_local_storage_save(
      entity_type,
      entity[entity_primary_key(entity_type)],
      entity
    );*/
  }
  catch (error) {
    console.log('drupalgap_entity_render_content - ' + error);
  }
}

/**
 * Given an entity_type, the entity, a field name, and the field this will
 * render the field using the appropriate hook_field_formatter_view().
 * @param {String} entity_type
 * @param {Object} entity
 * @param {String} field_name
 * @param {Object} field
 * @param {*} display
 * @return {String}
 */
function drupalgap_entity_render_field(entity_type, entity, field_name,
  field, display) {
  try {
    var content = '';
    // Determine module that implements the hook_field_formatter_view,
    // then determine the hook's function name, then render the field content.
    // If there wasn't a module specified in the display, look to the module
    // specified in the field widget. If we still don't find it, then just
    // return.
    var module = display['module'];
    if (!module) {
      if (!field.widget.module) {
        var msg = 'drupalgap_entity_render_field - ' +
          'unable to locate the module for the field (' + field_name + ')';
        console.log(msg);
        return content;
      }
      else { module = field.widget.module; }
    }
    var function_name = module + '_field_formatter_view';
    if (drupalgap_function_exists(function_name)) {
      // Grab the field formatter function, then grab the field items
      // from the entity, then call the formatter function and append its result
      // to the entity's content.
      var fn = window[function_name];
      var items = null;
      // Determine the language code. Note, multi lingual sites may have a
      // language code on the entity, but still have 'und' on the field, so
      // fall back to 'und' if the field's language code doesn't match the
      // entity's language code.
      var language = entity.language;
      if (entity[field_name]) {
        if (entity[field_name][language]) {
          items = entity[field_name][language];
        }
        else if (entity[field_name]['und']) {
          items = entity[field_name]['und'];
          language = 'und';
        }
        else { items = entity[field_name]; }
      }
      // @TODO - We've been sending 'field' as the instance
      // (drupalgap_field_info_instance), and the 'instance' as the field
      // (drupalgap_field_info_field). This is backwards, and should be
      // reversed. All contrib modules with field support will need to be
      // udpated to reflect this. Lame.
      var elements = fn(
        entity_type,
        entity,
        field, /* This is actually the instance, doh! (I think) */
        drupalgap_field_info_field(field_name),
        language,
        items,
        display
      );
      $.each(elements, function(delta, element) {
          // If the element has markup, render it as is, if it is
          // themeable, then theme it.
          var element_content = '';
          if (element.markup) { element_content = element.markup; }
          else if (element.theme) {
            element_content = theme(element.theme, element);
          }
          //content += '<div>' + element_content + '</div>';
          content += element_content;
      });
    }
    else {
      console.log(
        'WARNING: drupalgap_entity_render_field - ' + function_name + '() ' +
        'does not exist! (' + field_name + ')'
      );
    }
    // Render the field label, if necessary.
    if (content != '' && display['label'] != 'hidden') {
      var label = '<h3>' + field.label + '</h3>';
      // Place the label above or below the field content.
      label = '<div>' + label + '</div>';
      switch (display['label']) {
        case 'below':
          content += label;
          break;
        case 'above':
        default:
          content = label + content;
          break;
      }
    }
    // Give modules a chance to alter the field content.
    var reference = {'content': content};
    module_invoke_all(
      'entity_post_render_field', entity, field_name, field, reference
    );
    if (reference.content != content) { return reference.content; }
    return content;
  }
  catch (error) { console.log('drupalgap_entity_render_field - ' + error); }
}

/**
 * Given a form and form_state, this will assemble an entity from the form_state
 * values and return the entity as a JSON object.
 * @param {Object} form
 * @param {Object} form_state
 * @return {Object}
 */
function drupalgap_entity_build_from_form_state(form, form_state) {
  try {
    var entity = {};
    var language = language_default();
    $.each(form_state.values, function(name, value) {

        // Determine wether or not this element is a field. If it is, determine
        // it's module and field assembly hook.
        var is_field = false;
        var module = false;
        var hook = false;
        if (form.elements[name].is_field) {
          is_field = true;
          module = form.elements[name].field_info_field.module;
          hook = module + '_assemble_form_state_into_field';
          if (!function_exists(hook)) { hook = false; }
        }

        // Retrieve the potential key for the element, if we don't get one
        // then it is a flat field that should be attached as a property to the
        // entity. Otherwise attach the key and value to the entity.
        var key = drupalgap_field_key(name); // e.g. value, fid, tid, nid, etc.
        if (key) {

          // Determine how many allowed values for this field.
          var allowed_values = form.elements[name].field_info_field.cardinality;

          // Convert unlimited value fields to one, for now...
          if (allowed_values == -1) { allowed_values = 1; }

          // Make sure there is at least one value before creating the form
          // element on the entity.
          if (typeof value[language][0] === 'undefined') { return; }

          // Create an empty object to house the field on the entity.
          entity[name] = {};

          // Some fields do not use a delta value in the service call, so we
          // prepare for that here.
          // @todo - Do all options_select widgets really have no delta value?
          // Or is it only single value fields that don't have it? We need to
          // test this.
          var use_delta = true;
          if (
            form.elements[name].type ==
              'taxonomy_term_reference' ||
            form.elements[name].field_info_instance.widget.type ==
              'options_select'
          ) {
            use_delta = false;
            entity[name][language] = {};
          }
          else { entity[name][language] = []; }

          // Now iterate over each delta on the form element, and add the value
          // to the entity.
          for (var delta = 0; delta < allowed_values; delta++) {
            if (typeof value[language][delta] !== 'undefined') {

              // @TODO - the way values are determined here is turning into
              // spaghetti code. Every form element needs its own
              // value_callback, just like Drupal's FAPI. Right now DG has
              // something similar going on with the use of
              // hook_assemble_form_state_into_field(). So replace any spaghetti
              // below with a value_callback. Provide a deprecated hook warning
              // for any fields not haven't caught up yet, and fallback to the
              // hook for a while.
              // @UPDATE - Actually, the DG FAPI
              // hook_assemble_form_state_into_field() is a good idea, and
              // should be used by all field form elements, then in
              // drupalgap_field_info_instances_add_to_form(), that function
              // should use the value_callback idea to properly map entity data
              // to the form element's value.

              // Extract the value.
              var field_value = value[language][delta];

              // By default, we'll assume we'll be attaching this element item's
              // value according to a key (usually 'value' is the default key
              // used by Drupal fields). However, we'll give modules that
              // implement hook_assemble_form_state_into_field() an opportunity
              // to specify no usage of a key if their item doesn't need one.
              // The geofield module is an example of field that doesn't use a
              // key. The use_wrapper flag allows others to completely override
              // the use of a wrapper around the field value, e.g. taxonomy term
              // reference autocomplete.
              var field_key = {
                value: 'value',
                use_key: true,
                use_wrapper: true,
                use_delta: use_delta
              };

              // If this element is a field, give the field's module an
              // opportunity to assemble its own value, otherwise we'll just
              // use the field value extracted above.
              if (is_field && hook) {
                var fn = window[hook];
                field_value = fn(form.entity_type,
                  form.bundle,
                  field_value,
                  form.elements[name].field_info_field,
                  form.elements[name].field_info_instance,
                  language,
                  delta,
                  field_key
                );
              }

              // If someone updated the key, use it.
              if (key != field_key.value) { key = field_key.value; }

              // If we don't need a delta value, place the field value using the
              // key, if posible. If we're using a delta value, push the key
              // and value onto the field to indicate the delta.
              if (!field_key.use_delta) {
                if (!field_key.use_wrapper) {
                  entity[name][language] = field_value;
                }
                else {
                  if ($.isArray(entity[name][language])) {
                    console.log(
                      'WARNING: drupalgap_entity_build_from_form_state - ' +
                      'cannot use key (' + key + ') on field (' + name + ') ' +
                      'language code array, key will be ignored.'
                    );
                    entity[name][language].push(field_value);
                  }
                  else { entity[name][language][key] = field_value; }
                }
              }
              else {
                if (field_key.use_key) {
                  var item = {};
                  item[key] = field_value;
                  entity[name][language].push(item);
                }
                else {
                  entity[name][language].push(field_value);
                }
              }

              // If the field value was null, we won't send along the field, so
              // just remove it. Except for list_boolean fields, they need a
              // null value to set the field value to false.
              // @TODO - will this cause issues with multi value fields? i.e. if
              // delta zero is null, but delta one isn't, this will probably
              // destroy the field, derp.
              if (
                field_value === null &&
                typeof entity[name] !== 'undefined' &&
                form.elements[name].type != 'list_boolean'
              ) { delete entity[name]; }

              // If we had an optional select list, and no options were
              // selected, delete the empty field from the assembled entity.
              // @TODO - will this cause multi value issues?
              if (
                is_field && !use_delta &&
                form.elements[name].field_info_instance.widget.type ==
                  'options_select' && !form.elements[name].required &&
                field_value === '' && typeof entity[name] !== 'undefined'
              ) { delete entity[name]; }

            }
          }
        }
        else if (typeof value !== 'undefined') { entity[name] = value; }
    });
    return entity;
  }
  catch (error) {
    console.log('drupalgap_entity_build_from_form_state - ' + error);
  }
}

/**
 * Given a form, form_state and entity, this will call the appropriate service
 * resource to create or update the entity.
 * @param {Object} form
 * @param {Object} form_state
 * @param {Object} entity
 * @return {*}
 */
function drupalgap_entity_form_submit(form, form_state, entity) {
  try {

    // Grab the primary key name for this entity type.
    var primary_key = entity_primary_key(form.entity_type);

    // Determine if we are editing an entity or creating a new one.
    var editing = false;
    if (entity[primary_key] && entity[primary_key] != '') {
      editing = true;
    }

    // Let's set up the api call arguments.
    var call_arguments = {};

    // Setup the success call back to go back to the entity page view.
    call_arguments.success = function(result) {
      try {
        // If no one has provided a form.action to submit this form to,
        // by default we'll try to redirect to [entity-type]/[entity-id] to view
        // the entity. For taxonomy, we replace the underscore with a forward
        // slash in the path.
        var destination = form.action;
        if (!destination) {
          var prefix = form.entity_type;
          if (prefix == 'taxonomy_vocabulary' || prefix == 'taxonomy_term') {
            prefix = prefix.replace('_', '/');
          }
          destination = prefix + '/' + result[primary_key];
        }
        drupalgap_goto(destination, {'form_submission': true});
      }
      catch (error) {
        console.log('drupalgap_entity_form_submit - success - ' + error);
      }
    };

    // Setup the error call back.
    call_arguments.error = function(xhr, status, message) {
      try {
        // If there were any form errors, display them in an alert.
        var msg = _drupalgap_form_submit_response_errors(form, form_state, xhr,
          status, message);
        if (msg) { drupalgap_alert(msg); }
      }
      catch (error) {
        console.log('drupalgap_entity_form_submit - error - ' + error);
      }
    };

    // Change the jQM loader mode to saving.
    drupalgap.loader = 'saving';

    // Depending on if we are creating a new entity, or editing an existing one,
    // call the appropriate service resource.
    var crud = 'create';
    if (editing) {
      crud = 'update';
      // Remove the entity from local storage.
      // @todo This should be moved to jDrupal.
      window.localStorage.removeItem(
        entity_local_storage_key(form.entity_type, entity[primary_key])
      );
    }
    var fn = window[
      services_get_resource_function_for_entity(form.entity_type, crud)
    ];
    fn(entity, call_arguments);
  }
  catch (error) { console.log('drupalgap_entity_form_submit - ' + error); }
}

/**
 * Given an entity type, this returns its core fields as forms api elements.
 * @param {String} entity_type
 * @param {String} bundle
 * @return {Object}
 */
function drupalgap_entity_get_core_fields(entity_type, bundle) {
  try {
    // @todo - was this function what we were tyring to accomplish with the
    // early entity_info hook imitations?
    // @todo - And why is this function not populated dynamically via Drupal?
    var fields = {};
    switch (entity_type) {
      case 'comment':
        var content_type = bundle.replace('comment_node_', '');
        // Add each schema field to the field collection.
        $.each(
          drupalgap.entity_info[entity_type].schema_fields_sql['base table'],
          function(index, name) {
            var field = {
              'type': 'hidden',
              'required': false,
              'default_value': '',
              'title': ucfirst(name)
            };
            fields[name] = field;
            //eval('fields.' + name + ' = field;');
          }
        );
        // Make the node id required.
        fields['nid'].required = true;
        // Only anonymous users can fill out the name field, authenticated users
        // have their name auto filled and disabled.
        fields['name'].type = 'textfield';
        if (Drupal.user.uid != 0) {
          fields['name'].default_value = Drupal.user.name;
          fields['name'].disabled = true;
        }
        // If the 'Allow comment title' is enabled on the content type, show
        // the comment subject field.
        if (drupalgap.content_types_list[content_type].comment_subject_field) {
          fields['subject'].type = 'textfield';
        }
        // Depending on this content type's comment settings, let's make
        // modifications to the form elements.
        // admin/structure/types/manage/article
        // 0 = Anonymous posters may not enter their contact information
        // 1 = Anonymous posters may leave their contact information
        // 2 = Anonymous posters must leave their contact information
        var comment_anonymous =
          drupalgap.content_types_list[content_type].comment_anonymous;
        switch (comment_anonymous) {
          case '0':
            delete(fields['mail']);
            delete(fields['homepage']);
            break;
          case '1':
            break;
          case '2':
            fields['mail'].required = true;
            fields['homepage'].required = true;
            break;
          default:
            console.log('WARNING: drupalgap_entity_get_core_fields - ' +
              'Unknown anonymous comment setting (' + content_type + '): ' +
              comment_anonymous);
            break;
        }
        // Only anonymous users get the mail and homepage fields.
        if (Drupal.user.uid == 0) {
          if (fields['mail']) { fields['mail'].type = 'textfield'; }
          if (fields['homepage']) { fields['homepage'].type = 'textfield'; }
        }
        break;
      case 'node':
        fields.nid = {
          'type': 'hidden',
          'required': false,
          'default_value': ''
        };
        fields.title = {
          'type': 'textfield',
          'title': 'Title',
          'required': true,
          'default_value': '',
          'description': ''
        };
        fields.type = {
          'type': 'hidden',
          'required': true,
          'default_value': ''
        };
        fields.language = {
          'type': 'hidden',
          'required': true,
          'default_value': language_default()
        };
        break;
      case 'user':
        fields.uid = {
          'type': 'hidden',
          'required': false,
          'default_value': ''
        };
        fields.name = {
          'type': 'textfield',
          'title': 'Username',
          'required': true,
          'default_value': '',
          'description': ''
        };
        fields.mail = {
          'type': 'email',
          'title': 'E-mail address',
          'required': true,
          'default_value': '',
          'description': ''
        };
        fields.picture = {
          'type': 'image',
          'widget_type': 'imagefield_widget',
          'title': 'Picture',
          'required': false,
          'value': 'Add Picture'
        };
        break;
      case 'taxonomy_term':
        fields = {
          'vid': {
            'type': 'hidden',
            'required': true,
            'default_value': ''
          },
          'tid': {
            'type': 'hidden',
            'required': false,
            'default_value': ''
          },
          'name': {
            'type': 'textfield',
            'title': 'Name',
            'required': true,
            'default_value': ''
          },
          'description': {
            'type': 'textarea',
            'title': 'Description',
            'required': false,
            'default_value': ''
          }
        };
        break;
      case 'taxonomy_vocabulary':
        fields = {
          'vid': {
            'type': 'hidden',
            'required': false,
            'default_value': ''
          },
          'name': {
            'type': 'textfield',
            'title': 'Name',
            'required': true,
            'default_value': ''
          },
          'machine_name': {
            'type': 'textfield',
            'title': 'Machine Name',
            'required': true,
            'default_value': ''
          },
          'description': {
            'type': 'textarea',
            'title': 'Description',
            'required': false,
            'default_value': ''
          }
        };
        break;
      default:
        console.log(
          'drupalgap_entity_get_core_fields - entity type not supported yet (' +
            entity_type +
          ')'
        );
        break;
    }
    return fields;
  }
  catch (error) { console.log('drupalgap_entity_get_core_fields - ' + error); }
}

/**
 * Given an entity_type, this returns the entity JSON info, if it exists, false
 * otherwise. You may optionally call this function with no arguments to
 * retrieve the JSON info for all entity types. See also
 * @see http://api.drupal.org/api/drupal/includes%21common.inc/function/entity_get_info/7
 * @return {Object|Boolean}
 */
function drupalgap_entity_get_info() {
  try {
    if (arguments[0]) {
      var entity_type = arguments[0];
      if (entity_type && drupalgap.entity_info[entity_type]) {
        return drupalgap.entity_info[entity_type];
      }
      else {
        return false;
      }
    }
    return drupalgap.entity_info;
  }
  catch (error) { console.log('drupalgap_entity_get_info - ' + error); }
}

/**
 * @deprecated Since 7.x-1.7-alpha you should use entity_primary_key() instead.
 * Given an entity type, this returns the primary key identifier for it.
 * @param {String} entity_type
 * @return {String}
 */
function drupalgap_entity_get_primary_key(entity_type) {
  try {
    console.log(
      'WARNING: drupalgap_entity_get_primary_key() is deprecated! ' +
      'Use entity_primary_key() instead.'
    );
    return entity_primary_key(entity_type);
  }
  catch (error) { console.log('drupalgap_entity_get_primary_key - ' + error); }
}

/**
 * Given an entity type, an entity id and a mode, this will return a render
 * object for the entity's page container.
 * @param {String} entity_type
 * @param {Number} entity_id
 * @param {String} mode
 * @return {Object}
 */
function _drupalgap_entity_page_container(entity_type, entity_id, mode) {
  try {
    var id = _drupalgap_entity_page_container_id(entity_type, entity_id, mode);
    return {
      markup: '<div id="' + id + '"></div>'
    };
  }
  catch (error) { console.log('_drupalgap_entity_page_container - ' + error); }
}

/**
 * Given an entity type, an entity id, and a mode, this will return the unique
 * id to be used for the entity's page container.
 * @param {String} entity_type
 * @param {Number} entity_id
 * @param {String} mode
 * @return {String}
 */
function _drupalgap_entity_page_container_id(entity_type, entity_id, mode) {
  try {
    return entity_type + '_' + entity_id + '_' + mode + '_container';
  }
  catch (error) {
    console.log('_drupalgap_entity_page_container_id - ' + error);
  }
}

/**
 * Given an entity type, id, mode and page build, this will render the page
 * build and inject it into the container on the page.
 * @param {String} entity_type
 * @param {Number} entity_id
 * @param {String} mode
 * @param {Object} build
 */
function _drupalgap_entity_page_container_inject(entity_type, entity_id, mode,
  build) {
  try {
    // Get the container id, set the drupalgap.output to the page build, then
    // inject the rendered page into the container.
    var id = _drupalgap_entity_page_container_id(entity_type, entity_id, mode);
    drupalgap.output = build;
    $('#' + id).html(drupalgap_render_page()).trigger('create');
  }
  catch (error) {
    console.log('_drupalgap_entity_page_container_inject - ' + error);
  }
}

/**
 * The page callback for entity edit forms.
 * @param {String} form_id
 * @param {String} entity_type
 * @param {Number} entity_id
 * @return {Object}
 */
function entity_page_edit(form_id, entity_type, entity_id) {
  try {
    var content = {
      container: _drupalgap_entity_page_container(
        entity_type,
        entity_id,
        'edit'
      )
    };
    return content;
  }
  catch (error) { console.log('entity_page_edit - ' + error); }
}

/**
 * The pageshow callback for entity edit forms.
 * @param {String} form_id
 * @param {String} entity_type
 * @param {Number} entity_id
 */
function entity_page_edit_pageshow(form_id, entity_type, entity_id) {
  try {
    entity_load(entity_type, entity_id, {
        success: function(entity) {
          _drupalgap_entity_page_container_inject(
            entity_type,
            entity_id,
            'edit',
            drupalgap_get_form(form_id, entity)
          );
        }
    });
  }
  catch (error) { console.log('entity_page_edit_pageshow - ' + error); }
}

/**
 * Returns an entity type's primary title key.
 * @param {String} entity_type
 * @return {String}
 */
function entity_primary_key_title(entity_type) {
  try {
    var key;
    switch (entity_type) {
      case 'comment': key = 'subject'; break;
      case 'file': key = 'filename'; break;
      case 'node': key = 'title'; break;
      case 'taxonomy_term': key = 'name'; break;
      case 'taxonomy_vocabulary': key = 'name'; break;
      case 'user': key = 'name'; break;
      default:
        console.log(
          'entity_primary_key_title - unsupported entity type (' +
            entity_type +
          ')'
        );
        break;
    }
    return key;
  }
  catch (error) { console.log('entity_primary_key_title - ' + error); }
}

/**
 * Implements hook_services_request_pre_postprocess_alter().
 * @param {Object} options
 * @param {*} result
 */
function entity_services_request_pre_postprocess_alter(options, result) {
  try {
    // If we're retrieving an entity, render the entity's content, if it isn't
    // already set.
    if (
      options.resource == 'retrieve' &&
      in_array(options.service, entity_types()
    )) {
      // @TODO - does this condition ever evaluate to true?
      if (typeof result.content !== 'undefined') { return; }
      drupalgap_entity_render_content(options.service, result);
    }
    // If we're indexing comments, render its content, if it isn't already set.
    else if (options.service == 'comment' && options.resource == 'index') {
      $.each(result, function(index, object) {
          // @TODO - does this condition ever evaluate to true?
          if (typeof object.content !== 'undefined') { return; }
          drupalgap_entity_render_content(options.service, result[index]);
      });
    }
  }
  catch (error) {
    console.log('entity_services_request_pre_postprocess_alter - ' + error);
  }
}


/**
 * Given a field name, this will return its field info.
 * @param {String} field_name
 * @return {Object}
 */
function drupalgap_field_info_field(field_name) {
  try {
    return drupalgap.field_info_fields[field_name];
  }
  catch (error) { console.log('drupalgap_field_info_field - ' + error); }
}

/**
 * Returns info on all fields.
 * @return {Object}
 */
function drupalgap_field_info_fields() {
  try {
    return drupalgap.field_info_fields;
  }
  catch (error) { console.log('drupalgap_field_info_fields - ' + error); }
}

/**
 * Given an entity type, field name, and bundle name this will return a JSON
 * object with data for the specified field name.
 * @param {String} entity_type
 * @param {String} field_name
 * @param {String} bundle_name
 * @return {Object}
 */
function drupalgap_field_info_instance(entity_type, field_name, bundle_name) {
  try {
    var instances = drupalgap_field_info_instances(entity_type, bundle_name);
    if (!instances) {
      var msg = 'WARNING: drupalgap_field_info_instance - instance was null ' +
      'for entity (' + entity_type + ') bundle (' + bundle_name + ') using ' +
      'field (' + field_name + ')';
      console.log(msg);
      return null;
    }
    if (!instances[field_name]) {
      var msg = 'WARNING: drupalgap_field_info_instance - ' +
        '"' + field_name + '" does not exist for entity (' + entity_type + ')' +
        ' bundle (' + bundle_name + ')';
      console.log(msg);
      return null;
    }
    return instances[field_name];
  }
  catch (error) { console.log('drupalgap_field_info_instance - ' + error); }
}

/**
 * Given an entity type and/or a bundle name, this returns the field info
 * instances for the entity or the bundle.
 * @param {String} entity_type
 * @param {String} bundle_name
 * @return {Object}
 */
function drupalgap_field_info_instances(entity_type, bundle_name) {
  try {
    var field_info_instances;
    // If there is no bundle, pull the fields out of the wrapper.
    if (!bundle_name) {
      field_info_instances =
        drupalgap.field_info_instances[entity_type][entity_type];
    }
    else {
      if (typeof drupalgap.field_info_instances[entity_type] !== 'undefined') {
        field_info_instances =
          drupalgap.field_info_instances[entity_type][bundle_name];
      }
    }
    return field_info_instances;
  }
  catch (error) { console.log('drupalgap_field_info_instances - ' + error); }
}

/**
 * Given an entity type, bundle, form and entity, this will add the
 * entity's fields to the given form.
 * @param {String} entity_type
 * @param {String} bundle
 * @param {Object} form
 * @param {Object} entity
 */
function drupalgap_field_info_instances_add_to_form(entity_type, bundle,
  form, entity) {
  try {
    // Grab the field info instances for this entity type and bundle.
    var fields = drupalgap_field_info_instances(entity_type, bundle);
    // If there is no bundle, pull the fields out of the wrapper.
    //if (!bundle) { fields = fields[entity_type]; }
    // Use the default language, unless the entity has one specified.
    var language = language_default();
    if (entity && entity.language) { language = entity.language; }
    // Iterate over each field in the entity and add it to the form. If there is
    // a value present in the entity, then set the field's form element default
    // value equal to the field value.
    if (fields) {
      $.each(fields, function(name, field) {
        // The user registration form is a special case, in that we only want
        // to place fields that are set to display on the user registration
        // form. Skip any fields not set to display.
        if (form.id == 'user_register_form' &&
          !field.settings.user_register_form) {
          return;
        }
        var field_info = drupalgap_field_info_field(name);
        if (field_info) {
          form.elements[name] = {
            'type': field_info.type,
            'title': field.label,
            'required': field.required,
            'description': field.description
          };
          if (!form.elements[name][language]) {
            form.elements[name][language] = {};
          }
          var default_value = field.default_value;
          var delta = 0;
          var cardinality = parseInt(field_info.cardinality);
          if (cardinality == -1) {
            cardinality = 1; // we'll just add one element for now, until we
                             // figure out how to handle the 'add another
                             // item' feature.
          }
          if (entity && entity[name] && entity[name].length != 0) {
            for (var delta = 0; delta < cardinality; delta++) {
              // @TODO - is this where we need to use the idea of the
              // value_callback property present in Drupal's FAPI, that way
              // each element knows how to map the entity data to its element
              // value property.

              var hook = true;

              module = field_info.module;
              hook = module + '_assemble_form_value_into_field';

              if (!function_exists(hook)) { hook = false; }

              if (hook) {
                var fn = window[hook];
                field_value = fn(form.entity_type,
                  form.bundle,
                  entity[name],
                  field_info,
                  fields[name],
                  language,
                  delta
                );
                form.elements[name][language][delta] = field_value;
              } else {
                if (
                  entity[name][language][delta] &&
                  typeof entity[name][language][delta].value !== 'undefined'
                ) { default_value = entity[name][language][delta].value; }
                // If the default_value is null, set it to an empty string.
                if (default_value == null) { default_value = ''; }
                // @todo - It appears not all fields have a language code to use
                // here, for example taxonomy term reference fields don't!
                form.elements[name][language][delta] = {
                  'value': default_value
                };
              }
            }
          }
        }
      });
    }
  }
  catch (error) {
    console.log('drupalgap_field_info_instances_add_to_form - ' + error);
  }
}

/**
 * Given a field name, this will return the key that should be used when
 * setting its value on an entity. If the field name is not a field, it returns
 * false.
 * @param {String} field_name
 * @return {String}
 */
function drupalgap_field_key(field_name) {
  try {
    // Determine the key to use for the value. By default, most fields
    // use 'value' as the key.
    var key = false;
    var field_info = drupalgap_field_info_field(field_name);
    if (field_info) {
      key = 'value';
      // Images use fid as the key.
      if (field_info.module == 'image' && field_info.type == 'image') {
        key = 'fid';
      }
      else if (
        field_info.module == 'taxonomy' &&
        field_info.type == 'taxonomy_term_reference'
      ) { key = 'tid'; }
    }
    return key;
  }
  catch (error) { console.log('drupalgap_field_key - ' + error); }
}

/**
 * Implements hook_field_formatter_view().
 * @param {String} entity_type
 * @param {Object} entity
 * @param {Object} field
 * @param {Object} instance
 * @param {String} langcode
 * @param {Object} items
 * @param {*} display
 * @return {Object}
 */
function list_field_formatter_view(entity_type, entity, field, instance,
  langcode, items, display) {
  try {
    var element = {};
    if (!empty(items)) {
      $.each(items, function(delta, item) {
          var markup = '';
          // list_default or list_key
          if (display.type == 'list_default') {
            markup = instance.settings.allowed_values[item.value];
            // Single on/off checkboxes need an empty space as their markup so
            // just the label gets rendered.
            if (
              instance.type == 'list_boolean' &&
              field.widget.type == 'options_onoff'
            ) { markup = '&nbsp;'; }
          }
          else { markup = item.value; }
          element[delta] = { markup: markup };
      });
    }
    return element;
  }
  catch (error) { console.log('list_field_formatter_view - ' + error); }
}

/**
 * Implements hook_assemble_form_state_into_field().
 * @param {Object} entity_type
 * @param {String} bundle
 * @param {String} form_state_value
 * @param {Object} field
 * @param {Object} instance
 * @param {String} langcode
 * @param {Number} delta
 * @param {Object} field_key
 *
 * @return {*}
 */
function list_assemble_form_state_into_field(entity_type, bundle,
  form_state_value, field, instance, langcode, delta, field_key) {
  try {
    var result = form_state_value;
    switch (field.type) {
      case 'list_boolean':
        // For single on/off checkboxes, if the checkbox is unchecked, then we
        // send a null value on the language code. We know the checkbox is
        // unchecked if the form_state_value is equal to the first allowed value
        // on the field.
        if (instance.widget.type == 'options_onoff') {
          var index = 0;
          var on = true;
          $.each(field.settings.allowed_values, function(value, label) {
              if (form_state_value == value && index == 0) {
                on = false;
                return false;
              }
              index++;
          });
          if (!on) {
            field_key.use_delta = false;
            field_key.use_wrapper = false;
            result = null;
          }
        }
        else {
          console.log(
            'WARNING: list_assemble_form_state_into_field - unknown widget (' +
              field.type +
            ') on list_boolean'
          );
        }
        break;
      default:
        console.log(
          'WARNING: list_assemble_form_state_into_field - unknown type (' +
            field.type +
          ')'
        );
        break;
    }
    return result;
  }
  catch (error) {
    console.log('list_assemble_form_state_into_field - ' + error);
  }
}

/**
 * Implements hook_field_formatter_view().
 * @param {String} entity_type
 * @param {Object} entity
 * @param {Object} field
 * @param {Object} instance
 * @param {String} langcode
 * @param {Object} items
 * @param {*} display
 * @return {Object}
 */
function number_field_formatter_view(entity_type, entity, field, instance,
  langcode, items, display) {
  try {
    var element = {};
    // If items is a string, convert it into a single item JSON object.
    if (typeof items === 'string') {
      items = {0: {value: items}};
    }
    if (!empty(items)) {
      var prefix = '';
      if (!empty(field.settings.prefix)) { prefix = field.settings.prefix; }
      var suffix = '';
      if (!empty(field.settings.suffix)) { suffix = field.settings.suffix; }
      $.each(items, function(delta, item) {
          element[delta] = {
            markup: prefix + item.value + suffix
          };
      });
    }
    return element;
  }
  catch (error) { console.log('number_field_formatter_view - ' + error); }
}

/**
 * Implements hook_field_widget_form().
 * @param {Object} form
 * @param {Object} form_state
 * @param {Object} field
 * @param {Object} instance
 * @param {String} langcode
 * @param {Object} items
 * @param {Number} delta
 * @param {Object} element
 */
function number_field_widget_form(form, form_state, field, instance, langcode,
  items, delta, element) {
  try {
    switch (element.type) {
      case 'number_integer':
        // Change the form element into a number, and then set its min/max
        // attributes along with the step.
        items[delta].type = 'number';
        if (!empty(instance.settings.max)) {
          items[delta].options.attributes['min'] = instance.settings.min;
        }
        if (!empty(instance.settings.max)) {
          items[delta].options.attributes['max'] = instance.settings.max;
        }
        items[delta].options.attributes['step'] = 1;
        break;
      default:
        console.log(
          'number_field_widget_form - element type not supported (' +
            element.type +
          ')'
        );
        break;
    }
  }
  catch (error) { console.log('number_field_widget_form - ' + error); }
}

/**
 * Implements hook_field_widget_form().
 * @param {Object} form
 * @param {Object} form_state
 * @param {Object} field
 * @param {Object} instance
 * @param {String} langcode
 * @param {Object} items
 * @param {Number} delta
 * @param {Object} element
 * @return {*}
 */
function options_field_widget_form(form, form_state, field, instance, langcode,
  items, delta, element) {
  try {
    switch (element.type) {
      case 'checkbox':
        // If the checkbox has a default value of 1, check the box.
        if (items[delta].default_value == 1) { items[delta].checked = true; }
        break;
      case 'radios':
        break;
      case 'list_boolean':
        switch (instance.widget.type) {
          case 'options_onoff':
            // Switch an on/off boolean to a checkbox and place its on/off
            // values as attributes. Depending on the allowed values, we may
            // have to iterate over an array, or an object to get the on/off
            // values.
            items[delta].type = 'checkbox';
            var off = null;
            var on = null;
            if ($.isArray(field.settings.allowed_values)) {
              for (var key in field.settings.allowed_values) {
                if (off === null) { off = key; }
                else { on = key; }
              }
            }
            else {
              $.each(field.settings.allowed_values, function(value, label) {
                  if (off === null) { off = value; }
                  else { on = value; }
              });
            }
            items[delta].options.attributes.off = off;
            items[delta].options.attributes.on = on;
            // If the value equals the on value, then check the box.
            if (items[delta].value == on) {
              items[delta].options.attributes.checked = 'checked';
            }
            break;
          default:
            console.log(
              'WARNING: options_field_widget_form list_boolean with ' +
              'unsupported type (' + instance.widget.type + ')'
            );
            break;
        }
        break;
      case 'select':
      case 'list_text':
      case 'list_float':
      case 'list_integer':
        if (instance.widget.type == 'options_select') {
          items[delta].type = 'select';
        }
        // If the select list is required, add a 'Select' option and set it as
        // the default.  If it is optional, place a "none" option for the user
        // to choose from.
        if (items[delta].required) {
          items[delta].options[-1] = 'Select';
          items[delta].value = -1;
        }
        else {
          items[delta].options[''] = '- None -';
          items[delta].value = '';
        }
        // If there are any allowed values, place them on the options list. Then
        // check for a default value, and set it if necessary.
        if (field.settings.allowed_values) {
          $.each(field.settings.allowed_values, function(key, value) {
              // Don't place values that are objects onto the options (i.e.
              // commerce taxonomy term reference fields).
              if (typeof value === 'object') { return; }
              // Set the key and value for the option.
              items[delta].options[key] = value;
          });
          if (instance.default_value &&
            typeof instance.default_value[delta].value !== 'undefined') {
              items[delta].value = instance.default_value[delta].value;
          }
        }
        break;
      case 'taxonomy_term_reference':
          // Change the item type to a hidden input.
          items[delta].type = 'hidden';
          // What vocabulary are we using?
          var machine_name = field.settings.allowed_values[0].vocabulary;
          var taxonomy_vocabulary =
            taxonomy_vocabulary_machine_name_load(machine_name);

          var widget_type = false;
          if (instance.widget.type == 'options_select') {
            widget_type = 'select';
          }
          else {
            console.log(
              'WARNING: options_field_widget_form() - ' + instance.widget.type +
              ' not yet supported for ' + element.type + ' form elements!'
            );
            return false;
          }
          var widget_id = items[delta].id + '-' + widget_type;
          items[delta].children.push({
              type: widget_type,
              attributes: {
                id: widget_id,
                onchange: "_theme_taxonomy_term_reference_onchange(this, '" +
                  items[delta].id +
                "');"
              }
          });
          // Attach a pageshow handler to the current page that will load the
          // terms into the widget.
          var options = {
            'page_id': drupalgap_get_page_id(drupalgap_path_get()),
            'jqm_page_event': 'pageshow',
            'jqm_page_event_callback':
              '_theme_taxonomy_term_reference_load_items',
            'jqm_page_event_args': JSON.stringify({
                'taxonomy_vocabulary': taxonomy_vocabulary,
                'widget_id': widget_id
            })
          };
          // Pass the field name so the page event handler can be called for
          // each item.
          items[delta].children.push({
              markup: drupalgap_jqm_page_event_script_code(
                  options,
                  field.field_name
              )
          });
        break;
    }
  }
  catch (error) { console.log('options_field_widget_form - ' + error); }
}

/**
 * Implements hook_field_formatter_view().
 * @param {String} entity_type
 * @param {Object} entity
 * @param {Object} field
 * @param {Object} instance
 * @param {String} langcode
 * @param {Object} items
 * @param {*} display
 * @return {Object}
 */
function text_field_formatter_view(entity_type, entity, field, instance,
  langcode, items, display) {
  try {
    var element = {};
    if (!empty(items)) {
      $.each(items, function(delta, item) {
          // Grab the field value, but use the safe_value if we have it.
          var value = item.value;
          if (typeof item.safe_value !== 'undefined') {
            value = item.safe_value;
          }
          element[delta] = { markup: value };
      });
    }
    return element;
  }
  catch (error) { console.log('text_field_formatter_view - ' + error); }
}

/**
 * Implements hook_field_widget_form().
 * @param {Object} form
 * @param {Object} form_state
 * @param {Object} field
 * @param {Object} instance
 * @param {String} langcode
 * @param {Object} items
 * @param {Number} delta
 * @param {Object} element
 */
function text_field_widget_form(form, form_state, field, instance, langcode,
  items, delta, element) {
  try {
    // Determine the widget type, then set the delta item's type property.
    var type = null;
    switch (element.type) {
      case 'text':
        type = 'textfield';
        break;
      case 'textarea':
      case 'text_long':
      case 'text_with_summary':
      case 'text_textarea':
        type = 'textarea';
    }
    items[delta].type = type;
  }
  catch (error) { console.log('text_field_widget_form - ' + error); }
}




// Holds onto the phonegap getPicture success image data. It is keyed by field
// name, then delta value.
var image_phonegap_camera_options = {};

/**
 * Implements hook_field_formatter_view().
 /**
 * Implements hook_field_formatter_view().
 * @param {String} entity_type
 * @param {Object} entity
 * @param {Object} field
 * @param {Object} instance
 * @param {String} langcode
 * @param {Object} items
 * @param {*} display
 * @return {Object}
 */
function image_field_formatter_view(entity_type, entity, field, instance,
  langcode, items, display) {
  try {
    var element = {};
    if (!empty(items)) {
      $.each(items, function(delta, item) {
          // TODO - add support for image_style
          element[delta] = {
            theme: 'image',
            alt: item.alt,
            title: item.title,
            path: drupalgap_image_path(item.uri)
            /*image_style:display.settings.image_style*/
          };
      });
    }
    return element;
  }
  catch (error) { console.log('image_field_formatter_view - ' + error); }
}

/**
 * Implements hook_field_widget_form().
 * @param {Object} form
 * @param {Object} form_state
 * @param {Object} field
 * @param {Object} instance
 * @param {String} langcode
 * @param {Object} items
 * @param {Number} delta
 * @param {Object} element
 */
function image_field_widget_form(form, form_state, field, instance, langcode,
  items, delta, element) {
  try {
    // Change the item type to a hidden input to hold the file id.
    items[delta].type = 'hidden';

    // Set the default button text, and if a value was provided,
    // overwrite the button text.
    var button_text = 'Take Photo';
    if (items[delta].value) { button_text = item.value; }
    var browse_button_text = 'Browse';
    if (items[delta].value2) { browse_button_text = item.value2; }

    // Place variables into document for PhoneGap image processing.
    var item_id_base = items[delta].id.replace(/-/g, '_');
    var image_field_source = item_id_base + '_imagefield_source';
    var imagefield_destination_type =
      item_id_base + '_imagefield_destination_type';
    var imagefield_data = item_id_base + '_imagefield_data';
    eval('var ' + image_field_source + ' = null;');
    eval('var ' + imagefield_destination_type + ' = null;');
    eval('var ' + imagefield_data + ' = null;');
    // Build an imagefield widget with PhoneGap. Contains a message
    // div, an image item, a button to add an image, and a button to browse for
    // images.
    var browse_button_id = items[delta].id + '-browse-button';
    var html = '<div>' +
      '<div id="' + items[delta].id + '-imagefield-msg"></div>' +
      '<img id="' + items[delta].id + '-imagefield" style="display: none;" />' +
      '<a href="#" data-role="button" data-icon="camera" ' +
        'id="' + items[delta].id + '-button">' +
        button_text +
      '</a>' +
      '<a href="#" data-role="button" data-icon="grid" ' +
        'id="' + browse_button_id + '">' +
        browse_button_text +
      '</a>' +
    '</div>';
    // Open extra javascript declaration.
    html += '<script type="text/javascript">';
    // Add device ready listener for PhoneGap camera.
    var event_listener = item_id_base + '_imagefield_ready';
    html += '$("#' + drupalgap_get_page_id(
      drupalgap_path_get()) + '").on("pageshow",function(){' +
        'document.addEventListener(' +
        '"deviceready", ' +
        event_listener + ', ' +
        'false);' +
      '});' +
    'function ' + event_listener + '() {' +
      image_field_source + ' = navigator.camera.PictureSourceType;' +
      imagefield_destination_type + ' = navigator.camera.DestinationType;' +
    '}';
    // Define error callback function.
    var imagefield_error = item_id_base + '_error';
    html += 'function ' + imagefield_error + '(message) {' +
      'if (message != "Camera cancelled." && ' +
        'message != "Selection cancelled." && ' +
        'message != "no image selected")' +
      '{' +
        'console.log("' + imagefield_error + '");' +
        'drupalgap_alert(message);' +
      '}' +
    '}';
    // Define success callback function.
    var imagefield_success = item_id_base + '_success';
    html += 'function ' + imagefield_success + '(imageData) {' +
      '_image_phonegap_camera_getPicture_success(' +
      '{field_name:"' + field.field_name + '", ' +
        'image:imageData, id:"' + items[delta].id + '"' +
       '})' +
    '}';
    // Determine image quality.
    var quality = 50;
    if (drupalgap.settings.camera.quality) {
      quality = drupalgap.settings.camera.quality;
    }
    // Add click handler for photo button.
    html += '$("#' + items[delta].id + '-button").on("click",function(){' +
      'var photo_options = {' +
        'quality: ' + quality + ',' +
        'destinationType: ' + imagefield_destination_type + '.DATA_URL,' +
        'correctOrientation: true' +
      '};' +
      'navigator.camera.getPicture(' +
        imagefield_success + ', ' +
        imagefield_error + ', ' +
        'photo_options);' +
    '});';
    // Add click handler for browse button.
    html += '$("#' + browse_button_id + '").on("click",function(){' +
      'var browse_photo_options = {' +
        'quality: ' + quality + ',' +
        'sourceType: ' + image_field_source + '.PHOTOLIBRARY,' +
        'destinationType: ' + imagefield_destination_type + '.DATA_URL,' +
        'correctOrientation: true' +
      '};' +
      'navigator.camera.getPicture(' +
        imagefield_success + ', ' +
        imagefield_error + ', ' +
        'browse_photo_options);' +
    '});';
    // Close extra javascript declaration.
    html += '</script>';
    // Add html to the item's children.
    items[delta].children.push({markup: html});
  }
  catch (error) { console.log('image_field_widget_form - ' + error); }
}

/**
 * Given an entity type and optional bundle name, this will return an array
 * containing any image field names present, false otherwise.
 * @param {String} entity_type
 * @param {String} bundle
 * @return {Object}
 */
function image_fields_present_on_entity_type(entity_type, bundle) {
  try {
    var results = [];
    var fields = drupalgap_field_info_instances(entity_type, bundle);
    $.each(fields, function(name, field) {
        if (field.widget &&
          field.widget.type &&
          field.widget.type == 'image_image'
        ) {
          results.push(name);
        }
    });
    if (results.length == 0) { return false; }
    return results;
  }
  catch (error) {
    console.log('image_fields_present_on_entity_type - ' + error);
  }
}

/**
 * Implements hook_form_alter().
 * @param {Object} form
 * @param {Object} form_state
 * @param {String} form_id
 */
function image_form_alter(form, form_state, form_id) {
  try {
    // Make potential alterations to any entity edit form that has an image
    // field element(s).
    if (form.entity_type) {
      var bundle = form.bundle;
      var image_fields =
        image_fields_present_on_entity_type(form.entity_type, bundle);
      if (image_fields) {
        // Attach the image field names to the form for later reference.
        form.image_fields = image_fields;
        // For each image field, create a place for it in the global var.
        if ($.isArray(image_fields)) {
          $.each(image_fields, function(index, name) {
              image_phonegap_camera_options[name] = {0: null};
          });
        }
      }
    }
  }
  catch (error) { console.log('image_form_alter - ' + error); }
}

/**
 * Given an image style name and image uri, this will return the absolute URL
 * that can be used as a src value for an img element.
 * @param {String} style_name
 * @param {String} path
 * @return {String}
 */
function image_style_url(style_name, path) {
  try {
    var src =
      Drupal.settings.site_path + Drupal.settings.base_path + path;
    if (src.indexOf('public://') != -1) {
      src = src.replace(
        'public://',
        Drupal.settings.file_public_path +
          '/styles/' +
          style_name +
          '/public/'
      );
    }
    return src;
  }
  catch (error) { console.log('image_style_url - ' + error); }
}

/**
 * The success callback function used when handling PhoneGap's camera
 * getPicture() call.
 * @param {Object} options
 */
function _image_phonegap_camera_getPicture_success(options) {
  try {

    // Hold on to the image options in the global var.
    image_phonegap_camera_options[options.field_name] = {0: options};

    // Hide the 'Add image' button and show the 'Upload' button.
    //$('#' + options.id + '-button').hide();
    //$('#' + options.id + '_upload').show();

    // Show the captured photo as a thumbnail. When the photo is loaded, resize
    // it to fit the content area, then show it.
    var image_element_id = options.id + '-imagefield';
    var image = document.getElementById(image_element_id);
    image.src = 'data:image/jpeg;base64,' +
      image_phonegap_camera_options[options.field_name][0].image;
    image.onload = function() {
      var width = this.width;
      var height = this.height;
      var ratio = width / drupalgap_max_width();
      var new_width = width / ratio;
      var new_height = height / ratio;
      image.width = new_width;
      image.height = new_height;
      $('#' + image_element_id).show();
    };
  }
  catch (error) {
    console.log('_image_phonegap_camera_getPicture_success - ' + error);
  }
}

/**
 * An internal function used to upload images to the server, retreive their file
 * id and then populate the corresponding form element's value with the file id.
 * @param {Object} form
 * @param {Object} form_state
 * @param {Object} options
 */
function _image_field_form_process(form, form_state, options) {
  try {
    // @todo - this needs mutli value field support (delta)
    var lng = language_default();
    var processed_an_image = false;
    $.each(form.image_fields, function(index, name) {
        // Skip empty images.
        if (!image_phonegap_camera_options[name][0]) { return false; }
        // Skip image fields that already have their file id set.
        if (form_state.values[name][lng][0] != '') { return false; }
        // Create a unique file name using the UTC integer value.
        var d = new Date();
        var image_file_name = Drupal.user.uid + '_' + d.valueOf() + '.jpg';
        // Build the data for the file create resource.
        var file = {'file': {
          'file': image_phonegap_camera_options[name][0].image,
          'filename': image_file_name,
          'filepath': 'public://' + image_file_name
        }};
        // Change the loader mode to saving, and save the file.
        drupalgap.loader = 'saving';
        processed_an_image = true;
        file_save(file, {
            success: function(result) {
              try {
                // Set the hidden input and form state values with the file id.
                var element_id = drupalgap_form_get_element_id(name, form.id);
                $('#' + element_id).val(result.fid);
                form_state.values[name][lng][0] = result.fid;
                if (options.success) { options.success(); }
              }
              catch (error) {
                console.log('_image_field_form_process - success - ' + error);
              }
            }
        });
        // @todo - for now we only support the first image field on the form.
        return false;
    });
    // If no images were processed, we need to continue onward anyway.
    if (!processed_an_image && options.success) { options.success(); }
  }
  catch (error) { console.log('_image_field_form_validate - ' + error); }
}

/**
 * Implements hook_block_view().
 * @param {String} delta
 * @param {Object} region
 * @return {String}
 */
function menu_block_view(delta, region) {
  // NOTE: When rendering a jQM data-role="navbar" you can't place an
  // empty list (<ul></ul>) in it, this will cause an error:
  // https://github.com/jquery/jquery-mobile/issues/5141
  // So we must check to make sure we have any items before rendering the
  // menu since our theme_item_list implementation returns empty lists
  // for jQM pageshow async list item data retrieval and display.
  try {
    // Since menu link paths may have an 'access_callback' handler that needs
    // to make an async call to the server (e.g. local tasks), we'll utilize a
    // pageshow handler to render the menu, so for now just render an empty
    // placeholder and pageshow handler.
    var page_id = drupalgap_get_page_id();
    var container_id = menu_container_id(delta, page_id);
    var data_role = null;
    if (region.attributes && region.attributes['data-role']) {
      data_role = region.attributes['data-role'];
    }
    return '<div id="' + container_id + '"></div>' +
      drupalgap_jqm_page_event_script_code({
          page_id: page_id,
          jqm_page_event: 'pageshow',
          jqm_page_event_callback: 'menu_block_view_pageshow',
          jqm_page_event_args: JSON.stringify({
              menu_name: delta,
              container_id: container_id,
              'data-role': data_role
          })
      }, delta);
  }
  catch (error) { console.log('menu_block_view - ' + error); }
}

/**
 * The pageshow handler for menu blocks.
 * @param {Object} options
 */
function menu_block_view_pageshow(options) {
  try {
    var html = '';

    // Grab current path so we can watch out for any menu links that match it.
    var path = drupalgap_path_get();

    // Are we about to view a normal menu, or the local task menu?
    var delta = options.menu_name;
    if (delta == 'primary_local_tasks') {

      // LOCAL TASKS MENU LINKS

      // For the current page's router path, grab any local tasks menu links add
      // them into the menu. Note, local tasks are located in a menu link item's
      // children, if there are any. Local tasks typically have argument
      // wildcards in them, so we'll replace their wildcards with the current
      // args.
      var router_path = drupalgap_router_path_get();
      if (
        drupalgap.menu_links[router_path] &&
        drupalgap.menu_links[router_path].children
      ) {

        var args = arg();

        // Define a success callback that will be called later on...
        var _success = function(result) {
          var menu_items = [];
          var link_path = '';
          $.each(
            drupalgap.menu_links[router_path].children,
            function(index, child) {
              if (drupalgap.menu_links[child] && (
                drupalgap.menu_links[child].type == 'MENU_DEFAULT_LOCAL_TASK' ||
                drupalgap.menu_links[child].type == 'MENU_LOCAL_TASK'
              )) {
                if (drupalgap_menu_access(child, null, result)) {
                  menu_items.push(drupalgap.menu_links[child]);
                }
              }
            }
          );
          // If there was only one local task menu item, and it is the default
          // local task, don't render the menu, otherwise render the menu as an
          // item list as long as there are items to render.
          if (
            menu_items.length == 1 &&
            menu_items[0].type == 'MENU_DEFAULT_LOCAL_TASK'
          ) { html = ''; }
          else {
            var items = [];
            $.each(menu_items, function(index, item) {
                items.push(
                  l(item.title, drupalgap_place_args_in_path(item.path))
                );
            });
            if (items.length > 0) {
              html = theme('item_list', {'items': items});
            }
          }
          // Inject the html.
          $('#' + options.container_id).html(html).trigger('create');
          // If the block's region is a jQM navbar, refresh the navbar.
          if (options['data-role'] && options['data-role'] == 'navbar') {
            $('#' + options.container_id).navbar();
          }
        };

        // First, determine if any child has an entity arg in the path, and/or
        // an access_callback handler.
        var has_entity_arg = false;
        var has_access_callback = false;
        $.each(
          drupalgap.menu_links[router_path].children,
          function(index, child) {
            if (drupalgap.menu_links[child] &&
              (drupalgap.menu_links[child].type == 'MENU_DEFAULT_LOCAL_TASK' ||
               drupalgap.menu_links[child].type == 'MENU_LOCAL_TASK')
            ) {
              if (drupalgap_path_has_entity_arg(arg(null, child))) {
                has_entity_arg = true;
              }
              if (
                typeof
                  drupalgap.menu_links[child].access_callback !== 'undefined'
              ) { has_access_callback = true; }
            }
          }
        );

        // If we have an entity arg, and an access_callback, let's load up the
        // entity asynchronously.
        if (has_entity_arg && has_access_callback) {
          var found_int_arg = false;
          var int_arg_index = null;
          for (var i = 0; i < args.length; i++) {
            if (is_int(parseInt(args[i]))) {
              // Save the arg index so we can replace it later.
              int_arg_index = i;
              found_int_arg = true;
              break;
            }
          }
          if (!found_int_arg) { _success(null); return; }

          // Determine the naming convention for the entity load function.
          var load_function_prefix = args[0]; // default
          if (args[0] == 'taxonomy') {
            if (args[1] == 'vocabulary' || args[1] == 'term') {
              load_function_prefix = args[0] + '_' + args[1];
            }
          }
          var load_function = load_function_prefix + '_load';

          // If the load function exists, load the entity.
          if (drupalgap_function_exists(load_function)) {
            var entity_fn = window[load_function];
            // Load the entity. MVC items need to pass along the module name and
            // model type to its load function. All other entity load functions
            // just need the entity id.
            var entity_id = parseInt(args[int_arg_index]);
            if (args[0] == 'item') {
              entity = entity_fn(args[1], args[2], entity_id);
              _success(entity);
            }
            else {
              // Force a reset if we are editing the entity.
              var reset = false;
              if (arg(2) == 'edit') { reset = true; }
              // Load the entity asynchronously.
              entity_fn(entity_id, { reset: reset, success: _success });
            }
          }
          else {
            console.log('menu_block_view_pageshow - load function not ' +
              'implemented! ' + load_function
            );
          }
        }
        else { _success(null); }
      }
    }
    else {

      // ALL OTHER MENU LINKS

      // If the block's corresponding menu exists, and it has links, iterate
      // over each link, add it to an items array, then theme an item list.
      if (drupalgap.menus[delta] && drupalgap.menus[delta].links) {
        var items = [];
        $.each(drupalgap.menus[delta].links, function(index, menu_link) {
            // Make a deep copy of the menu link so we don't modify it.
            var link = jQuery.extend(true, {}, menu_link);
            // If there are no link options, set up defaults.
            if (!link.options) { link.options = {attributes: {}}; }
            else if (!link.options.attributes) { link.options.attributes = {}; }
            // If the link points to the current path, set it as active.
            if (link.path == path) {
              if (!link.options.attributes['class']) {
                link.options.attributes['class'] = '';
              }
              link.options.attributes['class'] +=
                ' ui-btn-active ui-state-persist ';
            }
            items.push(l(link.title, link.path, link.options));
        });
        if (items.length > 0) {
          // Pass along any menu attributes.
          var attributes = null;
          if (
            drupalgap.menus[delta].options &&
            drupalgap.menus[delta].options.attributes
          ) { attributes = drupalgap.menus[delta].options.attributes; }
          html = theme('item_list', {'items': items, 'attributes': attributes});
        }
      }
      $('#' + options.container_id).html(html).trigger('create');
    }
  }
  catch (error) { console.log('menu_block_view_pageshow - ' + error); }
}

/**
 * Implements hook_install().
 */
function menu_install() {
  try {
    // Grab the list of system menus and save each.
    var system_menus = menu_list_system_menus();
    $.each(system_menus, function(menu_name, menu) {
        menu_save(menu);
    });
  }
  catch (error) { console.log('menu_install - ' + error); }
}

/**
 * Given a menu, this adds it to drupalgap.menus. See menu_list_system_menus
 * for examples of a menu JSON object.
 * @param {Object} menu
 */
function menu_save(menu) {
  try {
    drupalgap.menus[menu.menu_name] = menu;
  }
  catch (error) { console.log('menu_save - ' + error); }
}

/**
 * Given a menu name and page id, this will return its container id for that
 * page.
 * @param {String} menu_name
 * @param {String} page_id
 * @return {String}
 */
function menu_container_id(menu_name, page_id) {
  try {
    return page_id + '_menu_' + menu_name;
  }
  catch (error) { console.log('menu_container_id - ' + error); }
}

/**
 * The page callback for mvc/collection/list/%/%.
 * @param {String} module
 * @param {String} type
 * @return {Object}
 */
function collection_list_page(module, type) {
  try {
    var content = {
      'collection_list': {
        'theme': 'jqm_item_list',
        'title': 'Collection'
      }
    };
    var items = [];
    var collection = collection_load(module, type);
    if (collection) {
      $.each(collection, function(id, item) {
          var path = 'mvc/item/' + module + '/' + type + '/' + id;
          items.push(l(item.name, path));
      });
      content.collection_list.items = items;
    }
    return content;
  }
  catch (error) { console.log('collection_list_page - ' + error); }
}

/**
 * Given a module name and model type, this will return the collection
 * JSON object.
 * @param {String} module
 * @param {String} type
 * @return {*}
 */
function collection_load(module, type) {
  try {
    return JSON.parse(
      window.localStorage.getItem(
        mvc_get_collection_key('collection', module, type)
      )
    );
  }
  catch (error) { console.log('collection_load - ' + error); }
}

/**
 * Given a module name, model type and item collection, this will save the
 * collection JSON object to local storage.
 * @param {String} module
 * @param {String} type
 * @param {Object} collection
 */
function collection_save(module, type, collection) {
  try {
    window.localStorage.setItem(
      mvc_get_collection_key('collection', module, type),
      JSON.stringify(collection)
    );
  }
  catch (error) { console.log('collection_save - ' + error); }
}

/**
 * Given a bucket (e.g. collection, settings), module name and mvc model type,
 * this will return the local storage key used for the model type's item
 * collection.
 * @param {String} bucket
 * @param {String} module
 * @param {String} model_type
 * @return {String}
 */
function mvc_get_collection_key(bucket, module, model_type) {
  try {
    return 'mvc_' + bucket + '_' + module + '_' + model_type;
  }
  catch (error) { console.log('mvc_get_collection_key - ' + error); }
}

/**
 * Implements hook_install().
 */
function mvc_install() {
  try {
    // Load models...
    // For each module that implements hook_mvc_model(), iterate over each model
    // placing it into drupalgap.mvc.models, each model will be placed into
    // a namespace according to the module that implements it, to avoid
    // namespace collisions.
    var modules = module_implements('mvc_model');
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      var models = module_invoke(module, 'mvc_model');
      if (models) {
        // Create namespace for model, keyed by module name.
        if (!drupalgap.mvc.models[module]) {
          drupalgap.mvc.models[module] = {};
        }
        // For each model type...
        $.each(models, function(model_type, model) {
            // Set the primary key 'id', the module name, and model type
            // on the model fields. These are the mvc_model_system_fields().
            model.fields.id = {
              'type': 'hidden',
              'title': 'ID',
              'required': false
            };
            model.fields.module = {
              'type': 'hidden',
              'title': 'Module',
              'required': true,
              'default_value': module
            };
            model.fields.type = {
              'type': 'hidden',
              'title': 'Model Type',
              'required': true,
              'default_value': model_type
            };
            // Add each model type to its namespace within drupalgap.mvc.models
            drupalgap.mvc.models[module][model_type] = model;
            // Save an empty collection to local storage for this model type, if
            // one doesn't already exist.
            var collection_key = mvc_get_collection_key(
              'collection',
              module,
              model_type
            );
            if (!window.localStorage.getItem(collection_key)) {
              window.localStorage.setItem(collection_key, '[]');
              // Save settings for the collection to local storage. The auto
              // increment value represents an item id, we start counting at
              // zero since the collection is an array.
              window.localStorage.setItem(
                mvc_get_collection_key('settings', module, model_type),
                '{"auto_increment":0}'
              );
            }
        });
      }
    }
    //console.log(JSON.stringify(drupalgap.mvc.models));
    //drupalgap_alert('drupalgap_mvc_init');
    // These may not be needed. Perhaps we should just call assumed hooks that
    // should be implemented for any custom views and controllers at the time
    // they are needed, probably no need to bundle them inside drupalgap.mvc.
    //var views = module_invoke_all('mvc_view');
    //var controllers = module_invoke_all('mvc_controller');
  }
  catch (error) { console.log('mvc_install - ' + error); }
}

/**
 * Implements hook_menu().
 * @return {Object}
 */
function mvc_menu() {
  try {
    var items = {
      'mvc/collection/list/%/%': {
        'page_callback': 'collection_list_page',
        'page_arguments': [3, 4]
      },
      'mvc/item/%/%/%': {
        'page_callback': 'item_view_page',
        'page_arguments': [2, 3, 4]
      },
      'mvc/item-add/%/%': {
        title: 'Add',
        page_callback: 'drupalgap_get_form',
        page_arguments: ['item_create_form', 2, 3]
      }
    };
    return items;
  }
  catch (error) { console.log('mvc_menu - ' + error); }
}

/**
 * Returns an array of system fields (properties) to be used on item JSON
 * object.
 * @return {Array}
 */
function mvc_model_system_fields() {
  try {
    return ['id', 'module', 'type'];
  }
  catch (error) { console.log('mvc_model_system_fields - ' + error); }
}

// We'll need developer friendly front end functions, e.g.
// model_load();
// model_save();
// model_delete();
// item_load();
// item_save();
// item_delete();
// etc...

/**
 * Given a module name and a corresponding model name, this will load the model
 * from drupalgap.mvc.models.
 * @param {String} module
 * @param {String} name
 * @return {Object}
 */
function model_load(module, name) {
  try {
    if (
      drupalgap.mvc.models[module] === 'undefined' ||
      drupalgap.mvc.models[module][name] === 'undefined'
    ) { return false; }
    return drupalgap.mvc.models[module][name];
  }
  catch (error) { console.log('model_load - ' + error); }
}

/**
 * Given a module type, and model type, this generates and returns the form JSON
 * object to create a model item.
 * @param {Object} form
 * @param {Object} form_state
 * @param {String} module
 * @param {String} type
 * @return {Object}
 */
function item_create_form(form, form_state, module, type) {
   try {
    //var form = drupalgap_form_defaults('item_create_form');
    var model = model_load(module, type);
    if (model) {
      // @todo - this could be dangerous just overriding the elements variable,
      // we should iterate over the model fields and add them one by one
      // instead.
      form.elements = model.fields;
      form.buttons.cancel = drupalgap_form_cancel_button();
      form.elements.submit = {
        type: 'submit',
        value: 'Create'
      };
    }
    return form;
  }
  catch (error) { console.log('item_create_form - ' + error); }
}

/**
 * Handles the submission of an mvc model item creation form.
 * @param {Object} form
 * @param {Object} form_state
 */
function item_create_form_submit(form, form_state) {
  try {
    // Save the item and then view it.
    if (item_save(form_state.values)) {
      /*var path = 'item/' +
                 form_state.values.module + '/' +
                 form_state.values.type + '/' +
                 form_state.values.id;*/
      var path = 'mvc/collection/list/' +
                 form_state.values.module + '/' +
                 form_state.values.type;
      // If there is a form action path set, use that instead.
      if (form.action) { path = form.action; }
      // Go to our destination path, and force a reload on the page.
      drupalgap_goto(path, {reloadPage: true});
    }
    else {
      var msg = 'item_create_form_submit - failed to save item!';
      drupalgap_alert(msg);
    }
  }
  catch (error) {
    console.log('item_create_form_submit - ' + error);
  }
}

/**
 * Given a module name, mvc model type, and item id, this will return the item,
 * or false if the item fails to load.
 * @param {String} module
 * @param {String} type
 * @param {String} id
 * @return {Object}
 */
function item_load(module, type, id) {
  try {
    var item = false;
    var collection = collection_load(module, type);
    if (collection && typeof collection[id] !== 'undefined') {
      item = collection[id];
    }
    return item;
  }
  catch (error) { console.log('item_load - ' + error); }
}

/**
 * Given an mvc item, this saves it to local storage.
 * @param {Object} item
 * @return {Boolean}
 */
function item_save(item) {
  try {
    if (typeof item === 'undefined') { return false; }

    // Grab the settings for this collection.
    var settings_key = mvc_get_collection_key(
      'settings',
      item.module,
      item.type
    );
    var settings = JSON.parse(window.localStorage.getItem(settings_key));

    // If there is no id, then this is a new item, grab the next id to use.
    if (!item.id) {
      item.id = settings.auto_increment;
    }
    // Load the collection from local storage.
    var collection = collection_load(item.module, item.type);

    // Add the item onto the collection.
    collection[item.id] = item;

    // Save the collection to local storage.
    collection_save(item.module, item.type, collection);

    // Increment to the next item id and save the settings.
    settings.auto_increment = item.id + 1;
    window.localStorage.setItem(settings_key, JSON.stringify(settings));

    return true;
  }
  catch (error) { console.log('item_save - ' + error); }
}

/**
 * The page callback for mvc/item/%/%/%.
 * @param {String} module
 * @param {String} type
 * @param {Object} item
 * @return {String}
 */
function item_view_page(module, type, item) {
  try {
    var html = '';
    var model = model_load(module, type);
    if (model) { html = theme('item', {'model': model, 'item': item}); }
    return html;
  }
  catch (error) { console.log('item_view_page - ' + error); }
}

/**
 * Given a node, this determines if the current user has access to it. Returns
 * true if so, false otherwise. This function implementation is incomplete, use
 * with caution.
 * @param {Object} node
 * @return {Boolean}
 */
function node_access(node) {
  try {
    if (
      (
        node.uid == Drupal.user.uid &&
        user_access('edit own ' + node.type + ' content')
      ) ||
      user_access('edit any ' + node.type + ' content')
    ) { return true; }
    else { return false; }
  }
  catch (error) { console.log('node_access - ' + error); }
}

/**
 * Page call back for node/add.
 * @return {Object}
 */
function node_add_page() {
  try {
    var content = {
      'header': {'markup': '<h2>Create Content</h2>'},
      'node_type_listing': {
        'theme': 'jqm_item_list',
        'title': 'Content Types',
        'attributes': {'id': 'node_type_listing_items'}
      }
    };
    var items = [];
    $.each(
      Drupal.user.content_types_user_permissions,
      function(type, permissions) {
        if (permissions.create) {
          items.push(l(drupalgap.content_types_list[type].name,
          'node/add/' + type));
        }
      }
    );
    content.node_type_listing.items = items;
    return content;
  }
  catch (error) { console.log('node_add_page - ' + error); }
}

/**
 * Page call back function for node/add/[type].
 * @param {String} type
 * @return {Object}
 */
function node_add_page_by_type(type) {
  try {
    return drupalgap_get_form('node_edit', {'type': type});
  }
  catch (error) { console.log('node_add_page_by_type - ' + error); }
}

/**
 * The node edit form.
 * @param {Object} form
 * @param {Object} form_state
 * @param {Object} node
 * @return {Object}
 */
function node_edit(form, form_state, node) {
  try {
    // Setup form defaults.
    form.entity_type = 'node';
    form.bundle = node.type;

    // Add the entity's core fields to the form.
    drupalgap_entity_add_core_fields_to_form('node', node.type, form, node);

    // Add the fields for this content type to the form.
    drupalgap_field_info_instances_add_to_form('node', node.type, form, node);

    // Add submit to form.
    form.elements.submit = {
      'type': 'submit',
      'value': 'Save'
    };

    // Add cancel button to form.
    form.buttons['cancel'] = drupalgap_form_cancel_button();

    // Add delete button to form if we're editing a node.
    if (node && node.nid) {
      form.buttons['delete'] =
        drupalgap_entity_edit_form_delete_button('node', node.nid);
    }

    return form;
  }
  catch (error) { console.log('node_edit - ' + error); }
}

/**
 * The node edit form's submit function.
 * @param {Object} form
 * @param {Object} form_state
 */
function node_edit_submit(form, form_state) {
  try {
    var node = drupalgap_entity_build_from_form_state(form, form_state);
    drupalgap_entity_form_submit(form, form_state, node);
  }
  catch (error) { console.log('node_edit_submit - ' + error); }
}

/**
 * Implements hook_menu().
 * @return {Object}
 */
function node_menu() {
  try {
    var items = {
      'node': {
        'title': 'Content',
        'page_callback': 'node_page',
        'pageshow': 'node_page_pageshow'
      },
      'node/add': {
        'title': 'Add content',
        'page_callback': 'node_add_page'
      },
      'node/add/%': {
        'title': 'Add content',
        'page_callback': 'node_add_page_by_type',
        'page_arguments': [2],
        options: {reloadPage: true}
      },
      'node/%': {
        'title': 'Node',
        'page_callback': 'node_page_view',
        'page_arguments': [1],
        'pageshow': 'node_page_view_pageshow',
        'title_callback': 'node_page_title',
        'title_arguments': [1]
      },
      'node/%/view': {
        'title': 'View',
        'type': 'MENU_DEFAULT_LOCAL_TASK',
        'weight': -10
      },
      'node/%/edit': {
        'title': 'Edit',
        'page_callback': 'entity_page_edit',
        'pageshow': 'entity_page_edit_pageshow',
        'page_arguments': ['node_edit', 'node', 1],
        'weight': 0,
        'type': 'MENU_LOCAL_TASK',
        'access_callback': 'node_access',
        'access_arguments': [1],
        options: {reloadPage: true}
      }
    };
    return items;
  }
  catch (error) { console.log('node_menu - ' + error); }
}

/**
 * Page callback for node.
 * @return {Object}
 */
function node_page() {
  try {
    var content = {
      'create_content': {
        'theme': 'button_link',
        'path': 'node/add',
        'text': 'Create Content'
      },
      'node_listing': {
        'theme': 'jqm_item_list',
        'title': 'Content List',
        'items': [],
        'attributes': {'id': 'node_listing_items'}
      }
    };
    return content;
  }
  catch (error) { console.log('node_page - ' + error); }
}

/**
 * The jQM pageshow callback for the node listing page.
 */
function node_page_pageshow() {
  try {
    // Grab some recent content and display it.
    views_datasource_get_view_result(
      'drupalgap/views_datasource/drupalgap_content', {
        success: function(content) {
          // Extract the nodes into items, then drop them in the list.
          var items = [];
          $.each(content.nodes, function(index, object) {
              items.push(l(object.node.title, 'node/' + object.node.nid));
          });
          drupalgap_item_list_populate('#node_listing_items', items);
        }
      }
    );
  }
  catch (error) { console.log('node_page_pageshow - ' + error); }
}

/**
 * Page callback for node/%.
 * @param {Number} nid
 * @return {Object}
 */
function node_page_view(nid) {
  try {
    if (nid) {
      var content = {
        container: _drupalgap_entity_page_container('node', nid, 'view')
      };
      return content;
    }
    else { drupalgap_error('No node id provided!'); }
  }
  catch (error) { console.log('node_page_view - ' + error); }
}

/**
 * jQM pageshow handler for node/% pages.
 * @param {Number} nid
 */
function node_page_view_pageshow(nid) {
  try {
    node_load(nid, {
        success: function(node) {
          // Build the node display.
          var build = {
            'theme': 'node',
            // @todo - is this line of code doing anything?
            'node': node,
            // @todo - this is a core field and should by fetched from entity.js
            'title': {'markup': node.title},
            'content': {'markup': node.content}
          };
          // Build an empty list for the comments.
          var comments = {
            title: 'Comments',
            items: [],
            attributes: {
              id: comment_list_id(node.nid)
            }
          };
          // If the comments are closed (1) or open (2), show the comments.
          if (node.comment != 0) {
            if (node.comment == 1 || node.comment == 2) {
              // Render the comment form, so we can add it to the content later.
              var comment_form = '';
              if (node.comment == 2) {
                comment_form = drupalgap_get_form(
                  'comment_edit',
                  { nid: node.nid },
                  node
                );
              }
              // If there are any comments, load them.
              if (node.comment_count != 0) {
                var query = {
                  parameters: {
                    nid: node.nid
                  }
                };
                comment_index(query, {
                    success: function(results) {
                      try {
                        $.each(results, function(index, comment) {
                            comments.items.push(theme('comment', {
                                comment: comment
                            }));
                        });
                        // Render the comment list.
                        build.content.markup += theme(
                          'jqm_item_list',
                          comments
                        );
                        // If the comments are open, show the comment form.
                        if (node.comment == 2) {
                          build.content.markup += comment_form;
                        }
                        // Finally, inject the page.
                        _drupalgap_entity_page_container_inject(
                          'node', node.nid, 'view', build
                        );
                      }
                      catch (error) {
                        var msg = 'node_page_view_pageshow - comment_index - ' +
                          error;
                        console.log(msg);
                      }
                    }
                });
              }
              else {
                // There weren't any comments, show the comment form if comments
                // are open, then inject the page.
                if (node.comment == 2) {
                  build.content.markup += theme('jqm_item_list', comments);
                  build.content.markup += comment_form;
                }
                _drupalgap_entity_page_container_inject(
                  'node', node.nid, 'view', build
                );
              }
            }
          }
          else {
            // Comments are hidden (0), so let's render an empty list, then
            // inject the content into the page.
            _drupalgap_entity_page_container_inject(
              'node', node.nid, 'view', build
            );
          }
        }
    });
  }
  catch (error) { console.log('node_page_view_pageshow - ' + error); }
}

/**
 * The title call back function for the node view page.
 * @param {Function} callback
 * @param {Number} nid
 */
function node_page_title(callback, nid) {
  try {
    // Try to load the node title, then send it back to the given callback.
    var title = '';
    var node = node_load(nid, {
        success: function(node) {
          if (node && node.title) { title = node.title; }
          callback.call(null, title);
        }
    });
  }
  catch (error) { console.log('node_page_title - ' + error); }
}

/**
 * Implements hook_theme().
 * @return {Object}
 */
function node_theme() {
  try {
    return {
      'node': {
        'template': 'node'
      }
    };
  }
  catch (error) { console.log('node_theme - ' + error); }
}

/**
 * Implements hook_menu().
 * @return {Object}
 */
function search_menu() {
  try {
    var items = {};
    items['search/%/%'] = {
      title: 'Search',
      'page_callback': 'drupalgap_get_form',
      'pageshow': 'search_form_pageshow',
      'page_arguments': ['search_form'],
      'access_arguments': ['search content']
    };
    return items;
  }
  catch (error) { console.log('search_menu - ' + error); }
}

/**
 * The search form.
 * @param {Object} form
 * @param {Object} form_state
 * @param {String} form_id
 * @return {Object}
 */
function search_form(form, form_state, form_id) {
  try {
    var type = arg(1);
    var keys = arg(2);
    form.elements.type = {
      type: 'hidden',
      default_value: type ? type : 'node'
    };
    form.elements.keys = {
      type: 'textfield',
      title: 'Enter your keywords',
      required: true,
      default_value: keys ? keys : ''
    };
    form.elements.submit = {
      type: 'submit',
      value: 'Go',
      options: {
        attributes: {
          'data-icon': 'search'
        }
      }
    };
    form.suffix += theme('jqm_item_list', {
        items: [],
        options: {
          attributes: {
            id: 'search_form_results'
          }
        }
    });
    return form;
  }
  catch (error) { console.log('search_form - ' + error); }
}

/**
 * The search form submit handler.
 * @param {Object} form
 * @param {Object} form_state
 */
function search_form_submit(form, form_state) {
  try {
    var type = form_state.values.type;
    var keys = form_state.values.keys;
    switch (type) {
      case 'node':
        search_node(keys, {
            success: function(results) {
              var items = [];
              $.each(results, function(index, result) {
                  var link = theme('search_result_node', result);
                  items.push(link);
              });
              drupalgap_item_list_populate('#search_form_results', items);
            }
        });
        break;
      default:
        console.log('search_form_submit - unsupported type (' + type + ')');
        break;
    }
  }
  catch (error) { console.log('search_form_submit - ' + error); }
}

/**
 * The pageshow callback for the search form page.
 * @param {String} form_id
 */
function search_form_pageshow(form_id) {
  try {
    var type = arg(1);
    var keys = arg(2);
    switch (type) {
      case 'node':
        search_node(keys, {
            success: function(results) {
              var items = [];
              $.each(results, function(index, result) {
                  var link = theme('search_result_node', result);
                  items.push(link);
              });
              drupalgap_item_list_populate('#search_form_results', items);
            }
        });
        break;
      default:
        console.log('search_form_pageshow - unsupported type (' + type + ')');
        break;
    }
  }
  catch (error) { console.log('search_form_pageshow - ' + error); }
}

/**
 * The search node service.
 * @param {String} keys The keyword(s) to search for.
 * @param {Object} options
 */
function search_node(keys, options) {
  try {
    options.method = 'GET';
    options.path = 'search_node/retrieve.json&keys=' + encodeURIComponent(keys);
    options.service = 'search_node';
    options.resource = 'retrieve';
    Drupal.services.call(options);
  }
  catch (error) { console.log('search_node - ' + error); }
}

/**
 * Themes a search result node.
 * @param {Object} variables
 * @return {String}
 */
function theme_search_result_node(variables) {
  try {
    return l(
      '<h2>' + variables.title + '</h2>' +
        '<p>' + variables.snippet + '</p>',
      'node/' + variables.node.nid
    );
  }
  catch (error) { console.log('theme_search_result_node - ' + error); }
}

/**
 * Given an entity type, this will return its corresponding service resource, or
 * null if the resource doesn't exist.
 * @param {String} entity_type
 * @return {?Type|Object|null}
 */
function drupalgap_services_get_entity_resource(entity_type) {
  try {
    console.log(
      'WARNING: drupalgap_services_get_entity_resource() is deprecated! ' +
      'Use services_get_resource_function_for_entity() instead.'
    );
    // @todo - deprecate this function, it is no longer needed now that entity
    // c.r.u.d. is built into jDrupal.
    if (drupalgap.services[entity_type]) {
      return drupalgap.services[entity_type];
    }
    else { return null; }
  }
  catch (error) {
    console.log('drupalgap_services_get_entity_resource - ' + error);
  }
}

/**
 * Returns the name of the jDrupal function to be used when in need of an entity
 * C.R.U.D. operation.
 * @param {String} entity_type
 * @param {String} crud
 * @return {String}
 */
function services_get_resource_function_for_entity(entity_type, crud) {
  try {
    var name = entity_type + '_';
    switch (crud) {
      case 'create': name += 'save'; break;
      case 'retrieve': name += 'load'; break;
      case 'update': name += 'save'; break;
      case 'delete': name += 'delete'; break;
      default: name += 'load'; break;
    }
    return name;
  }
  catch (error) {
    console.log('services_get_resource_function_for_entity - ' + error);
  }
}


/**
 * Given a json drupalgap options array from a service resource results call,
 * this extracts data based on the resource and populates necessary global vars.
 * @param {Object} options
 */
function drupalgap_service_resource_extract_results(options) {
  try {
    if (options.service == 'system' && options.resource == 'connect') {
      // The system connect resource's success function places what is in
      // options.data.user to overwrite Drupal.user, so anything we want in
      // the Drupal.user object must be added to options.data.user isntead.
      // Extract and build the user's permissions.
      options.data.user.permissions = [];
      var permissions = options.data.user_permissions;
      for (var permission in permissions) {
        options.data.user.permissions.push(permissions[permission]);
      }
      // Pull out the content types, and set them by their type.
      $.each(options.data.content_types_list, function(index, object) {
          drupalgap.content_types_list[object.type] = object;
      });
      // Pull out the content types user permissions.
      options.data.user.content_types_user_permissions =
        options.data.content_types_user_permissions;
      // Pull out the site settings.
      drupalgap.site_settings = options.data.site_settings;
      // Pull out the date formats and types.
      if (typeof options.data.date_formats !== 'undefined') {
        drupalgap.date_formats = options.data.date_formats;
      }
      if (typeof options.data.date_types !== 'undefined') {
        drupalgap.date_types = options.data.date_types;
      }
    }
  }
  catch (error) {
    console.log('drupalgap_service_resource_extract_results - ' + error);
  }
}

/**
 * Given the result of a drupalgap.services.rss.retrieve.call, this will iterate
 * over the RSS items and assemble them into a nice array of JSON objects and
 * return them. Returns null if it fails.
 * @param {Object} data
 * @return {?Type|Array|null}
 */
function drupalgap_services_rss_extract_items(data) {
  try {
    var items = null;
    var $xml = $(data);
    if ($xml) {
      // Extract the feeds items, then drop them in the list.
      var items = [];
      $xml.find('item').each(function() {
          var $this = $(this), item = {
            title: $this.find('title').text(),
            link: $this.find('link').text(),
            description: $this.find('description').text(),
            pubDate: $this.find('pubDate').text(),
            author: $this.find('author').text()
          };
          items.push(item);
      });
    }
    return items;
  }
  catch (error) {
    console.log('drupalgap_services_rss_extract_items - ' + error);
  }
}

/**
 * Implements hook_block_info().
 * @return {Object}
 */
function system_block_info() {
  try {
    // System blocks.
    var blocks = {
      'main': {
        'delta': 'main',
        'module': 'system'
      },
      messages: {
        delta: 'messages',
        module: 'system'
      },
      'logo': {
        'delta': 'logo',
        'module': 'system'
      },
      'title': {
        'delta': 'title',
        'module': 'system'
      },
      'powered_by': {
        'delta': 'powered_by',
        'module': 'system'
      },
      'help': {
        'delta': 'help',
        'module': 'system'
      }
    };
    // Make additional blocks for each system menu.
    var system_menus = menu_list_system_menus();
    $.each(system_menus, function(menu_name, menu) {
        var block_delta = menu.menu_name;
        eval(
          'blocks.' + block_delta + ' = ' +
            '{"name":"' + block_delta + '", "delta":"' + block_delta + '", ' +
            '"module":"menu"};'
        );
    });
    return blocks;
  }
  catch (error) { console.log('system_block_info - ' + error); }
}

/**
 * Implements hook_block_view().
 * @param {String} delta
 * @return {String}
 */
function system_block_view(delta) {
  try {
    switch (delta) {
      case 'main':
        // This is the main content block, it is required to be in a theme's
        // region for the content of a page to show up (nodes, users, taxonomy,
        // comments, etc). Depending on the menu link router, we need to route
        // this through the appropriate template files and functions.
        return drupalgap_render_page();
        break;
      case 'messages':
        // If there are any messages waiting to be displayed, render them, then
        // clear out the messages array.
        var html = '';
        if (drupalgap.messages.length == 0) { return html; }
        $.each(drupalgap.messages, function(index, msg) {
            html += '<div class="messages ' + msg.type + '">' +
              msg.message +
            '</div>';
        });
        drupalgap.messages = [];
        return html;
        break;
      case 'logo':
        if (drupalgap.settings.logo) {
          return '<div>' +
            l(theme('image', {'path': drupalgap.settings.logo}), '') +
          '</div>';
        }
        return '';
        break;
      case 'title':
        var title_id = system_title_block_id(drupalgap_path_get());
        return '<h1 id="' + title_id + '"></h1>';
        break;
      case 'powered_by':
        return '<p style="text-align: center;">Powered by: ' +
          l('DrupalGap', 'http://www.drupalgap.org', {InAppBrowser: true}) +
        '</p>';
        break;
      case 'help':
        return l('Help', 'http://www.drupalgap.org/support');
        break;
      default:
        return '';
        break;
    }
  }
  catch (error) { console.log('system_block_info - ' + error); }
}

/**
 * Implements hook_menu().
 * @return {Object}
 */
function system_menu() {
  try {
    var items = {
      'dashboard': {
        'title': 'Dashboard',
        'page_callback': 'system_dashboard_page'
      },
      'error': {
        'title': 'Error',
        'page_callback': 'system_error_page'
      },
      'offline': {
        'title': 'Offline',
        'page_callback': 'system_offline_page'
      },
      '401': {
        title: '401 - Not Authorized',
        page_callback: 'system_401_page'
      },
      '404': {
        title: '404 - Not Found',
        page_callback: 'system_404_page'
      }
    };
    return items;
  }
  catch (error) { console.log('system_menu - ' + error); }
}

/**
 * Page callback for the 401 page.
 * @param {String} path
 * @return {String}
 */
function system_401_page(path) {
  try { return 'Sorry, you are not authorized to view this page.'; }
  catch (error) { console.log('system_401_page - ' + error); }
}

/**
 * Page callback for the 404 page.
 * @param {String} path
 * @return {String}
 */
function system_404_page(path) {
  try { return 'Sorry, the page you requested was not found.'; }
  catch (error) { console.log('system_404_page - ' + error); }
}

/**
 * Page callback for the dashboard page.
 * @return {Object}
 */
function system_dashboard_page() {
  try {
    var content = {};
    content.site_info = {
      markup: '<h4 style="text-align: center;">' +
        Drupal.settings.site_path +
      '</h4>'
    };
    content.welcome = {
      markup: '<h2 style="text-align: center;">Welcome to DrupalGap</h2>' +
        '<p>The open source mobile application development kit for Drupal!</p>'
    };
    if (drupalgap.settings.logo) {
      content.logo = {
        markup: '<center>' +
                 theme('image', {path: drupalgap.settings.logo}) +
               '</center>'
      };
    }
    content.get_started = {
      theme: 'button_link',
      text: 'Getting Started Guide',
      path: 'http://www.drupalgap.org/get-started',
      options: {InAppBrowser: true}
    };
    content.support = {
      theme: 'button_link',
      text: 'Support',
      path: 'http://www.drupalgap.org/support',
      options: {InAppBrowser: true}
    };
    return content;
  }
  catch (error) { console.log('system_dashboard_page - ' + error); }
}

/**
 * The page callback for the error page.
 * @return {Object}
 */
function system_error_page() {
  try {
    var content = {
      info: {
        markup: '<p>An unexpected error has occurred!</p>'
      }
    };
    return content;
  }
  catch (error) { console.log('system_error_page - ' + error); }
}

/**
 * Call back for the offline page.
 * @return {Object}
 */
function system_offline_page() {
  try {
    var content = {
      'message': {
        'markup': '<h2>Failed Connection</h2>' +
          "<p>Oops! We couldn't connect to:</p>" +
          '<p>' + Drupal.settings.site_path + '</p>'
      },
      'try_again': {
        'theme': 'button',
        'text': 'Try Again',
        'attributes': {
          'onclick': 'javascript:offline_try_again();'
        }
      },
      'footer': {
        'markup': "<p>Check your device's network settings and try again.</p>"
      }
    };
    return content;
  }
  catch (error) { console.log('system_offline_page - ' + error); }
}

/**
 * When the 'try again' button is clicked, check for a connection and if it has
 * one make a call to system connect then go to the front page, otherwise just
 * inform user the device is still offline.
 * @return {*}
 */
function offline_try_again() {
  try {
    var connection = drupalgap_check_connection();
    if (drupalgap.online) {
      system_connect({
        success: function() {
          drupalgap_goto('');
        }
      });
    }
    else {
      var msg = 'Sorry, no connection found! (' + connection + ')';
      drupalgap_alert(msg, {
          title: 'Offline'
      });
      return false;
    }
  }
  catch (error) { console.log('offline_try_again - ' + error); }
}

/**
 * Returns an array of region names defined by the system that themes must use.
 * We do this so Core and Contrib Modules can use these regions for UI needs.
 * @return {Array}
 */
function system_regions_list() {
  try {
    var regions = ['header', 'content', 'footer'];
    return regions;
  }
  catch (error) { console.log('system_regions_list - ' + error); }
}

/**
 * Add default buttons to a form and set its prefix.
 * @param {Object} form
 * @param {Object} form_state
 * @return {Object}
 */
function system_settings_form(form, form_state) {
  try {
    // Add submit button to form if one isn't present.
    if (!form.elements.submit) {
      form.elements.submit = {
        type: 'submit',
        value: 'Save configuration'
      };
    }
    // Add cancel button to form if one isn't present.
    if (!form.buttons.cancel) {
      form.buttons['cancel'] = drupalgap_form_cancel_button();
    }
    // Attach submit handler.
    form.submit.push('system_settings_form_submit');
    return form;
  }
  catch (error) { console.log('system_settings_form - ' + error); }
}

/**
 * Execute the system_settings_form.
 * @param {Object} form
 * @param {Object} form_state
 */
function system_settings_form_submit(form, form_state) {
  try {
    if (form_state.values) {
      $.each(form_state.values, function(variable, value) {
          variable_set(variable, value);
      });
    }
    // @todo - a nice spot to have a drupalgap_set_message function, eh?
    drupalgap_alert('The configuration options have been saved.');
  }
  catch (error) { console.log('system_settings_form_submit - ' + error); }
}

/**
 * Returns the block id used on the system's title block.
 * @param {String} path
 * @return {String}
 */
function system_title_block_id(path) {
  try {
    var id = 'drupalgap_page_title_' + drupalgap_get_page_id(path);
    return id;
  }
  catch (error) { console.log('system_title_block_id - ' + error); }
}

/**
 * Determine whether the user has a given privilege. Optionally pass in a user
 * account JSON object for the second paramater to check that particular
 * account.
 * @param {String} string The permission, such as "administer nodes", being
 *                        checked for.
 * @return {Boolean}
 */
function user_access(string) {
  try {
    var account;
    if (arguments[1]) { account = arguments[1]; }
    else { account = Drupal.user; }
    if (account.uid == 1) { return true; }
    var access = false;
    $.each(account.permissions, function(index, object) {
        if (object.permission == string) {
          access = true;
          return false;
        }
    });
    return access;
  }
  catch (error) { console.log('user_access - ' + error); }
}

/**
 * The access callback for the user/%/edit page.
 * @param {Object} account
 * @return {Boolean}
 */
function user_edit_access(account) {
  try {
    // If the current user is looking at their own account, or if they have the
    // 'administer users' permission, then they are allowed to edit the account.
    if (Drupal.user.uid == account.uid || user_access('administer users')) {
      return true;
    }
    return false;
  }
  catch (error) { console.log('user_edit_access - ' + error); }
}

/**
 * A page call back function to display a simple list of drupal users.
 * @return {Object}
 */
function user_listing() {
  try {
    // Place an empty item list that will hold a list of users.
    var content = {
      'user_listing': {
        'theme': 'jqm_item_list',
        'title': 'Users',
        'items': [],
        'attributes': {'id': 'user_listing_items'}
      }
    };
    return content;
  }
  catch (error) { console.log('user_listing - ' + error); }
}

/**
 * The pageshow callback handler for the user listing page.
 */
function user_listing_pageshow() {
  try {
    // Grab some users and display them.
    drupalgap.views_datasource.call({
      'path': 'drupalgap/views_datasource/drupalgap_users',
      'success': function(data) {
        // Extract the users into items, then drop them in the list.
        var items = [];
        $.each(data.users, function(index, object) {
            items.push(l(object.user.name, 'user/' + object.user.uid));
        });
        drupalgap_item_list_populate('#user_listing_items', items);
      }
    });
  }
  catch (error) { console.log('user_listing_pageshow - ' + error); }
}

/**
 * The user login form.
 * @param {Object} form
 * @param {Object} form_state
 * @return {Object}
 */
function user_login_form(form, form_state) {
  try {
    form.entity_type = 'user';
    form.bundle = null;
    form.elements.name = {
      'type': 'textfield',
      'title': 'Username',
      'required': true
    };
    form.elements.pass = {
      'type': 'password',
      'title': 'Password',
      'required': true
    };
    form.elements.submit = {
      'type': 'submit',
      'value': 'Login'
    };
    return form;
  }
  catch (error) { console.log('user_login_form - ' + error); }
}

/**
 * The user login form submit handler.
 * @param {Object} form
 * @param {Object} form_state
 */
function user_login_form_submit(form, form_state) {
  try {
    user_login(form_state.values.name, form_state.values.pass, {
      success: function(result) {
        drupalgap_goto(drupalgap.settings.front);
      }
    });
  }
  catch (error) { console.log('user_login_form_submit - ' + error); }
}

/**
 * The user logout page callback.
 * @return {String}
 */
function user_logout_callback() {
  try { return '<p>Logging out...</p>'; }
  catch (error) { console.log('user_logout_callback - ' + error); }
}

/**
 * The user logout pageshow callback. This actually handles the call to the
 * user logout service resource.
 */
function user_logout_pagechange() {
  try {
    user_logout({
      success: function(data) {
        drupalgap_goto(drupalgap.settings.front);
      }
    });
  }
  catch (error) { console.log('user_logout_pagechange - ' + error); }
}

/**
 * Implements hook_menu().
 * @return {Object}
 */
function user_menu() {
  try {
    var items = {
      'user': {
        'page_callback': 'user_page'
      },
      'user/login': {
        'title': 'Login',
        'page_callback': 'drupalgap_get_form',
        'page_arguments': ['user_login_form'],
        options: {reloadPage: true}
      },
      'user/logout': {
        'title': 'Logout',
        'page_callback': 'user_logout_callback',
        'pagechange': 'user_logout_pagechange',
        options: {reloadPage: true}
      },
      'user/register': {
        'title': 'Register',
        'page_callback': 'drupalgap_get_form',
        'page_arguments': ['user_register_form'],
        'access_callback': 'user_register_access',
        options: {reloadPage: true}
      },
      'user/%': {
        'title': 'My account',
        'page_callback': 'user_view',
        'pageshow': 'user_view_pageshow',
        'page_arguments': [1]
      },
      'user/%/view': {
        'title': 'View',
        'type': 'MENU_DEFAULT_LOCAL_TASK',
        'weight': -10
      },
      'user/%/edit': {
        'title': 'Edit',
        'page_callback': 'entity_page_edit',
        'pageshow': 'entity_page_edit_pageshow',
        'page_arguments': ['user_profile_form', 'user', 1],
        'access_callback': 'user_edit_access',
        'access_arguments': [1],
        'weight': 0,
        'type': 'MENU_LOCAL_TASK',
        options: {reloadPage: true}
      },
      'user-listing': {
        'title': 'Users',
        'page_callback': 'user_listing',
        'access_arguments': ['access user profiles'],
        'pageshow': 'user_listing_pageshow'
      }
    };
    return items;
  }
  catch (error) { console.log('user_menu - ' + error); }
}

/**
 * Page callback for the user page.
 * @return {String}
 */
function user_page() {
  try {
    // NOTE, this page call back isn't actually used, because the 'user' path
    // in DrupalGap is redirected to either 'user/login' or e.g.
    // 'user/123/view'.
    return 'user_page()';
  }
  catch (error) { console.log('user_page - ' + error); }
}

/**
 * Access callback for the user registration page.
 * @return {Boolean}
 */
function user_register_access() {
  try {
    switch (drupalgap.site_settings.user_register) {
      case '0': // admins only can register
        return false;
        break;
      case '1': // visitors can register
      case '2': // visitors can register, but admin approval is needed
        return true;
        break;
    }
  }
  catch (error) { console.log('user_register_access - ' + error); }
}

/**
 * The user registration form.
 * @param {Object} form
 * @param {Object} form_state
 * @return {Object}
 */
function user_register_form(form, form_state) {
  try {
    form.entity_type = 'user';
    form.bundle = null;
    form.elements.name = {
      'type': 'textfield',
      'title': 'Username',
      'required': true,
      'description': 'Spaces are allowed; punctuation is not allowed except ' +
        'for periods, hyphens, apostrophes, and underscores.'
    };
    form.elements.mail = {
      'type': 'email',
      'title': 'E-mail address',
      'required': true
    };
    // If e-mail verification is not requred, provide password fields and
    // the confirm e-mail address field.
    if (!drupalgap.site_settings.user_email_verification) {
      form.elements.conf_mail = {
        type: 'email',
        title: 'Confirm e-mail address',
        required: true
      };
      form.elements.pass = {
        type: 'password',
        title: 'Password',
        required: true
      };
      form.elements.pass2 = {
        type: 'password',
        title: 'Confirm password',
        required: true
      };
    }
    // @todo - instead of a null bundle, it appears drupal uses the bundle
    // 'user' instead.
    drupalgap_field_info_instances_add_to_form('user', null, form, null);
    // Add registration messages to form.
    form.user_register = {
      'user_mail_register_no_approval_required_body': 'Registration complete!',
      'user_mail_register_pending_approval_required_body':
        'Registration complete, waiting for administrator approval.',
      'user_mail_register_email_verification_body':
        'Registration complete, check your e-mail inbox to verify the account.'
    };
    // Set the auto login boolean. This only happens when the site's account
    // settings require no e-mail verification. Others can stop this from
    // happening via hook_form_alter().
    form.auto_user_login = true;
    // Add submit button.
    form.elements.submit = {
      'type': 'submit',
      'value': 'Create new account'
    };
    return form;
  }
  catch (error) { console.log('user_register_form - ' + error); }
}

/**
 * Define the form's validation function (optional).
 * @param {Object} form
 * @param {Object} form_state
 */
function user_register_form_validate(form, form_state) {
  try {
    // If e-mail verification is not required, make sure the passwords match.
    if (!drupalgap.site_settings.user_email_verification &&
      form_state.values.pass != form_state.values.pass2) {
      drupalgap_form_set_error('pass', 'Passwords do not match!');
    }
    // If there are two e-mail address fields on the form, make sure they match.
    if (!empty(form_state.values.mail) && !empty(form_state.values.conf_mail) &&
      form_state.values.mail != form_state.values.conf_mail
    ) { drupalgap_form_set_error('mail', 'E-mail addresses do not match!'); }
  }
  catch (error) {
    console.log('user_register_form_validate - ' + error);
  }
}

/**
 * The user registration form submit handler.
 * @param {Object} form
 * @param {Object} form_state
 */
function user_register_form_submit(form, form_state) {
  try {
    var account = drupalgap_entity_build_from_form_state(form, form_state);
    user_register(account, {
      success: function(data) {
        // Check if e-mail verification is required or not..
        if (!drupalgap.site_settings.user_email_verification) {
          // E-mail verification not needed, if administrator approval is
          // needed, notify the user, otherwise log them in.
          if (drupalgap.site_settings.user_register == '2') {
            drupalgap_alert(
            form.user_register.user_mail_register_pending_approval_required_body
            );
            drupalgap_goto('');
          }
          else {
            drupalgap_alert(
              form.user_register.user_mail_register_no_approval_required_body
            );
            // If we're automatically logging in do it, otherwise just go to
            // the front page.
            if (form.auto_user_login) {
              user_login(account.name, account.pass, {
                  success: function(result) {
                    drupalgap_goto('');
                  }
              });
            }
            else { drupalgap_goto(''); }
          }
        }
        else {
          // E-mail verification needed... notify the user.
          drupalgap_alert(
            form.user_register.user_mail_register_email_verification_body
          );
          drupalgap_goto('');
        }
      },
      error: function(xhr, status, message) {
        // If there were any form errors, display them.
        var msg = _drupalgap_form_submit_response_errors(form, form_state, xhr,
          status, message);
        if (msg) { drupalgap_alert(msg); }
      }
    });
  }
  catch (error) { console.log('user_register_form_submit - ' + error); }
}

/**
 * The user profile form.
 * @param {Object} form
 * @param {Object} form_state
 * @param {Object} account
 * @return {Object}
 */
function user_profile_form(form, form_state, account) {
  try {
    // Setup form defaults.
    form.entity_type = 'user';
    form.bundle = null;

    // Add the entity's core fields to the form.
    drupalgap_entity_add_core_fields_to_form('user', null, form, account);

    // Add the fields for accounts to the form.
    drupalgap_field_info_instances_add_to_form('user', null, form, account);

    // Add password fields to the form. We show the current password field only
    // if the user is editing their account. We show the password and confirm
    // password field no matter what.
    if (Drupal.user.uid == account.uid) {
      form.elements.current_pass = {
        'title': 'Current password',
        'type': 'password',
        'description': 'Enter your current password to change the E-mail ' +
          'address or Password.'
      };
    }
    form.elements.pass_pass1 = {
      'title': 'Password',
      'type': 'password'
    };
    form.elements.pass_pass2 = {
      'title': 'Confirm password',
      'type': 'password',
      'description': 'To change the current user password, enter the new ' +
        'password in both fields.'
    };

    // Add submit to form.
    form.elements.submit = {
      'type': 'submit',
      'value': 'Save'
    };

    // Add cancel button to form.
    form.buttons['cancel'] = {
      'title': 'Cancel',
      attributes: {
        onclick: 'javascript:drupalgap_back();'
      }
    };

    return form;
  }
  catch (error) { console.log('user_profile_form - ' + error); }
}

/**
 * The user profile form submit handler.
 * @param {Object} form
 * @param {Object} form_state
 */
function user_profile_form_submit(form, form_state) {
  try {
    var account = drupalgap_entity_build_from_form_state(form, form_state);
    drupalgap_entity_form_submit(form, form_state, account);
  }
  catch (error) { console.log('user_profile_form_submit - ' + error); }
}

/**
 * Implements hook_services_postprocess().
 * @param {Object} options
 * @param {Object} result
 */
function user_services_postprocess(options, result) {
  try {
    // Don't process any other services.
    if (options.service != 'user') { return; }
    // Only process login, logout and registration.
    if (!in_array(options.resource, ['login', 'logout', 'register'])) {
      return;
    }
    // If there were any form errors, alert them to the user.
    if (!result.responseText) { return; }
    var response = JSON.parse(result.responseText);
    if ($.isArray(response)) {
      var msg = '';
      $.each(response, function(index, message) {
          msg += message + '\n';
      });
      if (msg != '') { drupalgap_alert(msg); }
    }
  }
  catch (error) { console.log('user_services_postprocess - ' + error); }
}

/**
 * Implements hook_theme().
 * @return {Object}
 */
function user_theme() {
  try {
    return {
      'user_picture': {
        'template': 'user-picture'
      },
      'user_profile': {
        'template': 'user-profile'
      }
    };
  }
  catch (error) { console.log('user_theme - ' + error); }
}

/**
 * Page callback for user/%.
 * @param {Number} uid
 * @return {Object}
 */
function user_view(uid) {
  try {
    if (uid) {
      var content = {
        container: _drupalgap_entity_page_container('user', uid, 'view')
      };
      return content;
    }
    else { console.log('user_view - No user id provided!'); }
  }
  catch (error) { console.log('user_view - ' + error); }
}

/**
 * jQM pageshow handler for node/% pages.
 * @param {Number} uid
 */
function user_view_pageshow(uid) {
  try {
    user_load(uid, {
        success: function(account) {
          // Determine the incoming arguments, and set defaults if necessary.
          var view_mode = 'full';
          var langcode = null;
          if (arguments[1]) { view_mode = arguments[1]; }
          if (arguments[2]) { langcode = arguments[2]; }
          if (!langcode) { langcode = language_default(); }
          if (account) {
            var build = {
              'theme': 'user_profile',
              'account': account,
              'view_mode': view_mode,
              'language': langcode,
              'name': {'markup': account.name},
              'created': {
                markup:
                  (new Date(parseInt(account.created) * 1000)).toDateString()
              }
            };
            // Any content?
            if (typeof account.content !== 'undefined') {
              build.content = { markup: account.content };
            }
            // Any picture?
            if (account.picture && account.picture.fid) {
              build.picture = {
                'theme': 'image',
                'path': account.picture.url
              };
            }
            _drupalgap_entity_page_container_inject(
              'user', account.uid, 'view', build
            );
          }
        }
    });
  }
  catch (error) { console.log('user_view_pageshow - ' + error); }
}

/**
 * Given a user role (string), this determines if the current user has the role.
 * Returns true if the user has the role, false otherwise. You may pass in a
 * user account object to check against a certain account, instead of the
 * current user.
 * @param {String} role
 * @return {Boolean}
 */
function drupalgap_user_has_role(role) {
  try {
    var has_role = false;
    var account = null;
    if (arguments[1]) { account = arguments[1]; }
    else { account = Drupal.user; }
    $.each(account.roles, function(rid, value) {
        if (role == value) {
          has_role = true;
          return false;
        }
    });
    return has_role;
  }
  catch (error) { console.log('drupalgap_user_has_role - ' + error); }
}

/**
 * Extracts the taxonomy vocabularies JSON objects bundled by the Drupal module
 * into the system connect's resource results.
 * @param {Object} taxonomy_vocabularies
 * @return {Object}
 */
function drupalgap_taxonomy_vocabularies_extract(taxonomy_vocabularies) {
  try {
    var results = false;
    if (taxonomy_vocabularies && taxonomy_vocabularies.length > 0) {
      results = {};
      $.each(taxonomy_vocabularies, function(index, vocabulary) {
          eval('results.' + vocabulary.machine_name + ' = vocabulary;');
      });
    }
    return results;
  }
  catch (error) {
    console.log('drupalgap_taxonomy_vocabularies_extract - ' + error);
  }
}

/**
 * Implements hook_field_formatter_view().
 * @param {String} entity_type
 * @param {Object} entity
 * @param {Object} field
 * @param {Object} instance
 * @param {String} langcode
 * @param {Object} items
 * @param {*} display
 * @return {Object}
 */
function taxonomy_field_formatter_view(entity_type, entity, field, instance,
  langcode, items, display) {
  try {
    var element = {};
    // If items is a string, convert it into a single item JSON object.
    if (typeof items === 'string') { items = {0: {tid: items}}; }
    // It's possible the term items are wrapped in a language code, if they are,
    // pull them out.
    if (typeof items[language_default()] !== 'undefined') {
      items = items[language_default()];
    }
    if (!empty(items)) {
      $.each(items, function(delta, item) {
          var text = item.tid;
          if (item.name) { text = item.name; }
          element[delta] = {
            theme: 'button_link',
            text: text,
            path: 'taxonomy/term/' + item.tid
          };
      });
    }
    return element;
  }
  catch (error) { console.log('taxonomy_field_formatter_view - ' + error); }
}

/**
 * Implements hook_field_widget_form().
 * @param {Object} form
 * @param {Object} form_state
 * @param {Object} field
 * @param {Object} instance
 * @param {String} langcode
 * @param {Object} items
 * @param {Number} delta
 * @param {Object} element
 */
function taxonomy_field_widget_form(form, form_state, field, instance, langcode,
  items, delta, element) {
  try {
    items[delta].type = 'hidden';
    // Build the widget and attach it to the item.
    var list_id = items[delta].id + '-list';
    var widget = {
      theme: 'item_list',
      items: [],
      attributes: {
        'id': list_id,
        'data-role': 'listview',
        'data-filter': 'true',
        'data-inset': 'true',
        'data-filter-placeholder': '...'
      }
    };
    items[delta].children.push(widget);
    // Attach JS to handle the widget's data fetching.
    var machine_name = field.settings.allowed_values[0].vocabulary;
    var vocabulary = taxonomy_vocabulary_machine_name_load(machine_name);
    var vid = vocabulary.vid;
    var js = '<script type="text/javascript">' +
      '$("#' + list_id + '").on("filterablebeforefilter",' +
        'function(e, d) {' +
          '_taxonomy_field_widget_form_autocomplete(' +
            '"' + items[delta].id + '", ' + vid + ', this, e, d' +
          ');' +
        '}' +
      ');' +
    '</script>';
    items[delta].children.push({
        markup: js
    });
  }
  catch (error) { console.log('taxonomy_field_widget_form - ' + error); }
}

var _taxonomy_field_widget_form_autocomplete_input = null;

/**
 * Handles the remote data fetching for taxonomy term reference autocomplete
 * tagging widget.
 * @param {String} id The id of the hidden input that will hold the term id.
 * @param {Number} vid
 * @param {Object} list The unordered list that displays the terms.
 * @param {Object} e
 * @param {Object} data
 */
function _taxonomy_field_widget_form_autocomplete(id, vid, list, e, data) {
  try {
    // Setup the vars to handle this widget.
    var $ul = $(list),
        $input = $(data.input),
        value = $input.val(),
        html = '';
    // Save a reference to this text input field. Then attach an on change
    // handler that will set the hidden input's value when the text field
    // changes. Keep in mind, later on we listen for clicks on autocomplete
    // results to populate this same hidden input's field.
    _taxonomy_field_widget_form_autocomplete_input = $input;
    $(_taxonomy_field_widget_form_autocomplete_input).on('change', function() {
        $('#' + id).val($(this).val());
    });
    // Clear the list, then set up its input handlers.
    $ul.html('');
    if (value && value.length > 0) {
        $ul.html('<li><div class="ui-loader">' +
          '<span class="ui-icon ui-icon-loading"></span>' +
          '</div></li>');
        $ul.listview('refresh');
        var path =
          'drupalgap/taxonomy-term-autocomplete/' + vid + '&name=' +
          encodeURIComponent(value);
        views_datasource_get_view_result(path, {
            success: function(results) {
              if (results.terms.length == 0) { return; }
              $.each(results.terms, function(index, object) {
                  var attributes = {
                    tid: object.term.tid,
                    vid: vid,
                    name: object.term.name,
                    onclick: '_taxonomy_field_widget_form_click(' +
                      "'" + id + "', " +
                      "'" + $ul.attr('id') + "', " +
                      'this' +
                    ')'
                  };
                  html += '<li ' + drupalgap_attributes(attributes) + '>' +
                    object.term.name +
                  '</li>';
              });
              $ul.html(html);
              $ul.listview('refresh');
              $ul.trigger('updatelayout');
            }
        });
    }
  }
  catch (error) {
    console.log('_taxonomy_field_widget_form_autocomplete - ' + error);
  }
}

/**
 * Handles clicks on taxonomy term reference autocomplete widgets.
 * @param {String} id The id of the hidden input that will hold the term name.
 * @param {String} list_id The id of the list that holds the terms.
 * @param {Object} item The list item that was just clicked.
 */
function _taxonomy_field_widget_form_click(id, list_id, item) {
  try {
    var tid = $(item).attr('name');
    $('#' + id).val(tid);
    $(_taxonomy_field_widget_form_autocomplete_input).val($(item).attr('name'));
    $('#' + list_id).html('');
  }
  catch (error) { console.log('_taxonomy_field_widget_form_click - ' + error); }
}

/**
 * Implements hook_assemble_form_state_into_field().
 * @param {Object} entity_type
 * @param {String} bundle
 * @param {String} form_state_value
 * @param {Object} field
 * @param {Object} instance
 * @param {String} langcode
 * @param {Number} delta
 * @param {Object} field_key
 * @return {Object}
 */
function taxonomy_assemble_form_state_into_field(entity_type, bundle,
  form_state_value, field, instance, langcode, delta, field_key) {
  try {
    var result = null;
    switch (instance.widget.type) {
      case 'taxonomy_autocomplete':
        field_key.use_wrapper = false;
        result = form_state_value;
        break;
      case 'options_select':
        result = form_state_value;
        break;
    }
    return result;
  }
  catch (error) {
    console.log('taxonomy_assemble_form_state_into_field - ' + error);
  }
}

/**
 * Implements hook_menu().
 * @return {Object}
 */
function taxonomy_menu() {
  try {
    var items = {
      'taxonomy/vocabularies': {
        'title': 'Taxonomy',
        'page_callback': 'taxonomy_vocabularies_page',
        'pageshow': 'taxonomy_vocabularies_pageshow'
      },
      'taxonomy/vocabulary/%': {
        'title': 'Taxonomy vocabulary',
        'page_callback': 'taxonomy_vocabulary_page',
        'page_arguments': [2],
        'pageshow': 'taxonomy_vocabulary_pageshow'
      },
      'taxonomy/vocabulary/%/view': {
        'title': 'View',
        'type': 'MENU_DEFAULT_LOCAL_TASK',
        'weight': -10
      },
      'taxonomy/vocabulary/%/edit': {
        'title': 'Edit',
        'page_callback': 'entity_page_edit',
        'pageshow': 'entity_page_edit_pageshow',
        'page_arguments': [
          'taxonomy_form_vocabulary',
          'taxonomy_vocabulary',
          2
        ],
        'weight': 0,
        'type': 'MENU_LOCAL_TASK',
        'access_arguments': ['administer taxonomy'],
        options: {reloadPage: true}
      },
      'taxonomy/term/%': {
        'title': 'Taxonomy term',
        'page_callback': 'taxonomy_term_page',
        'page_arguments': [2],
        'pageshow': 'taxonomy_term_pageshow'
      },
      'taxonomy/term/%/view': {
        'title': 'View',
        'type': 'MENU_DEFAULT_LOCAL_TASK',
        'weight': -10
      },
      'taxonomy/term/%/edit': {
        'title': 'Edit',
        'page_callback': 'entity_page_edit',
        'pageshow': 'entity_page_edit_pageshow',
        'page_arguments': ['taxonomy_form_term', 'taxonomy_term', 2],
        'weight': 0,
        'type': 'MENU_LOCAL_TASK',
        'access_arguments': ['administer taxonomy'],
        options: {reloadPage: true}
      }
    };
    return items;
  }
  catch (error) { console.log('taxonomy_menu - ' + error); }
}

/**
 * The taxonomy vocabulary form.
 * @param {Object} form
 * @param {Object} form_state
 * @param {Object} vocabulary
 * @return {Object}
 */
function taxonomy_form_vocabulary(form, form_state, vocabulary) {
  try {

    // Setup form defaults.
    form.entity_type = 'taxonomy_vocabulary';
    form.bundle = null;
    form.action = 'taxonomy/vocabularies';

    // Add the entity's core fields to the form.
    drupalgap_entity_add_core_fields_to_form(
      'taxonomy_vocabulary',
      null,
      form,
      vocabulary
    );

    // Add submit to form.
    form.elements.submit = {
      'type': 'submit',
      'value': 'Save'
    };

    // Add cancel button to form.
    form.buttons['cancel'] = drupalgap_form_cancel_button();

    // If we're editing a vocabulary add a delete button, if the user has
    // access.
    if (vocabulary && vocabulary.vid && user_access('administer taxonomy')) {
      form.buttons['delete'] = drupalgap_entity_edit_form_delete_button(
        'taxonomy_vocabulary',
        vocabulary.vid
      );
    }

    return form;
  }
  catch (error) { console.log('taxonomy_form_vocabulary - ' + error); }
}

/**
 * The taxonomy vocabulary form submit handler.
 * @param {Object} form
 * @param {Object} form_state
 */
function taxonomy_form_vocabulary_submit(form, form_state) {
  try {
    var vocabulary = drupalgap_entity_build_from_form_state(form, form_state);
    drupalgap_entity_form_submit(form, form_state, vocabulary);
  }
  catch (error) { console.log('taxonomy_form_vocabulary_submit - ' + error); }
}

/**
 * The taxonomy term form.
 * @param {Object} form
 * @param {Object} form_state
 * @param {Object} term
 * @return {Object}
 */
function taxonomy_form_term(form, form_state, term) {
  try {
    // Setup form defaults.
    form.entity_type = 'taxonomy_term';
    form.bundle = null;
    form.action = 'taxonomy/vocabularies';

    // Add the entity's core fields to the form.
    drupalgap_entity_add_core_fields_to_form('taxonomy_term', null, form, term);

    // Add submit to form.
    form.elements.submit = {
      'type': 'submit',
      'value': 'Save'
    };

    // Add cancel button to form.
    form.buttons['cancel'] = drupalgap_form_cancel_button();

    // If we are editing a term, add a delete button.
    if (term && term.tid && user_access('administer taxonomy')) {
      form.buttons['delete'] = drupalgap_entity_edit_form_delete_button(
        'taxonomy_term',
        term.tid
      );
    }

    return form;
  }
  catch (error) { console.log('taxonomy_form_term - ' + error); }
}

/**
 * The taxonomy term form submit handler.
 * @param {Object} form
 * @param {Object} form_state
 */
function taxonomy_form_term_submit(form, form_state) {
  try {
    var term = drupalgap_entity_build_from_form_state(form, form_state);
    drupalgap_entity_form_submit(form, form_state, term);
  }
  catch (error) { console.log('taxonomy_form_term_submit - ' + error); }
}

/**
 * Page callback for taxonomy/term/%.
 * @param {Number} tid
 * @return {Object}
 */
function taxonomy_term_page(tid) {
  try {
    if (tid) {
      var content = {
        container: _drupalgap_entity_page_container(
          'taxonomy_term',
          tid,
          'view'
        ),
        taxonomy_term_node_listing: {
          theme: 'jqm_item_list',
          items: [],
          attributes: {
            id: 'taxonomy_term_node_listing_items_' + tid
          }
        }
      };
      return content;
    }
    else { console.log('taxonomy_term_pageshow - No term id provided!'); }
  }
  catch (error) { console.log('taxonomy_term_pageshow - ' + error); }
}

/**
 * jQM pageshow callback for taxonomy/term/%
 * @param {Number} tid
 */
function taxonomy_term_pageshow(tid) {
  try {
    taxonomy_term_load(tid, {
        success: function(term) {
          var description = term.description ? term.description : '';
          var content = {
            'name': {
              'markup': '<h2>' + term.name + '</h2>'
            },
            'description': {
              'markup': '<p>' + description + '</p>'
            }
          };
          _drupalgap_entity_page_container_inject(
            'taxonomy_term',
            term.tid,
            'view',
            content
          );
          taxonomy_term_selectNodes(term.tid, {
              success: function(results) {
                // Extract the nodes into items, then drop them in the list.
                var items = [];
                $.each(results, function(index, node) {
                    items.push(l(node.title, 'node/' + node.nid));
                });
                drupalgap_item_list_populate(
                  '#taxonomy_term_node_listing_items_' + term.tid,
                  items
                );
              }
          });
        }
    });
  }
  catch (error) { console.log('taxonomy_term_pageshow - ' + error); }
}

/**
 * The selectNodes resource from the Taxonomy Term service.
 * @param {Number} tid The taxonomy term id.
 * @param {Object} options
 */
function taxonomy_term_selectNodes(tid, options) {
  try {
    // @TODO - move this function to jDrupal.
    options.method = 'POST';
    options.path = 'taxonomy_term/selectNodes.json';
    options.service = 'taxonomy_term';
    options.resource = 'selectNodes';
    options.data = JSON.stringify({ tid: tid});
    Drupal.services.call(options);
  }
  catch (error) { console.log('taxonomy_term_selectNodes - ' + error); }
}

/**
 * Page call back for taxonomy/vocabularies.
 * @return {Object}
 * @return {Object}
 */
function taxonomy_vocabularies_page() {
  try {
    // Place an empty item list that will hold a list of users.
    var content = {
      'vocabulary_listing': {
        'theme': 'jqm_item_list',
        'title': 'Vocabularies',
        'items': [],
        'attributes': {'id': 'vocabulary_listing_items'}
      }
    };
    return content;
  }
  catch (error) { console.log('taxonomy_vocabularies_page - ' + error); }
}

/**
 * jQM pageshow call back for taxonomy/vocabularies.
 */
function taxonomy_vocabularies_pageshow() {
  try {
    taxonomy_vocabulary_index(null, {
        success: function(vocabularies) {
          // Extract the vocabs into items, then drop them in the list.
          var items = [];
          $.each(vocabularies, function(index, vocabulary) {
              items.push(
                l(vocabulary.name, 'taxonomy/vocabulary/' + vocabulary.vid)
              );
          });
          drupalgap_item_list_populate('#vocabulary_listing_items', items);
        }
    });
  }
  catch (error) { console.log('taxonomy_vocabularies_pageshow - ' + error); }
}

/**
 * Page callback for taxonomy/vocabulary/%
 * @param {Number} vid
 * @return {String|Object}
 */
function taxonomy_vocabulary_page(vid) {
  try {
    if (vid) {
      var content = {
        container: _drupalgap_entity_page_container(
          'taxonomy_vocabulary',
          vid,
          'view'
        ),
        taxonomy_term_listing: {
          theme: 'jqm_item_list',
          title: 'Terms',
          items: [],
          attributes: {
            id: 'taxonomy_term_listing_items_' + vid
          }
        }
      };
      return content;
    }
    else {
      console.log('taxonomy_vocabulary_page - No vocabulary id provided!');
    }
  }
  catch (error) { console.log('taxonomy_vocabulary_page - ' + error); }
}

/**
 * jQM pageshow callback for taxonomy/vocabulary/%.
 * @param {Number} vid
 */
function taxonomy_vocabulary_pageshow(vid) {
  try {
    taxonomy_vocabulary_load(vid, {
        success: function(vocabulary) {
          var content = {
            'name': {
              'markup': '<h2>' + vocabulary.name + '</h2>'
            },
            'description': {
              'markup': '<p>' + vocabulary.description + '</p>'
            }
          };
          _drupalgap_entity_page_container_inject(
            'taxonomy_vocabulary',
            vocabulary.vid,
            'view',
            content
          );
          var query = {
            parameters: {
              vid: vid
            }
          };
          taxonomy_term_index(query, {
              success: function(terms) {
                if (terms.length != 0) {
                  // Extract the terms into items, then drop them in the list.
                  var items = [];
                  $.each(terms, function(index, term) {
                      items.push(l(term.name, 'taxonomy/term/' + term.tid));
                  });
                  drupalgap_item_list_populate(
                    '#taxonomy_term_listing_items_' + vid,
                    items
                  );
                }
              }
          });
        }
    });
  }
  catch (error) { console.log('taxonomy_vocabulary_pageshow - ' + error); }
}

/**
 * Given a vocabulary machine name this will return the JSON
 * object for the vocabulary that is attached to the
 * drupalgap.taxonomy_vocabularies object, or false if it doesn't exist.
 * @param {String} name
 * @return {Object|Boolean}
 */
function taxonomy_vocabulary_machine_name_load(name) {
  try {
    if (drupalgap.taxonomy_vocabularies &&
      drupalgap.taxonomy_vocabularies[name]) {
      return drupalgap.taxonomy_vocabularies[name];
    }
    return false;
  }
  catch (error) {
    console.log('taxonomy_vocabulary_machine_name_load - ' + error);
  }
}

/**
 * Theme's the html for a taxonomy term reference field.
 * @param {Object} variables
 * @return {String}
 */
function theme_taxonomy_term_reference(variables) {
  try {
    var html = '';

    // Make this a hidden field since the widget will just populate a value.
    variables.attributes.type = 'hidden';
    html += '<input ' + drupalgap_attributes(variables.attributes) + '/>';

    // What vocabulary are we using?
    var machine_name =
      variables.field_info_field.settings.allowed_values[0].vocabulary;
    var taxonomy_vocabulary = taxonomy_vocabulary_machine_name_load(
      machine_name
    );

    // Prepare the variables for the widget and render it based on its type.
    var widget_type = variables.field_info_instance.widget.type;
    if (widget_type == 'options_select') { widget_type = 'select'; }
    var widget_function = 'theme_' + widget_type;
    var widget_id = variables.attributes.id + '-' + widget_type;
    if (drupalgap_function_exists(widget_function)) {
      var fn = window[widget_function];
      html += fn.call(null, {
        attributes: {
          id: widget_id,
          onchange: "_theme_taxonomy_term_reference_onchange(this, '" +
            variables.attributes.id + "');"
        }
      });
      // Attach a pageshow handler to the current page that will load the terms
      // into the widget.
       var options = {
         'page_id': drupalgap_get_page_id(drupalgap_path_get()),
         'jqm_page_event': 'pageshow',
         'jqm_page_event_callback': '_theme_taxonomy_term_reference_load_items',
         'jqm_page_event_args': JSON.stringify({
             'taxonomy_vocabulary': taxonomy_vocabulary,
             'widget_id': widget_id
         })
       };
       html += drupalgap_jqm_page_event_script_code(options);
    }
    else {
      console.log(
        'WARNING: theme_taxonomy_term_reference() - ' +
        'unsupported widget type! (' + widget_type + ')'
      );
    }
    return html;
  }
  catch (error) {
    console.log('theme_taxonomy_term_reference - ' + error);
  }
}

/**
 * An internal function used to load the taxonomy terms from a term reference
 * field and populate them into select list identified by options.widget_id.
 * @param {Object} options
 */
function _theme_taxonomy_term_reference_load_items(options) {
  try {
    var query = {
      parameters: {
        vid: options.taxonomy_vocabulary.vid
      }
    };
    taxonomy_term_index(query, {
        success: function(terms) {
          if (terms.length == 0) { return; }
          $.each(terms, function(index, term) {
              var option = '<option value="' + term.tid + '">' +
                term.name +
              '</option>';
              $('#' + options.widget_id).append(option);
          });
        }
    });
  }
  catch (error) {
    console.log('_theme_taxonomy_term_reference_load_items - ' + error);
  }
}

/**
 * An internal function used by a taxonomy term reference field widget to
 * detect changes on it and populate the hidden field that holds the tid in the
 * form.
 * @param {Object} input
 * @param {String} id
 */
function _theme_taxonomy_term_reference_onchange(input, id) {
  try {
    $('#' + id).val($(input).val());
  }
  catch (error) {
    console.log('_theme_taxonomy_term_reference_onchange - ' + error);
  }
}

/**
 * Given a path to a Views Datasource (Views JSON) view, this will get the
 * results and pass them along to the provided success callback.
 * @param {String} path
 * @param {Object} options
 */
function views_datasource_get_view_result(path, options) {
  try {
    // Since we do not use clean URLs, replace any potential question marks from
    // the path with an ampersand so the path will not be invalid.
    if (path.indexOf('?') != -1) {
      var replacement = path.replace('?', '&');
      path = replacement;
    }
    // If local storage caching is enabled, let's see if we can load the results
    // from there. If we successfully loaded the result, make sure it didn't
    // expire. If it did expire, remove it from local storage. If we don't have
    // it in local storage, or local storage caching is disabled, call Drupal to
    // get the results. After the results are fetched, save them to local
    // storage with an expiration time, if necessary. We use the path of the
    // view as the local storage key.
    // If we are resetting, remove the item from localStorage.
    if (options.reset) { window.localStorage.removeItem(path); }
    else if (Drupal.settings.cache.views.enabled) {
      var result = window.localStorage.getItem(path);
      if (result) {
        // Loaded from local storage, did it expire?
        result = JSON.parse(result);
        if (typeof result.expiration !== 'undefined' &&
          result.expiration != 0 &&
          time() > result.expiration
        ) {
          // Expired, remove from local storage.
          window.localStorage.removeItem(path);
        }
        else if (options.success) {
          // Did not expire yet, use it.
          options.success(result);
          return;
        }
      }
    }
    Drupal.services.call({
        endpoint: '',
        service: 'views_datasource',
        resource: '',
        method: 'GET',
        path: path,
        success: function(result) {
          try {
            if (options.success) {
              // Add the path to the result.
              result.path = path;
              // If any views caching is enabled, cache the results in local
              // storage.
              if (Drupal.settings.cache.views.enabled) {
                var expiration =
                  time() + Drupal.settings.cache.views.expiration;
                if (Drupal.settings.cache.views.expiration == 0) {
                  expiration = 0;
                }
                // Saving to local storage.
                result.expiration = expiration;
                window.localStorage.setItem(path, JSON.stringify(result));
              }
              options.success(result);
            }
          }
          catch (error) {
            console.log(
              'views_datasource_get_view_result - success - ' + error
            );
          }
        },
        error: function(xhr, status, message) {
          try {
            if (options.error) { options.error(xhr, status, message); }
          }
          catch (error) {
            console.log('views_datasource_get_view_result - error - ' + error);
          }
        }
    });
  }
  catch (error) { console.log('views_datasource_get_view_result - ' + error); }
}

/**
 * Themes a view.
 * @param {Object} variables
 * @return {String}
 */
function theme_view(variables) {
  try {
    // Throw a warning if no id is provided.
    if (!variables.attributes.id) {
      console.log(
        'WARNING: theme_view() - No id specified on attributes! ' +
        'A random id will be generated instead.'
      );
      variables.attributes.id = 'views-view--' + user_password();
    }
    // Since we'll by making an asynchronous call to load the view, we'll just
    // return an empty div container, with a script snippet to load the view.
    var html = '<div id="' + variables.attributes.id + '" class="view"></div>';
    var options = {
      page_id: drupalgap_get_page_id(),
      jqm_page_event: 'pageshow',
      jqm_page_event_callback: '_theme_view',
      jqm_page_event_args: JSON.stringify(variables)
    };
    html += drupalgap_jqm_page_event_script_code(options);
    return html;
  }
  catch (error) { console.log('theme_view - ' + error); }
}

/**
 * An internal function used to theme a view.
 * @param {Object} variables
 */
function _theme_view(variables) {
  try {
    // Determine what page of the view we're on.
    var page = 0;
    if (variables.page) { page = variables.page; }
    // Make a copy of variables and prepare the success callback for embedding
    // the view.
    var variables_copy = $.extend(
      {},
      {
        success: function(html) {
          try {
            $('#' + variables.attributes.id).html(html);
          }
          catch (error) {
            console.log('_theme_view - success - ' + error);
          }
        }
      },
      variables
    );
    // Finally, embed the view.
    views_embed_view(variables.path + '&page=' + page, variables_copy);
  }
  catch (error) { console.log('_theme_view - ' + error); }
}

// A global variable used to hold the current views' results during a views
// embed view call.
var _views_embed_view_results = null;

/**
 * Returns the html string to options.success, used to embed a view.
 * @param {String} path
 * @param {Object} options
 */
function views_embed_view(path, options) {
  try {
    views_datasource_get_view_result(path, {
        success: function(results) {
          try {
            _views_embed_view_results = results;
            if (!options.success) { return; }
            options.results = results;
            var html = theme('views_view', options);
            options.success(html);
          }
          catch (error) {
            console.log('views_embed_view - success - ' + error);
          }
        },
        error: function(xhr, status, message) {
          try {
            _views_embed_view_results = null;
            if (options.error) { options.error(xhr, status, message); }
          }
          catch (error) {
            console.log('views_embed_view - error - ' + error);
          }
        }
    });
  }
  catch (error) { console.log('views_embed_view - ' + error); }
}

/**
 * Theme's a view.
 * @param {Object} variables
 * @return {String}
 */
function theme_views_view(variables) {
  try {
    // If an id hasn't been provided, generate a random one. We need an id for
    // the div container.
    var id = null;
    if (variables.attributes.id) { id = variables.attributes.id; }
    else { id = 'views-view--' + user_password(); }
    // Open the container.
    var html = '<div id="' + id + '">';
    // Extract the results.
    var results = _views_embed_view_results;
    if (!results) { return html; }
    // Extract the root and child object name.
    var root = results.view.root;
    var child = results.view.child;
    // Is there a title to display?
    if (variables.title) {
      var title_attributes = variables.title_attributes ?
        drupalgap_attributes(variables.title_attributes) : '';
      html +=
        '<div ' + title_attributes + '><h2>' + variables.title + '</h2></div>' +
        theme('views_spacer', null);
    }
    // Are the results empty? If so, return the empty callback's html, if it
    // exists. Often times, the empty callback will want to place html that
    // needs to be enhanced by jQM, therefore we'll set a timeout to trigger
    // the creation of the content area.
    if (results.view.count == 0 && variables.empty_callback &&
      function_exists(variables.empty_callback)
    ) {
      var empty_callback = window[variables.empty_callback];
      var selector = '#' + drupalgap_get_page_id() + ' #' + id;
      $(selector).hide();
      setTimeout(function() {
          $(selector).trigger('create').show('fast');
      }, 100);
      return empty_callback(results.view);
    }
    // Depending on the format, let's render the container opening and closing,
    // and then render the rows.
    if (!variables.format) { variables.format = 'unformatted_list'; }
    var open = '';
    var close = '';
    var open_row = '';
    var close_row = '';
    switch (variables.format) {
      case 'ul':
        open = '<ul data-role="listview">';
        close = '</ul>';
        open_row = '<li>';
        close_row = '</li>';
        break;
      case 'ol':
        open = '<ol data-role="listview">';
        close = '</ol>';
        open_row = '<li>';
        close_row = '</li>';
        break;
      case 'table':
        open = '<table>';
        close = '</table>';
        open_row = '<tr>';
        close_row = '</tr>';
        break;
      case 'unformatted_list':
      default:
        open = '<div class="views-rows">';
        close = '</div>';
        open_row = '<div>';
        close_row = '</div>';
        break;
    }
    var rows = '' + open;
    $.each(results[root], function(count, object) {
        // Extract the row.
        var row = object[child];
        // Mark the row count.
        row.count = count;
        // If a row_callback function exists, call it to render the row,
        // otherwise use the default row render mechanism.
        var row_content = '';
        if (variables.row_callback && function_exists(variables.row_callback)) {
          row_callback = window[variables.row_callback];
          row_content = row_callback(results.view, row);
        }
        else { row_content = JSON.stringify(row); }
        rows += open_row + row_content + close_row;
    });
    rows += close;
    // If we have any pages, render the pager above or below the results
    // according to the pager_pos setting.
    var pager = '';
    if (results.view.pages) { pager = theme('pager', variables); }
    var pager_pos = 'top';
    if (typeof variables.pager_pos !== 'undefined') {
      pager_pos = variables.pager_pos;
    }
    // Append the rendered rows and the pager to the html string according to
    // the pager position.
    if (pager_pos == 'top') {
      html += pager + theme('views_spacer', null) + rows;
    }
    else if (pager_pos == 'bottom') {
      html += rows + theme('views_spacer', null) + pager;
    }
    else {
      console.log('WARNING: theme_views_view - unsupported pager_pos (' +
        pager_pos +
      ')');
    }
    // Since the views content is injected dynamically after the page is loaded,
    // we need to have jQM refresh the page to add its styling.
    var selector = '#' + drupalgap_get_page_id() + ' #' + id;
    $(selector).hide();
    setTimeout(function() {
        $(selector).trigger('create').show('fast');
    }, 100);
    // Close the container.
    html += '</div>';
    return html;
  }
  catch (error) { console.log('theme_views_view - ' + error); }
}

/**
 * Themes a spacer that can be placed between displayed components of the view.
 * @param {Object} variables
 * @return {String}
 */
function theme_views_spacer(variables) {
  try {
    return '<h2 class="dg_empty_list_header">&nbsp;</h2>';
  }
  catch (error) { console.log('theme_views_spacer - ' + error); }
}

/**
 * Themes a pager.
 * @param {Object} variables
 * @return {String}
 */
function theme_pager(variables) {
  try {
    var html = '';
    // Extract the view and pager data.
    var view = variables.results.view;
    var page = view.page;
    var pages = view.pages;
    var count = view.count;
    var limit = view.limit;
    var page = view.page;
    // If we don't have any results, return.
    if (count == 0) { return html; }
    // Add the pager items to the list.
    var items = [];
    if (page != 0) { items.push(theme('pager_previous', variables)); }
    if (page != pages - 1) { items.push(theme('pager_next', variables)); }
    if (items.length > 0) {
      // Make sure we have an id to use since we need to dynamically build the
      // navbar container for the pager. If we don't have one, generate a random
      // one.
      var id = 'theme_pager_' + user_password();
      html += '<div id="' + id + '" data-role="navbar">' + theme('item_list', {
          items: items
      }) + '</div>' +
      '<script type="text/javascript">' +
        '$("#' + id + '").navbar();' +
      '</script>';
    }
    return html;
  }
  catch (error) { console.log('theme_pager - ' + error); }
}

/**
 * Themes a pager link.
 * @param {Object} variables
 * @param {Object} link_vars
 * @return {String}
 */
function theme_pager_link(variables, link_vars) {
  try {
    var onclick = _theme_pager_link_onclick(variables);
    return "<a href='#' onclick='" + onclick + "'>" + link_vars.text + '</a>';
  }
  catch (error) { console.log('theme_pager_link - ' + error); }
}

/**
 * An internal function used to generate the onclick handler JS for a pager
 * link.
 * @param {Object} variables
 * @return {String}
 */
function _theme_pager_link_onclick(variables) {
  try {
    // Make a copy of variables. While doing so remove any results from it
    // because we don't want them in the onclick handler's html. The results
    // will be available in the _views_embed_view_results variable if they are
    // needed
    var copy = $.extend({ }, { }, variables);
    if (copy.results) { delete copy.results; }
    var onclick = '_theme_pager_link_click(' + JSON.stringify(copy) + ')';
    return onclick;
  }
  catch (error) { console.log('_theme_pager_link_onclick - ' + error); }
}

/**
 * An internal function used to handle clicks on pager links.
 * @param {Object} variables
 */
function _theme_pager_link_click(variables) {
  try {
    _theme_view(variables);
  }
  catch (error) { console.log('_theme_pager_link_click - ' + error); }
}

/**
 * Themes a pager next link.
 * @param {Object} variables
 * @return {String}
 */
function theme_pager_next(variables) {
  try {
    var html;
    variables.page = variables.results.view.page + 1;
    var link_vars = {
      text: '&raquo;',
      attributes: {
        'class': 'pager_next'
      }
    };
    html = theme_pager_link(variables, link_vars);
    return html;
  }
  catch (error) { console.log('theme_pager_next - ' + error); }
}

/**
 * Themes a pager previous link.
 * @param {Object} variables
 * @return {String}
 */
function theme_pager_previous(variables) {
  try {
    var html;
    variables.page = variables.results.view.page - 1;
    var link_vars = {
      text: '&laquo;',
      attributes: {
        'class': 'pager_previous'
      }
    };
    html = theme_pager_link(variables, link_vars);
    return html;
  }
  catch (error) { console.log('theme_pager_previous - ' + error); }
}

/**
 * @deprecated - Use views_datasource_get_view_result() instead.
 */
drupalgap.views_datasource = {
  'options': { },
  'call': function(options) {
    try {
      var msg = 'WARNING: drupalgap.views_datasource has been deprecated! ' +
      'Use views_datasource_get_view_result() instead.';
      console.log(msg);
      views_datasource_get_view_result(options.path, options);
    }
    catch (error) { console.log('drupalgap.views_datasource - ' + error); }
  }
};

