// Initialize the drupalgap json object.
var drupalgap = drupalgap || drupalgap_init(); // Do not remove this line.

// Setup the jQueryMobile loader to show/hide itself while navigating between
// pages in the app.
/*$(document).on('pagebeforecreate', '[data-role="page"]', function() {
    setTimeout(function() {
        drupalgap.loading = true;
        $.mobile.loading('show', drupalgap_loader_options());
    }, 1);
});
$(document).on('pageshow', '[data-role="page"]', function() {
    setTimeout(function() {
        drupalgap.loading = false;
        $.mobile.loading('hide');
    }, 100);
});*/

/**
 * Initializes the drupalgap json object.
 * @return {Object}
 */
function drupalgap_init() {
  try {
    var dg = {
      modules: {
        core: [
           { name: 'api' },
           { name: 'block' },
           { name: 'comment' },
           { name: 'contact' },
           { name: 'entity' },
           { name: 'field' },
           { name: 'file' },
           { name: 'image' },
           { name: 'menu' },
           { name: 'mvc' },
           { name: 'node' },
           { name: 'search' },
           { name: 'system' },
           { name: 'taxonomy' },
           { name: 'user' },
           { name: 'views' }
         ]
      },
      module_paths: [],
      includes: [
          {name: 'common' },
          {name: 'form' },
          {name: 'menu' },
          {name: 'theme' }
      ],
      online: false,
      destination: '',
      api: {},
      back: false, /* moving backwards or not */
      back_path: '', /* the path to move back to */
      blocks: [],
      content_types_list: {}, /* holds info about each content type */
      entity_info: {},
      field_info_fields: {},
      field_info_instances: {},
      form_errors: {},
      form_states: [],
      loading: false, /* indicates if the loading message is shown or not */
      loader: 'loading', /* used to determine the jQM loader mode */
      messages: [],
      menus: {},
      menu_links: {},
      menu_router: {}, /* @todo - doesn't appear to be used at all, remove it */
      mvc: {
        models: {},
        views: {},
        controllers: {}
      },
      output: '', /* hold output generated by menu_execute_active_handler() */
      page: {
        jqm_events: [],
        title: '',
        variables: {},
        process: true,
        options: {} /* holds the current page's options, eg. reloadPage, etc. */
      },
      pages: [], /* Collection of page ids that are loaded into the DOM. */
      path: '', /* The current menu path. */
      router_path: '', /* The current menu router path. */
      services: {},
      sessid: null,
      settings: {},
      site_settings: {}, /* holds variable settings from the Drupal site */
      taxonomy_vocabularies: false, /* holds vocabs from system connect */
      theme_path: '',
      themes: [],
      theme_registry: {},
      views_datasource: {}
    };
    //if (drupalgap) { dg = $.extend({}, dg, drupalgap); }
    return dg;
  }
  catch (error) { console.log('drupalgap_init - ' + error); }
}

/**
 * This is called once the <body> element's onload is fired.
 */
function drupalgap_onload() {
  try {
    // At this point, the Drupal object has been initialized by jDrupal and has
    // loaded the app/settings.js into the <head>. Let's add DrupalGap's modules
    // onto the Drupal JSON object. Remember, all of the module source code is
    // included via the makefile's bin generation. However, the core modules
    // hook_install() implementations haven't been called yet, so we add them to
    // the module listing so they can be invoked later on.
    var modules = [
      'drupalgap',
      'block',
      'comment',
      'contact',
      'entity',
      'field',
      'file',
      'image',
      'menu',
      'mvc',
      'node',
      'search',
      'system',
      'taxonomy',
      'user',
      'views'
    ];
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      Drupal.modules.core[module] = module_object_template(module);
    }
    // Add PhoneGap's deviceready listener.
    document.addEventListener('deviceready', _drupalgap_deviceready, false);
  }
  catch (error) { console.log('drupalgap_onload - ' + error); }
}

/**
 * Implements PhoneGap's deviceready().
 */
function _drupalgap_deviceready() {
  try {
    // PhoneGap is loaded and it is now safe for DrupalGap to start...
    drupalgap_bootstrap();

    // Verify site path is set.
    if (!Drupal.settings.site_path || Drupal.settings.site_path == '') {
      var msg = 'No site_path to Drupal set in the app/settings.js file!';
      drupalgap_alert(msg, {
          title: 'Error'
      });
      return;
    }

    // Check device connection. If the device is offline, warn the user and then
    // go to the offline page.
    drupalgap_check_connection();
    if (!drupalgap.online) {
      module_invoke_all('device_offline');
      drupalgap_alert('No connection found!', {
          title: 'Offline',
          alertCallback: function() { drupalgap_goto('offline'); }
      });
      return;
    }
    else {

      // Device is online, let's call any implementations of hook_deviceready().
      // If any implementation returns false, that means they don't want
      // DrupalGap to continue with the System Connect call, so we'll skip that
      // and go straight to the App's front page.
      var proceed = true;
      var invocation_results = module_invoke_all('deviceready');
      if (invocation_results && invocation_results.length > 0) {
        for (var i = 0; i < invocation_results; i++) {
          if (!invocation_results[i]) {
            proceed = false;
            break;
          }
        }
      }
      if (!proceed) {
        drupalgap_goto('');
        // @todo - if module's are going to skip the System Connect call, then
        // we need to make sure Drupal.user is set up with appropriate defaults.
      }
      else {
        // Device is online, let's build the default system connect options.
        var options = {
          success: function(result) {
            // Call all hook_device_connected implementations then go to
            // the front page.
            module_invoke_all('device_connected');
            drupalgap_goto('');
          },
          error: function(jqXHR, textStatus, errorThrown) {
            // Build an informative error message and display it.
            var msg = 'Failed connection to ' + drupalgap.settings.site_path;
            if (errorThrown != '') { msg += ' - ' + errorThrown; }
            msg += ' - Check your device\'s connection and check that ' +
                   Drupal.settings.site_path + ' is online.';
           drupalgap_alert(msg, {
               title: 'Unable to Connect',
               alertCallback: function() { drupalgap_goto('offline'); }
           });
          }
        };

        // Make the system connect call.
        system_connect(options);
      }
    }
  }
  catch (error) { console.log('_drupalgap_deviceready - ' + error); }
}

/**
 * Loads up all necessary assets to make DrupalGap ready.
 */
function drupalgap_bootstrap() {
  try {
    // Load up any contrib and/or custom modules (the DG core moodules have
    // already been loaded at this point), load the theme and all blocks. Then
    // build the menu router, load the menus, and build the theme registry.
    drupalgap_load_modules();
    drupalgap_load_theme();
    drupalgap_load_blocks();
    menu_router_build();
    drupalgap_menus_load();
    drupalgap_theme_registry_build();

    // Attach device back button handler (Android).
    document.addEventListener('backbutton', drupalgap_back, false);
  }
  catch (error) { console.log('drupalgap_bootstrap - ' + error); }
}

/**
 * Loads any contrib or custom modules specifed in the settings.js file. Then
 * invoke hook_install() on all modules, including core.
 */
function drupalgap_load_modules() {
  try {
    var module_types = ['contrib', 'custom'];
    // We only need to load contrib and custom modules because core modules are
    // already included in the binary.
    $.each(module_types, function(index, bundle) {
        // Let's be nice and try to load any old drupalgap.modules declarations
        // in developers settings.js files for a while, but throw a warning to
        // encourage them to update. This code can be removed after a few
        // releases to help developers get caught up without angering them.
        if (
          drupalgap.modules &&
          drupalgap.modules[bundle] &&
          drupalgap.modules[bundle].length != 0
        ) {
          $.each(drupalgap.modules[bundle], function(index, module) {
              if (module.name) {
                var msg = 'WARNING: The module "' + module.name + '" defined ' +
                  'in settings.js needs to be added to ' +
                  'Drupal.modules[\'' + bundle + '\'] instead! See ' +
                  'default.settings.js for examples on the new syntax!';
                console.log(msg);
                Drupal.modules[bundle][module.name] = module;
              }
          });
        }
        $.each(Drupal.modules[bundle], function(module_name, module) {
            // If the module object is empty, initialize a module object.
            if ($.isEmptyObject(module)) {
              Drupal.modules[bundle][module_name] =
                module_object_template(module_name);
              module = Drupal.modules[bundle][module_name];
            }
            // If the module's name isn't set, set it.
            if (!module.name) {
              Drupal.modules[bundle][module_name].name = module_name;
              module = Drupal.modules[bundle][module_name];
            }
            // Determine module directory.
            var dir = drupalgap_modules_get_bundle_directory(bundle);
            module_base_path = dir + '/' + module.name;
            // Add module .js file to array of paths to load.
            module_path = module_base_path + '/' + module.name + '.js';
            modules_paths = [module_path];
            // If there are any includes with this module, add them to the
            // list of paths to include.
            if (module.includes != null && module.includes.length != 0) {
              $.each(module.includes, function(include_index, include_object) {
                modules_paths.push(
                  module_base_path + '/' + include_object.name + '.js'
                );
              });
            }
            // Now load all the paths for this module.
            $.each(modules_paths,
              function(modules_paths_index, modules_paths_object) {
                jQuery.ajax({
                    async: false,
                    type: 'GET',
                    url: modules_paths_object,
                    data: null,
                    success: function() {
                        //console.log('Loaded module: ' + modules_paths_object);
                    },
                    dataType: 'script',
                    error: function(xhr, textStatus, errorThrown) {
                      var msg = 'Failed to load module! (' + module.name + ')';
                      drupalgap_alert(msg);
                    }
                });
              }
            );
      });
    });
    // Now invoke hook_install on all modules, including core.
    module_invoke_all('install');
  }
  catch (error) { console.log('drupalgap_load_modules - ' + error); }
}

/**
 * Load the theme specified by drupalgap.settings.theme into drupalgap.theme
 * Returns true on success, false if it fails.
 * @return {Boolean}
 */
function drupalgap_load_theme() {
  try {
    if (!drupalgap.settings.theme) {
      var msg = 'drupalgap_load_theme - no theme specified in settings.js';
      drupalgap_alert(msg);
    }
    else {
      // Pull the theme name from the settings.js file.
      var theme_name = drupalgap.settings.theme;
      // Let's try to load to theme's js file first by looking in the core
      // themes directory, then in the app/themes directory.
      var theme_path = 'themes/' + theme_name + '/' + theme_name + '.js';
      if (!drupalgap_file_exists(theme_path)) {
        theme_path = 'app/themes/' + theme_name + '/' + theme_name + '.js';
        if (!drupalgap_file_exists(theme_path)) {
          var error_msg = 'drupalgap_theme_load - Failed to load theme! ' +
            'The theme\'s JS file does not exist: ' + theme_path;
          drupalgap_alert(error_msg);
          return false;
        }
      }
      // We found the theme's js file, add it to the page.
      drupalgap_add_js(theme_path);
      // Call the theme's template_info implementation.
      var template_info_function = theme_name + '_info';
      if (drupalgap_function_exists(template_info_function)) {
        var fn = window[template_info_function];
        drupalgap.theme = fn();
        // For each region in the name, set the 'name' value on the region JSON.
        $.each(drupalgap.theme.regions, function(name, region) {
            drupalgap.theme.regions[name].name = name;
        });
        // Make sure the theme implements the required regions.
        var regions = system_regions_list();
        for (var i = 0; i < regions.length; i++) {
          var region = regions[i];
          if (typeof drupalgap.theme.regions[region] === 'undefined') {
            console.log('WARNING: drupalgap_load_theme() - The "' +
                        theme_name + '" theme does not have the "' + region +
                        '" region specified in "' + theme_name + '_info()."');
          }
        }
        // Theme loaded successfully! Set the drupalgap.theme_path and return
        // true.
        drupalgap.theme_path = theme_path.replace('/' + theme_name + '.js', '');
        return true;
      }
      else {
        var error_msg = 'drupalgap_load_theme() - failed - ' +
          template_info_function + '() does not exist!';
        drupalgap_alert(error_msg);
      }
    }
    return false;
  }
  catch (error) { console.log('drupalgap_load_theme - ' + error); }
}

/**
 * Given a path to a javascript file relative to the app's www directory,
 * this will load the javascript file so it will be available in scope.
 */
function drupalgap_add_js() {
  try {
    var data;
    if (arguments[0]) { data = arguments[0]; }
    jQuery.ajax({
      async: false,
      type: 'GET',
      url: data,
      data: null,
      success: function() {
        if (drupalgap.settings.debug) {
          // Print the js path to the console.
          console.log(data);
        }
      },
      dataType: 'script',
      error: function(xhr, textStatus, errorThrown) {
        console.log(
          'drupalgap_add_js - error - (' +
            data + ' : ' + textStatus +
          ') ' + errorThrown
        );
      }
    });
  }
  catch (error) {
    console.log('drupalgap_add_js - ' + error);
  }
}

/**
 * Given a path to a css file relative to the app's www directory, this will
 * attempt to load the css file so it will be available in scope.
 */
function drupalgap_add_css() {
  try {
    var data;
    if (arguments[0]) { data = arguments[0]; }
    $('<link/>', {rel: 'stylesheet', href: data}).appendTo('head');
  }
  catch (error) { console.log('drupalgap_add_css - ' + error); }
}

/**
 * Alerts a message to the user using PhoneGap's alert. It is important to
 * understand this is an async function, so code will continue to execute while
 * the alert is displayed to the user.
 * You may optionally pass in a second argument as a JSON object with the
 * following properties:
 *   alertCallback - the function to call after the user presses OK
 *   title - the title to use on the alert box, defaults to 'Alert'
 *   buttonName - the text to place on the button, default to 'OK'
 * @param {String} message
 */
function drupalgap_alert(message) {
  try {
    var options = null;
    if (arguments[1]) { options = arguments[1]; }
    var alertCallback = function() { };
    var title = 'Alert';
    var buttonName = 'OK';
    if (options) {
      if (options.alertCallback) { alertCallback = options.alertCallback; }
      if (options.title) { title = options.title; }
      if (options.buttonName) { buttonName = options.buttonName; }
    }
    navigator.notification.alert(message, alertCallback, title, buttonName);
  }
  catch (error) { console.log('drupalgap_alert - ' + error); }
}

/**
 * Displays a confirmation message to the user using PhoneGap's confirm. It is
 * important to understand this is an async function, so code will continue to
 * execute while the confirmation is displayed to the user.
 * You may optionally pass in a second argument as a JSON object with the
 * following properties:
 *   confirmCallback - the function to call after the user presses a button. The
 *               button label is passed to the function.
 *   title - the title to use on the alert box, defaults to 'Alert'
 *   buttonLabels - the text to place on the OK, and Cancel buttons, separated
 *                  by comma.
 * @param {String} message
 */
function drupalgap_confirm(message) {
  try {
    var options = null;
    if (arguments[1]) { options = arguments[1]; }
    var confirmCallback = function(button) { };
    var title = 'Confirm';
    var buttonLabels = ['OK', 'Cancel'];
    if (options) {
      if (options.confirmCallback) {
        confirmCallback = options.confirmCallback;
      }
      if (options.title) { title = options.title; }
      if (options.buttonLabels) { buttonLabels = options.buttonLabels; }
    }
    navigator.notification.confirm(
        message,
        confirmCallback,
        title,
        buttonLabels
    );
  }
  catch (error) { console.log('drupalgap_confirm - ' + error); }
}

/**
 * Rounds up all blocks defined by hook_block_info and places them in the
 * drupalgap.blocks array.
 */
function drupalgap_load_blocks() {
  try {
    /*drupalgap.blocks[0] = {};
    var modules = module_implements('block_info');
    if (modules) {
      $.each(modules, function(index, module){
          var blocks = module_invoke(module, 'block_info');
          if (blocks) {
            $.each(blocks, function(delta, block){
              // Assign the delta as the name of the block, set the delta of the
              // block as well, and set the module name on the block for
              // reference.
              block.name = delta;
              block.delta = delta;
              block.module = module;
              // Add the block to drupalgap.blocks.
              eval("drupalgap.blocks[0]." + delta + " = block;");
              //drupalgap.blocks[delta] = block;
            });
          }
      });
    }*/
    drupalgap.blocks = module_invoke_all('block_info');
    if (drupalgap.settings.debug) {
      console.log(JSON.stringify(drupalgap.blocks));
    }
  }
  catch (error) { console.log('drupalgap_load_blocks - ' + error); }
}

/**
 * Checks the devices connection and sets drupalgap.online to true if the
 * device has a connection, false otherwise.
 * @return {String}
 *   A string indicating the type of connection according to PhoneGap.
 */
function drupalgap_check_connection() {
  try {
    // We'll assume that Ripple emulation always has a connection, for now.
    // http://stackoverflow.com/q/15950382/763010
    if (typeof parent.window.ripple === 'function') {
      drupalgap.online = true;
      return 'Ethernet connection';
    }

    var networkState = navigator.connection.type;
    var states = {};
    states[Connection.UNKNOWN] = 'Unknown connection';
    states[Connection.ETHERNET] = 'Ethernet connection';
    states[Connection.WIFI] = 'WiFi connection';
    states[Connection.CELL_2G] = 'Cell 2G connection';
    states[Connection.CELL_3G] = 'Cell 3G connection';
    states[Connection.CELL_4G] = 'Cell 4G connection';
    states[Connection.NONE] = 'No network connection';
    if (states[networkState] == 'No network connection') {
      drupalgap.online = false;
    }
    else {
      drupalgap.online = true;
    }
    return states[networkState];
  }
  catch (error) { console.log('drupalgap_check_connection - ' + error); }
}

/**
 * @deprecated Use empty() instead.
 * Returns true if given value is empty. A generic way to test for emptiness.
 * @param {*} value
 * @return {Boolean}
 */
function drupalgap_empty(value) {
  try {
    console.log(
      'WARNING: drupalgap_empty() is deprecated! ' +
      'Use empty() instead.'
    );
    return empty(value);
  }
  catch (error) { console.log('drupalgap_empty - ' + error); }
}

/**
 * Checks if a given file exists, returns true or false.
 * @param  {string} path
 *   A path to a file
 * @return {bool}
 *   True if file exists, else false.
 */
function drupalgap_file_exists(path) {
  try {
    var file_exists = false;
    jQuery.ajax({
      async: false,
      type: 'HEAD',
      url: path,
      success: function() { file_exists = true; },
      error: function(xhr, textStatus, errorThrown) { }
    });
    return file_exists;
  }
  catch (error) { console.log('drupalgap_file_exists - ' + error); }
}

/**
 * Reads entire file into a string and returns the string. Returns false if
 * it fails.
 * @param {String} path
 * @param {Object} options
 * @return {String}
 */
function drupalgap_file_get_contents(path, options) {
  try {
    var file = false;
    var default_options = {
      type: 'GET',
      url: path,
      dataType: 'html',
      data: null,
      async: false,
      success: function(data) { file = data; },
      error: function(xhr, textStatus, errorThrown) {
        console.log(
          'drupalgap_file_get_contents - failed to load file (' + path + ')'
        );
      }
    };
    $.extend(default_options, options);
    jQuery.ajax(default_options);
    return file;
  }
  catch (error) { console.log('drupalgap_file_get_contents - ' + error); }
}


/**
 * @see http://api.drupal.org/api/drupal/includes%21common.inc/function/format_plural/7
 * @param {Number} count
 * @param {String} singular
 * @param {String} plural
 * @return {String}
 */
function drupalgap_format_plural(count, singular, plural) {
  try {
    if (count == 1) { return singular; }
    return plural;
  }
  catch (error) { console.log('drupalgap_format_plural - ' + error); }
}

/**
 * @deprecated - Use function_exists() instead.
 * @param {String} name
 * @return {Boolean}
 */
function drupalgap_function_exists(name) {
  try {
    return function_exists(name);
  }
  catch (error) { console.log('drupalgap_function_exists - ' + error); }
}

/**
 * Given an html string from a *.tpl.html file, this will extract all of the
 * placeholders names and return them in an array. Returns false otherwise.
 * @param {String} html
 * @return {*}
 */
function drupalgap_get_placeholders_from_html(html) {
  try {
    var placeholders = false;
    if (html) {
      placeholders = html.match(/(?!{:)([\w]+)(?=:})/g);
    }
    return placeholders;
  }
  catch (error) {
    console.log('drupalgap_get_placeholders_from_html - ' + error);
  }
}

/**
 * Returns the current page's title.
 * @return {String}
 */
function drupalgap_get_title() {
  try {
    return drupalgap.page.title;
  }
  catch (error) { console.log('drupalgap_get_title - ' + error); }
}

/**
 * Given a router path, this will return an array containing the indexes of
 * where the wildcards (%) are present in the router path. Returns false if
 * there are no wildcards present.
 * @param {String} router_path
 * @return {Boolean}
 */
function drupalgap_get_wildcards_from_router_path(router_path) {
  try {
    // @todo - Is this function even used? Doesn't look like it.
    var wildcards = false;
    return wildcards;
  }
  catch (error) {
    console.log('drupalgap_get_wildcards_from_router_path - ' + error);
  }
}


/**
 * Given a drupal image file uri, this will return the path to the image on the
 * Drupal site.
 * @param {String} uri
 * @return {String}
 */
function drupalgap_image_path(uri) {
  try {
    var altered = false;
    // If any modules want to alter the path, let them do it.
    var modules = module_implements('image_path_alter');
    if (modules) {
      $.each(modules, function(index, module) {
          var result = module_invoke(module, 'image_path_alter', uri);
          if (result) {
            altered = true;
            uri = result;
            return false;
          }
      });
    }
    if (!altered) {
      // No one modified the image path, we'll use the default approach to
      // generating the image src path.
      var src = Drupal.settings.site_path + Drupal.settings.base_path + uri;
      if (src.indexOf('public://') != -1) {
        src = src.replace('public://', Drupal.settings.file_public_path + '/');
      }
      return src;
    }
    else { return uri; }
  }
  catch (error) { console.log('drupalgap_image_path - ' + error); }
}

/**
 * @deprecated - This is no longer needed since the includes are built via the
 * makefile. Loads the js files in includes specified by drupalgap.includes.
 */
function drupalgap_includes_load() {
  try {
    if (drupalgap.includes != null && drupalgap.includes.length != 0) {
      $.each(drupalgap.includes, function(index, include) {
          var include_path = 'includes/' + include.name + '.inc.js';
          jQuery.ajax({
              async: false,
              type: 'GET',
              url: include_path,
              data: null,
              success: function() {
                if (drupalgap.settings.debug) {
                  // Print the include path to the console.
                  console.log(include_path);
                }
              },
              dataType: 'script',
              error: function(xhr, textStatus, errorThrown) {
                console.log(errorThrown);
              }
          });
      });
    }
  }
  catch (error) { console.log('drupalgap_includes_load - ' + error); }
}

/**
 * Given an html list element id and an array of items, this will clear the
 * list, populate it with the items, and then refresh the list.
 * @param {String} list_css_selector
 * @param {Array} items
 */
function drupalgap_item_list_populate(list_css_selector, items) {
  try {
    // @todo - This could use some validation and alerts for improper input.
    $(list_css_selector).html('');
    for (var i = 0; i < items.length; i++) {
      $(list_css_selector).append($('<li></li>', { html: items[i] }));
    }
    $(list_css_selector).listview('refresh').listview();
  }
  catch (error) { console.log('drupalgap_item_list_populate - ' + error); }
}

/**
 * Given an html table element id and an array of rows, this will clear the
 * table, populate it with the rows, and then refresh the table.
 * @param {String} table_css_selector
 * @param {Array} rows
 * rows follow the.
 */
function drupalgap_table_populate(table_css_selector, rows) {
  try {
    // Select only the body. Other things are already setup
    table_css_selector = table_css_selector + '> tbody ';
    $(table_css_selector).html('');
    for (var i = 0; i < rows.length; i++) {
      var row = rows[i];
      var rowhtml = '';
      for (var j = 0; j < row.length; j++) {
          rowhtml = rowhtml + '<td>' + row[j] + '</td>';
      }
      $('<tr>').html(rowhtml).appendTo($(table_css_selector));
    }
    $(table_css_selector).rebuild();
  }
  catch (error) { console.log('drupalgap_table_populate - ' + error); }
}

/**
 * Given a jQM page event, and the corresponding callback function name that
 * handles the event, this function will call the callback function, if it has
 * not already been called on the current page. This really is only used by
 * menu_execute_active_handler() to prevent jQM from firing inline page event
 * handlers more than once.
 * @param {String} event
 * @param {String} callback
 * @param {*} page_arguments
 */
function drupalgap_jqm_page_event_fire(event, callback, page_arguments) {
  try {
    // Concatenate the event name and the callback name together into a unique
    // key so multiple callbacks can handle the same event.
    var key = event + '-' + callback + '-' + JSON.stringify(page_arguments);
    if ($.inArray(key, drupalgap.page.jqm_events) == -1 &&
      drupalgap_function_exists(callback)) {
      drupalgap.page.jqm_events.push(key);
      var fn = window[callback];
      if (page_arguments) {
        // If the page arguments aren't an array, place them into an array so
        // they can be applied to the callback function.
        if (!$.isArray(page_arguments)) { page_arguments = [page_arguments]; }
        fn.apply(null, Array.prototype.slice.call(page_arguments));
      }
      else { fn(); }
    }
  }
  catch (error) { console.log('drupalgap_jqm_page_event_fire - ' + error); }
}

/**
 * Returns array of jQM Page event names.
 * @return {Array}
 * @see http://api.jquerymobile.com/category/events/
 */
function drupalgap_jqm_page_events() {
  try {
    return [
      'pagebeforechange',
      'pagebeforecreate',
      'pagebeforehide',
      'pagebeforeload',
      'pagebeforeshow',
      'pagechange',
      'pagechangefailed',
      'pagecreate',
      'pagehide',
      'pageinit',
      'pageload',
      'pageloadfailed',
      'pageremove',
      'pageshow'
    ];
  }
  catch (error) { console.log('drupalgap_jqm_page_events - ' + error); }
}

/**
 * Given a JSON object with a page id, a jQM page event name, a callback
 * function to handle the jQM page event and any page arguments (as a JSON
 * string), this function will return the inline JS code needed to handle the
 * event.
 * @param {Object} options
 * @return {String}
 */
function drupalgap_jqm_page_event_script_code(options) {
  try {
    var script_code = '<script type="text/javascript">' +
      '$("#' + options.page_id + '").on("' +
        options.jqm_page_event + '", drupalgap_jqm_page_event_fire("' +
          options.jqm_page_event + '", "' +
          options.jqm_page_event_callback + '", ' +
          options.jqm_page_event_args +
        '));' +
    '</script>';
    return script_code;
  }
  catch (error) {
    console.log('drupalgap_jqm_page_event_script_code - ' + error);
  }
}

/**
 * Show the jQueryMobile loading message.
 * @see http://stackoverflow.com/a/16277865/763010
 */
function drupalgap_loading_message_show() {
  try {
    // Backwards compatability for versions prior to 7.x-1.6-alpha
    if (drupalgap.loading === 'undefined') { drupalgap.loading = false; }
    // Return if the loading message is already shown.
    if (drupalgap.loading) { return; }
    var options = drupalgap_loader_options();
    if (arguments[0]) { options = arguments[0]; }
    // Show the loading message.
    //$.mobile.loading('show', options);
    //drupalgap.loading = true;
    setTimeout(function() {
        $.mobile.loading('show', options);
        drupalgap.loading = true;
    }, 1);
  }
  catch (error) { console.log('drupalgap_loading_message_show - ' + error); }
}

/**
 * Hide the jQueryMobile loading message.
 */
function drupalgap_loading_message_hide() {
  try {
    /*$.mobile.loading('hide');
    drupalgap.loading = false;
    drupalgap.loader = 'loading';*/
    setTimeout(function() {
        $.mobile.loading('hide');
        drupalgap.loading = false;
        drupalgap.loader = 'loading';
    }, 100);
  }
  catch (error) { console.log('drupalgap_loading_message_hide - ' + error); }
}

/**
 * Returns the jQM loader options based on the current mode and settings.js.
 * @return {Object}
 */
function drupalgap_loader_options() {
  try {
    var mode = drupalgap.loader;
    var text = 'Loading...';
    var textVisible = true;
    if (mode == 'saving') { var text = 'Saving...'; }
    var options = {
      text: text,
      textVisible: textVisible
    };
    if (drupalgap.settings.loader && drupalgap.settings.loader[mode]) {
      options = drupalgap.settings.loader[mode];
    }
    return options;
  }
  catch (error) { console.log(' - ' + error); }
}

/**
 * Returns the suggested max width for elements within the content area.
 * @return {Number}
 */
function drupalgap_max_width() {
  try {
    var padding = parseInt($('.ui-content').css('padding'));
    if (isNaN(padding)) { padding = 16; } // use a 16px default if needed
    return $(document).width() - padding * 2;
  }
  catch (error) { console.log('drupalgap_max_width - ' + error); }
}

/**
 * Checks to see if the current user has access to the given path. Returns true
 * if the user has access, false otherwise. You may optionally pass in a user
 * account object as the second argument to check access on a specific user.
 * @param {String} path
 * @return {Boolean}
 */
function drupalgap_menu_access(path) {
  try {
    // User #1 is allowed to do anything, I mean anything.
    if (Drupal.user.uid == 1) { return true; }
    // Everybody else will not have access unless we prove otherwise.
    var access = false;
    if (drupalgap.menu_links[path]) {
      // Check to see if there is an access callback specified with the menu
      // link.
      if (typeof drupalgap.menu_links[path].access_callback === 'undefined') {
        // No access call back specified, if there are any access arguments
        // on the menu link, then it is assumed they are user permission machine
        // names, so check that user account's role(s) for that permission to
        // grant access.
        if (drupalgap.menu_links[path].access_arguments) {
          if ($.isArray(drupalgap.menu_links[path].access_arguments)) {
            $.each(drupalgap.menu_links[path].access_arguments, function(index, 
              permission) {
              access = user_access(permission);
              if (access) { return false; }
            });
          }
        }
        else {
          // There is no access callback and no access arguments specified with
          // the menu link, so we'll assume everyone has access.
          access = true;
        }
      }
      else {

        // An access callback function is specified for this path...

        // START HERE: https://github.com/signalpoint/DrupalGap/issues/191

        var function_name = drupalgap.menu_links[path].access_callback;
        if (drupalgap_function_exists(function_name)) {
          // Grab the access callback function. If there are any access args
          // send them along, or just call the function directly.
          // access arguments.
          var fn = window[function_name];
          if (drupalgap.menu_links[path].access_arguments) {
            var access_arguments =
              drupalgap.menu_links[path].access_arguments.slice(0);
            var args = arg();
            drupalgap_prepare_argument_entities(access_arguments, args);
            return fn.apply(null, Array.prototype.slice.call(access_arguments));
          }
          else { return fn(); }
        }
        else {
          console.log('drupalgap_menu_access - access call back (' +
            function_name + ') does not exist'
          );
        }
      }
    }
    else {
      console.log('drupalgap_menu_access - path (' + path + ') does not exist');
    }
    return access;
  }
  catch (error) { console.log('drupalgap_menu_access - ' + error); }
}

/**
 * @deprecated Use drupal_module_load() instead.
 * @param {String} name
 * @return {Object}
 */
function drupalgap_module_load(name) {
  try {
    return module_load(name);
  }
  catch (error) { console.log('drupalgap_module_load - ' + error); }
}

/**
 * Given a module bundle type, this will return the path to that module bundle's
 * directory.
 * @param {String} bundle
 * @return {String}
 */
function drupalgap_modules_get_bundle_directory(bundle) {
  try {
    dir = '';
    if (bundle == 'core') { dir = 'modules'; }
    else if (bundle == 'contrib') { dir = 'app/modules'; }
    else if (bundle == 'custom') { dir = 'app/modules/custom'; }
    return dir;
  }
  catch (error) {
    console.log('drupalgap_modules_get_bundle_directory - ' + error);
  }
}

/**
 * Given a router path (and optional path, defaults to current drupalgap path if
 * one isn't provided), this takes the path's arguments and replaces any
 * wildcards (%) in the router path with the corresponding path argument(s). It
 * then returns the assembled path. Returns false otherwise.
 * @param {String} input_path
 * @return {*}
 */
function drupalgap_place_args_in_path(input_path) {
  try {
    var assembled_path = false;
    if (input_path) {

      // Determine path to use and break it up into its args.
      var path = drupalgap_path_get();
      if (arguments[1]) { path = arguments[1]; }
      var path_args = arg(null, path);

      // Grab wild cards from router path then replace each wild card with
      // the corresponding path arg.
      var wildcards;
      var input_path_args = arg(null, input_path);
      if (input_path_args && input_path_args.length > 0) {
        $.each(input_path_args, function(index, arg) {
            if (arg == '%') {
              if (!wildcards) { wildcards = []; }
              wildcards.push(index);
            }
        });
        if (wildcards && wildcards.length > 0) {
          $.each(wildcards, function(index, wildcard) {
              if (path_args[wildcard]) {
                input_path_args[wildcard] = path_args[wildcard];
              }
          });
          assembled_path = input_path_args.join('/');
        }
      }
    }
    return assembled_path;
  }
  catch (error) {
    console.log('drupalgap_place_args_in_path - ' + error);
  }
}
/**
 * Converts a hook_menu items page_arguments path like node/123 so arg zero
 * would be 'node' and arg 1 would be the loaded entity node. Also works for MVC
 * page paths, converts the integer into an MVC item.
 * @param {Array} page_arguments
 * @param {Array} args
 */
function drupalgap_prepare_argument_entities(page_arguments, args) {
  try {
    // If argument zero is an entity type (or base type, e.g. taxonomy), and we
    // have at least one integer argument, replace the page call back's integer
    // argument index with the loaded entity.
    if (args.length > 1 &&
          (
            args[0] == 'comment' ||
            args[0] == 'node' ||
            (args[0] == 'taxonomy' &&
              (args[1] == 'vocabulary' || args[1] == 'term')
            ) ||
            args[0] == 'user' ||
            args[0] == 'item'
          )
    ) {
      var found_int_arg = false;
      var int_arg_index = null;
      for (var i = 0; i < args.length; i++) {
        if (is_int(parseInt(args[i]))) {
          int_arg_index = i; // Save the arg index so we can replace it later.
          found_int_arg = true;
          break;
        }
      }
      if (!found_int_arg) { return; }
      // Determine the naming convention for the entity load function.
      var load_function_prefix = args[0]; // default
      if (args[0] == 'taxonomy') {
        if (args[1] == 'vocabulary' || args[1] == 'term') {
          load_function_prefix = args[0] + '_' + args[1];
        }
      }
      var load_function = load_function_prefix + '_load';
      // If the load function exists, load the entity.
      if (drupalgap_function_exists(load_function)) {
        var entity_fn = window[load_function];
        var entity = null;
        // Load the entity. MVC items need to pass along the module name and
        // model type to its load function. All other entity load functions just
        // need the entity id.
        if (args[0] == 'item') {
          entity = entity_fn(args[1], args[2], parseInt(args[int_arg_index]));
        }
        else {
          // Force a reload (reset) when we load the entity if we are editing
          // the entity.
          if (arg(2) == 'edit') {
            entity = entity_fn(parseInt(args[int_arg_index]), { reset: true });
          }
          else {
             entity = entity_fn(parseInt(args[int_arg_index]));
          }
        }
        // Now that we have the entity loaded, replace the first integer we find
        // in the page arguments with the loaded entity.
        $.each(page_arguments, function(index, page_argument) {
            if (is_int(parseInt(page_argument))) {
              page_arguments[index] = entity;
              return false;
            }
        });
      }
      else {
        console.log(
          'drupalgap_prepare_argument_entities - ' +
          'load function not implemented! ' + load_function
        );
      }
    }
  }
  catch (error) {
    console.log('drupalgap_prepare_argument_entities - ' + error);
  }
}

/**
 * Given a page id, this will remove it from the DOM.
 * @param {String} page_id
 */
function drupalgap_remove_page_from_dom(page_id) {
  try {
    $('#' + page_id).empty().remove();
  }
  catch (error) { console.log('drupalgap_remove_page_from_dom - ' + error); }
}

/**
 * Sets a message to display to the user. Optionally pass in a second argument
 * to specify the message type: status, warning, error
 * @param {String} message
 */
function drupalgap_set_message(message) {
  try {
    if (empty(message)) { return; }
    var type = 'status';
    if (arguments[1]) { type = arguments[1]; }
    var msg = {
      message: message,
      type: type
    };
    drupalgap.messages.push(msg);
  }
  catch (error) { console.log('drupalgap_set_message - ' + error); }
}

/**
 * Clears the messages from the current page. Optionally pass in a page id to
 * clear messages from a particular page.
 */
function drupalgap_clear_messages() {
  try {
    var page_id = arguments[0];
    if (empty(page_id)) { page_id = drupalgap_get_page_id(); }
    $('#' + page_id + ' div.messages').remove();
  }
  catch (error) { console.log('drupalgap_clear_messages - ' + error); }
}

/**
 * Implementation of drupal_set_title().
 * @param {String} title
 */
function drupalgap_set_title(title) {
  try {
    if (title) { drupalgap.page.title = title; }
  }
  catch (error) { console.log('drupalgap_set_title - ' + error); }
}

/**
 * Implements hook_services_preprocess().
 * @param {Object} options
 */
function drupalgap_services_preprocess(options) {
  try {
    // Show the loading icon.
    drupalgap_loading_message_show();
  }
  catch (error) { console.log('drupalgap_services_preprocess - ' + error); }
}

/**
 * Implements hook_services_postprocess().
 * @param {Object} options
 * @param {Object} result
 */
function drupalgap_services_postprocess(options, result) {
  try {
    // Hide the loading icon.
    drupalgap_loading_message_hide();
  }
  catch (error) { console.log('drupalgap_services_postprocess - ' + error); }
}

/**
 * Implements hook_services_request_pre_postprocess_alter().
 * @param {Object} options
 * @param {*} result
 */
function drupalgap_services_request_pre_postprocess_alter(options, result) {
  try {
    // Extract drupalgap system connect service resource results.
    if (options.service == 'system' && options.resource == 'connect') {
      drupalgap.entity_info = result.entity_info;
      drupalgap.field_info_instances = result.field_info_instances;
      drupalgap.field_info_fields = result.field_info_fields;
      drupalgap.taxonomy_vocabularies =
        drupalgap_taxonomy_vocabularies_extract(
          result.taxonomy_vocabularies
        );
      drupalgap_service_resource_extract_results({
        service: options.service,
        resource: options.resource,
        data: result
      });
    }
    // Whenever a user logs in, out or registers, remove all pages from the DOM.
    else if (options.service == 'user' &&
      (options.resource == 'logout' || options.resource == 'login' ||
        options.resource == 'register')) {
      drupalgap_remove_pages_from_dom();
    }
    // Whenever an entity is created, updated or deleted, remove the
    // corresponing DrupalGap core page(s) from the DOM so the pages will be
    // rebuilt properly next time they are loaded.
    else if (
      in_array(options.resource, ['create', 'update', 'delete']) &&
      in_array(options.service, entity_types())
    ) {
      var entity_type = options.entity_type;
      var entity_id = options.entity_id;
      var bundle = options.bundle || null;
      var paths = [];
      if (options.resource != 'create') {
        var prefix = entity_type;
        if (in_array(entity_type, ['taxonomy_vocabulary', 'taxonomy_term'])) {
          prefix = prefix.replace('_', '/', prefix);
        }
        paths.push(prefix + '/' + entity_id);
        paths.push(prefix + '/' + entity_id + '/view');
        // @todo This page won't get removed since it is the current page...
        // maybe when an entity is updated or deleted, we need a transitional
        // page that says "Deleting [entity]..." that way we can remove this
        // page (since it is not possible to remove the current page in jQM).
        // Actually now that I think about, we should have a confirmation page
        // when deleting an entity just like Drupal, and that should take care
        // of the deletion case. Not sure what to do about the update case...
        // maybe some type of pageshow handler on entity view pages that can
        // remove the edit form for the entity.
        paths.push(prefix + '/' + entity_id + '/edit');
      }
      else {
        switch (entity_type) {
          case 'node':
            // @todo This page won't get removed since it is the current page...
            paths.push('node/add/' + bundle);
            break;
        }
      }
      // Add extras depending on the entity type.
      switch (entity_type) {
        case 'node': paths.push('node'); break;
        case 'taxonomy_vocabulary': paths.push('taxonomy/vocabularies'); break;
        case 'user': paths.push('user-listing'); break;
      }
      // Convert the paths to page ids, then remove them from the DOM.
      var pages = [];
      $.each(paths, function(index, path) {
          pages.push(drupalgap_get_page_id(path));
      });
      $.each(pages, function(index, page_id) {
          drupalgap_remove_page_from_dom(page_id);
      });
    }
  }
  catch (error) {
    console.log('drupalgap_services_request_pre_postprocess_alter - ' + error);
  }
}

/**
 * @deprecated - Loads the settings specified in app/settings.js into the app.
 */
function drupalgap_settings_load() {
  try {
    console.log('WARNING: drupalgap_settings_load() is deprecated!');
    //drupal_settings_load();
  }
  catch (error) {
    console.log('drupalgap_settings_load - ' + error);
  }
}

/**
 * This calls all implementations of hook_theme and builds the DrupalGap theme
 * registry.
 */
function drupalgap_theme_registry_build() {
  try {
    var modules = module_implements('theme');
    $.each(modules, function(index, module) {
        var function_name = module + '_theme';
        var fn = window[function_name];
        var hook_theme = fn();
        $.each(hook_theme, function(element, variables) {
            variables.path = drupalgap_get_path(
              'theme',
              drupalgap.settings.theme
            );
            drupalgap.theme_registry[element] = variables;
        });
    });
  }
  catch (error) { console.log('drupalgap_theme_registry_build - ' + error); }
}

/**
 * Given a variable name and value, this will save the value to local storage,
 * keyed by its name.
 * @param {String} name
 * @param {*} value
 * @return {*}
 */
function variable_set(name, value) {
  try {
    if (!value) { value = ' '; } // store null values as a single space*
    else if (is_int(value)) { value = value.toString(); }
    else if (typeof value === 'object') { value = JSON.stringify(value); }
    return window.localStorage.setItem(name, value);
    // * phonegap won't store an empty string in local storage
  }
  catch (error) { drupalgap_error(error); }
}

/**
 * Given a variable name and a default value, this will first attempt to load
 * the variable from local storage, if it can't then the default value will be
 * returned.
 * @param {String} name
 * @param {*} default_value
 * @return {*}
 */
function variable_get(name, default_value) {
  try {
    var value = window.localStorage.getItem(name);
    if (!value) { value = default_value; }
    if (value == ' ') { value = ''; } // Convert single spaces to empty strings.
    return value;
  }
  catch (error) { drupalgap_error(error); }
}

/**
 * Given an JSON object, this will output it to the console. It accepts an
 * optional boolean as second argument, if it is false the output sent to the
 * console will not use pretty printing in a Chrome/Ripple environment.
 * @param {*} data
 */
function dpm(data) {
  try {
    // Show the caller name.
    //var caller = arguments.callee.caller.name + '()';
    //console.log(caller);
    if (data) {
      // If we're in ripple we can output it directly to the console and it will
      // have pretty printing, otherwise we'll stringify it first.
      // TODO - be careful, when just using console.log() with ripple, it will
      // always print out the final value of data (because of pass by reference)
      // this can be very misleading for debugging things.
      if (typeof parent.window.ripple === 'function') {
        if (typeof arguments[1] !== 'undefined' && arguments[1] == false) {
          console.log(JSON.stringify(data));
        }
        else {
          console.log(data);
        }
      }
      else {
        console.log(JSON.stringify(data));
      }
    }
    else {
      console.log('<null>');
    }
  }
  catch (error) { console.log('dpm - ' + error); }
}

/**
 * Returns the current time as a string with the format: "yyyy-mm-dd hh:mm:ss".
 * @return {String}
 */
function date_yyyy_mm_dd_hh_mm_ss() {
  try {
    var result;
    if (arguments[0]) { result = arguments[0]; }
    else { result = date_yyyy_mm_dd_hh_mm_ss_parts(); }
    return result['year'] + '-' + result['month'] + '-' + result['day'] + ' ' +
           result['hour'] + ':' + result['minute'] + ':' + result['second'];
  }
  catch (error) { console.log('date_yyyy_mm_dd_hh_mm_ss - ' + error); }
}

/**
 * Returns an array with the parts for the current time. You may optionally
 * pass in a JS date object to use that date instead.
 * @return {Array}
 */
function date_yyyy_mm_dd_hh_mm_ss_parts() {
  try {
    var result = [];
    var now = null;
    if (arguments[0]) { now = arguments[0]; }
    else { now = new Date(); }
    var year = '' + now.getFullYear();
    var month = '' + (now.getMonth() + 1);
    if (month.length == 1) { month = '0' + month; }
    var day = '' + now.getDate();
    if (day.length == 1) { day = '0' + day; }
    var hour = '' + now.getHours();
    if (hour.length == 1) { hour = '0' + hour; }
    var minute = '' + now.getMinutes();
    if (minute.length == 1) { minute = '0' + minute; }
    var second = '' + now.getSeconds();
    if (second.length == 1) { second = '0' + second; }
    result['year'] = year;
    result['month'] = month;
    result['day'] = day;
    result['hour'] = hour;
    result['minute'] = minute;
    result['second'] = second;
    return result;
  }
  catch (error) { console.log('date_yyyy_mm_dd_hh_mm_ss_parts - ' + error); }
}

/**
 * Given a year and month (0-11), this will return the number of days in that
 * month.
 * @see http://stackoverflow.com/a/1810990/763010
 * @param {Number} year
 * @param {Number} month
 * @return {Number}
 */
function date_number_of_days_in_month(year, month) {
  try {
    var d = new Date(year, month, 0);
    return d.getDate();
  }
  catch (error) { console.log('date_number_of_days_in_month - ' + error); }
}

/**
 * @see http://www.dconnell.co.uk/blog/index.php/2012/03/12/scroll-to-any-element-using-jquery/
 */
function scrollToElement(selector, time, verticalOffset) {
  try {
    time = typeof(time) != 'undefined' ? time : 1000;
    verticalOffset = typeof(verticalOffset) != 'undefined' ? verticalOffset : 0;
    element = $(selector);
    offset = element.offset();
    offsetTop = offset.top + verticalOffset;
    $('html, body').animate({
        scrollTop: offsetTop
    }, time);
  }
  catch (error) { console.log('scrollToElement - ' + error); }
}

